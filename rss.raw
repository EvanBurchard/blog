<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>in Code — Entries</title><link>http://home.jle0.com:4111/</link><description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</description><item><title>Placeholder Entry</title><link>http://home.jle0.com:4111/entry/placeholder-entry.html</link><description>&lt;p&gt;Placeholder entry.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Markdown supported&lt;/li&gt;
&lt;li&gt;Inline HTML supported&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;first-section&quot;&gt;First section&lt;/h2&gt;
&lt;p&gt;Hi!&lt;/p&gt;</description><author>Justin Le</author><category>Placeholder</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/placeholder-entry.html</guid><pubDate>Fri, 20 Jan 2017 05:02:06 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Placeholder</dc:subject><dc:date>2017-01-20</dc:date></item><item><title>Auto: Building a declarative chat bot with implicit serialization</title><link>http://home.jle0.com:4111/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html</link><description>&lt;p&gt;Today we’re going to look at building a declarative chatbot using the denotational components from the &lt;a href=&quot;http://hackage.haskell.org/package/auto&quot;&gt;auto&lt;/a&gt; library that is modular and has implicit serialization. Most importantly, we’ll look at the “design process”, and principles of architecture that you can apply to your own projects.&lt;/p&gt;
&lt;h2 id=&quot;overall-layout&quot;&gt;Overall Layout&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;auto&lt;/em&gt; is a library that at the highest level gives you a stream transformer. Transform a stream of inputs to a stream of outputs. So when we approach a chat bot, we have to think — what are the inputs, and what are the outputs?&lt;/p&gt;
&lt;p&gt;The choice should be pretty straightforward – our input stream is a stream of input messages from the irc server, and our output stream is a stream of messages to send to the server. In haskell we like types, so let’s make some types.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L29-44&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; {&lt;span class=&quot;ot&quot;&gt; _inMessageNick   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;
                           ,&lt;span class=&quot;ot&quot;&gt; _inMessageBody   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;
                           ,&lt;span class=&quot;ot&quot;&gt; _inMessageSource ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;
                           ,&lt;span class=&quot;ot&quot;&gt; _inMessageTime   ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;
                           } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]) &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monoid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    mempty  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; M.empty
    mappend (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; m1) (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; m2)
            &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (M.unionWith (&lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt;) m1 m2)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We make some type aliases to make things a bit clearer. Our inputs are going to be a data type/“struct” with a nick, a body, a source, and a time. Our outputs are going to be a &lt;code&gt;Data.Map.Map&lt;/code&gt; from &lt;em&gt;containers&lt;/em&gt; associating channels with messages to send. I’m just adding here a &lt;code&gt;Monoid&lt;/code&gt; instance in case we want to combine &lt;code&gt;OutMessages&lt;/code&gt; maps.&lt;/p&gt;
&lt;p&gt;The type for a chat bot over a monad &lt;code&gt;m&lt;/code&gt; would then be:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L46-46&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;ChatBot&lt;/code&gt; takes a stream of &lt;code&gt;InMessage&lt;/code&gt;s and returns a stream of &lt;code&gt;OutMessages&lt;/code&gt;s…and might have effects in &lt;code&gt;m&lt;/code&gt; as it does so.&lt;/p&gt;
&lt;p&gt;Note that we get a free instance of &lt;code&gt;Monoid&lt;/code&gt; on &lt;code&gt;ChatBot m&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;mappend&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That takes two &lt;code&gt;ChatBot&lt;/code&gt;s and creates a new &lt;code&gt;ChatBot&lt;/code&gt; that forks the input stream (sends all &lt;code&gt;InMessage&lt;/code&gt;s) to both of the original ones, and &lt;code&gt;mappend&lt;/code&gt;s the results. So the new &lt;code&gt;ChatBot&lt;/code&gt; will send message to both original ones and return a “combined” &lt;code&gt;OutMessages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, not all modules really have to “care” about the room of the outputs…they might just always reply directly to the room they received the message on. So it’ll help us to also make another sort of &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L47-47&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;RoomBot&lt;/code&gt; doesn’t care where its messages go…it just replies to the same room it got its input from. It outputs a blip stream of message lists; when it doesn’t want to send messages out, it doesn’t emit. When it does, it &lt;em&gt;does&lt;/em&gt; emit, with the list of messages.&lt;/p&gt;
&lt;h3 id=&quot;converting&quot;&gt;Converting&lt;/h3&gt;
&lt;p&gt;We can write a quick helper function to convert a &lt;code&gt;RoomBot&lt;/code&gt; into a full-on &lt;code&gt;ChatBot&lt;/code&gt;, so we can merge them together with &lt;code&gt;mappend&lt;/code&gt;/&lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L49-52&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;perRoom ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
perRoom rb &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc inp &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    messages &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; fromBlips [] &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; rb &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; inp
    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; M.singleton (_inMessageSource inp) messages&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This example uses proc notation; see this &lt;a href=&quot;https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md#brief-primer-on-proc-notation&quot;&gt;proc notation primer&lt;/a&gt; for a quick run-down of the relevant aspects)&lt;/p&gt;
&lt;p&gt;We say that &lt;code&gt;messages&lt;/code&gt; is just the output of &lt;code&gt;rb&lt;/code&gt; fed with the input, except it “collapses” the blip stream into a normal stream by substituting in &lt;code&gt;[]&lt;/code&gt; whenever the stream doesn’t emit. So &lt;code&gt;messages&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; when &lt;code&gt;rb&lt;/code&gt; doesn’t emit (it doesn’t want to send anything), and &lt;code&gt;messages&lt;/code&gt; is &lt;code&gt;[message1, message2 ...]&lt;/code&gt;, with the emitted contents, when it &lt;em&gt;does&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The “output” will be a singleton map with the source of the input and the messages to send to that source.&lt;/p&gt;
&lt;p&gt;So now if we have a &lt;code&gt;RoomBot m&lt;/code&gt;, we can convert it up into a &lt;code&gt;ChatBot m&lt;/code&gt;, and combine it/merge it with other &lt;code&gt;ChatBot m&lt;/code&gt;s.&lt;/p&gt;
&lt;h3 id=&quot;the-whole-deal&quot;&gt;The whole deal&lt;/h3&gt;
&lt;p&gt;We have enough now then to imagine our entire program architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write a bunch of separate modules, as &lt;code&gt;ChatBot m&lt;/code&gt;s or &lt;code&gt;RoomBot m&lt;/code&gt;s, which ever one is more convenient. The beauty is that we can merge them all together in the end with our promoter.&lt;/li&gt;
&lt;li&gt;Combine all of our modules with &lt;code&gt;mconcat&lt;/code&gt; — that is, something like &lt;code&gt;chatBot = mconcat [module1, module2, module3, module 4]&lt;/code&gt;. And that’s it, that’s our entire chat bot!&lt;/li&gt;
&lt;li&gt;Having an overall &lt;code&gt;chatBot :: ChatBot m&lt;/code&gt;, we can use something like &lt;code&gt;runOnChan&lt;/code&gt; from &lt;code&gt;Control.Auto.Run&lt;/code&gt; to have it exist on a concurrent thread and whatch a channel for input, and perform an action on output.&lt;/li&gt;
&lt;li&gt;Find an out-of-the-box irc library that can trigger adding something to a concurrent queue when it receives a message, and where you can send messages to rooms.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And…that’s it. Program logic in our &lt;code&gt;ChatBot m&lt;/code&gt;s, and handling the “view”/input with our backend.&lt;/p&gt;
&lt;h4 id=&quot;free-serialization&quot;&gt;Free Serialization&lt;/h4&gt;
&lt;p&gt;Remember that &lt;em&gt;auto&lt;/em&gt; gives us the ability to serialize and resume our &lt;code&gt;Auto&lt;/code&gt;s for free…so we can at any time save the state of our chat bot to disk, and resume it when we re-load. We don’t have to worry about manually gathering our state between each &lt;code&gt;Auto&lt;/code&gt; and writing serialization code.&lt;/p&gt;
&lt;p&gt;There’s a “convenience combinator” called &lt;code&gt;serializing&#39;&lt;/code&gt; in &lt;code&gt;Control.Auto.Serialize&lt;/code&gt; (it’s one of many different ones that can do something like this; &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Serialize.html&quot;&gt;check out the module&lt;/a&gt; to see other ways of varying disciplined-ness!). It’ll take any &lt;code&gt;Auto&lt;/code&gt; and turn it into an &lt;code&gt;Auto&lt;/code&gt; that “self-serializes” — when you begin running it, it automatically loads its previous state if it exists, and as you run it, it automatically maintains an updated “resume state” on disk.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;serializing&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; FilePath &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;serializing&#39; fp :: MonadIO m =&amp;gt; ChatBot m -&amp;gt; ChatBot m&lt;/code&gt;. It looks a lot like an “identity-ish” sort of function, right? That’s because it is meant to behave &lt;em&gt;like&lt;/em&gt; &lt;code&gt;id&lt;/code&gt;…the returned &lt;code&gt;ChatBot&lt;/code&gt; behaves identical to the previous one…except it splices in the serializing action in-between. (We are in &lt;code&gt;MonadIO&lt;/code&gt; now, because the &lt;code&gt;Auto&lt;/code&gt; has to access &lt;code&gt;IO&lt;/code&gt; in order to serialize itself between steps).&lt;/p&gt;
&lt;p&gt;So, instead of&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [module1, module2, module3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;state.dat&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; mconcat [module1, module2, module3]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now our &lt;code&gt;chatBot&lt;/code&gt; will automatically resume itself on program startup, and keep its state backed up on disk at &lt;code&gt;state.dat&lt;/code&gt;. We get this for free, without doing anything extra in the composition of our modules.&lt;/p&gt;
&lt;p&gt;Note that in practice, with a bot you are actively developing, this might not be the best idea. &lt;code&gt;serializing&#39;&lt;/code&gt; &lt;em&gt;analyzes&lt;/em&gt; your &lt;code&gt;Auto&lt;/code&gt;s to determine a serialization and reloading strategy, and applies that to do its job. However, if you, for example, add a new module to your chat bot…the serialization strategy will change, and your new bot won’t be able to resume old save files.&lt;/p&gt;
&lt;p&gt;One solution at this point is just to serialize individual modules that you do not see yourself changing…or even just serializing parts of the modules you don’t see yourself changing. Then you can change each portion separately and not worry about migrtion issues.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [ serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;m1.dat&amp;quot;&lt;/span&gt; module1
                  , module2
                  , serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;m3.dat&amp;quot;&lt;/span&gt; module3
                  ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re not all-or-nothing now here, either! So, &lt;code&gt;module1&lt;/code&gt; gets serialized and auto-resumed from &lt;code&gt;m1.dat&lt;/code&gt;, &lt;code&gt;module2&lt;/code&gt; is not serialized at all, and &lt;code&gt;module3&lt;/code&gt; now gets serialized and auto-resumed from &lt;code&gt;m3.dat&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;irc-backend-the-ugly-part&quot;&gt;IRC Backend (the ugly part)&lt;/h2&gt;
&lt;p&gt;Before we get started on our actual modules, let’s just write out the backend/interface between our &lt;code&gt;ChatBot&lt;/code&gt; and irc to get it out of the way. This will vary based on what library you use; I’m going to use the &lt;a href=&quot;http://hackage.haskell.org/package/simpleirc&quot;&gt;simpleirc-0.3.0&lt;/a&gt;, but feel free to use any interface/library you want.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L25-199&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;withIrcConf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IrcConfig&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
withIrcConf ircconf chatbot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- chan to receive `InMessage`s&lt;/span&gt;
    inputChan &lt;span class=&quot;ot&quot;&gt;&amp;lt;- newChan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt;)

    &lt;span class=&quot;co&quot;&gt;-- configuring IRC&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; events   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; cEvents ircconf &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [ &lt;span class=&quot;dt&quot;&gt;Privmsg&lt;/span&gt; (onMessage inputChan) ]
        ircconf&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ircconf { cEvents &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; events }

    &lt;span class=&quot;co&quot;&gt;-- connect; simplified for demonstration purposes&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Right&lt;/span&gt; server &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; connect ircconf&amp;#39; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- run `chatbot` on `inputChan`&lt;/span&gt;
    void &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; forkIO &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; void &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt;
        runOnChanM id (processOutput server) inputChan chatbot

  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- what to do when `chatBot` outputs&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    processOutput ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MIrc&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
    processOutput server (&lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; outs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      print outs
      _ &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; flip M.traverseWithKey outs &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \channel messages &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; channel&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; encodeUtf8 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; pack &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; channel
        forM_ messages &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \message &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; message&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; encodeUtf8 &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; pack &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; message
          sendMsg server channel&amp;#39; message&amp;#39;
      return &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- &amp;quot;yes, continue on&amp;quot;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;-- what to do when you get a new message&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    onMessage ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;EventFunc&lt;/span&gt;
    onMessage inputChan &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; \_ message &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; (mNick message, mOrigin message) &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; src) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
          time &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; getCurrentTime
          writeChan inputChan &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; (unpack (decodeUtf8 nick))
                                          (unpack (decodeUtf8 (mMsg message)))
                                          (unpack (decodeUtf8 src))
                                          time

&lt;span class=&quot;ot&quot;&gt;conf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IrcConfig&lt;/span&gt;
conf &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (mkDefaultConfig &lt;span class=&quot;st&quot;&gt;&amp;quot;irc.freenode.org&amp;quot;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;testautobot&amp;quot;&lt;/span&gt;) { cChannels &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;#jlebot-test&amp;quot;&lt;/span&gt;] }

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    withIrcConf conf chatBot
    forever (threadDelay &lt;span class=&quot;dv&quot;&gt;1000000000&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That should be it…don’t worry if you don’t understand all of it, most of it is just implementation details from &lt;code&gt;simpleirc&lt;/code&gt;. The overall loop is &lt;code&gt;runOnChanM&lt;/code&gt; waits on a separate thread for &lt;code&gt;inputChan&lt;/code&gt;…when it gets input, it runs it through &lt;code&gt;ChatBot&lt;/code&gt; and sends the outputs through &lt;em&gt;simpleirc&lt;/em&gt;’s interface. Meanwhile, &lt;code&gt;onMessage&lt;/code&gt; is triggered whenever &lt;em&gt;simpleirc&lt;/em&gt; receives a message, where it prepares an &lt;code&gt;InMessage&lt;/code&gt; and drops it off at &lt;code&gt;inputChan&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;runOnChanM ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m
           &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (forall c&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; m c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; c)   &lt;span class=&quot;co&quot;&gt;-- convert `m` to `IO`&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)            &lt;span class=&quot;co&quot;&gt;-- handle output&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Chan&lt;/span&gt; a                    &lt;span class=&quot;co&quot;&gt;-- chan to await input on&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b                &lt;span class=&quot;co&quot;&gt;-- `Auto` to run&lt;/span&gt;
           &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;runOnChanM&lt;/code&gt; runs any &lt;code&gt;Auto m a b&lt;/code&gt;, as long as there’s a way to convert it to &lt;code&gt;Auto IO a b&lt;/code&gt; (we can use a &lt;code&gt;ChatBot IO&lt;/code&gt;, so we just put &lt;code&gt;id&lt;/code&gt; there). You give it a “handler” &lt;code&gt;b -&amp;gt; IO Bool&lt;/code&gt; that it run whenever it outputs; if the handler returns &lt;code&gt;False&lt;/code&gt;, then the whole thing stops. You give it the &lt;code&gt;Chan a&lt;/code&gt; to await for input &lt;code&gt;a&lt;/code&gt;s on, and it takes care of the rest. It blocks until the handler returns &lt;code&gt;False&lt;/code&gt;, where it’ll return the “updated” &lt;code&gt;Auto m a b&lt;/code&gt; with updated state after running through all of those inputs.&lt;/p&gt;
&lt;p&gt;Phew. With that out of the way, let’s get right on to the fun part — building our chat bot modules.&lt;/p&gt;
&lt;h2 id=&quot;the-modules&quot;&gt;The Modules&lt;/h2&gt;
&lt;h3 id=&quot;seenbot&quot;&gt;seenBot&lt;/h3&gt;
&lt;p&gt;What’s a common module? Well, we can write a module that keeps track of the last time any user was “seen” (sent a message), and then respond when there is a query.&lt;/p&gt;
&lt;p&gt;There are two components here…the part that keeps track of the last seen time, and the part that responds to queries.&lt;/p&gt;
&lt;p&gt;Keeping track of our last seen time sounds like a job that takes in a stream of &lt;code&gt;(Nick, UTCTime)&lt;/code&gt; pairs and outputs a stream of &lt;code&gt;Map Nick UTCTime&lt;/code&gt;, where we could look up the last seen time for a nick by looking up the nick in the map.&lt;/p&gt;
&lt;p&gt;Logically, this is pretty straightforward, and anything other than &lt;code&gt;accum&lt;/code&gt; (which is like &lt;code&gt;foldl&#39;&lt;/code&gt;) would really be a bit overkill; every input would just update the output map.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L80-86&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
    trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;



&lt;span class=&quot;ot&quot;&gt;trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;accum&lt;/code&gt; takes the same thing that &lt;code&gt;foldl&lt;/code&gt; takes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foldl&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt;            (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b
&lt;span class=&quot;ot&quot;&gt;accum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; (b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So it basically “folds up” the entire history of inputs, with a starting value. Every time an input comes, the output is the new folded history of inputs. You can sort of think of it as it applying the function to any incoming values to an internal accumulator and updating it at every step.&lt;/p&gt;
&lt;p&gt;The next component is just to respond to requests. We want to do something on some “triggering” input. Every once in a while, some input will come that will “trigger” some special response. This is a sign that we can use &lt;em&gt;blip streams&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L82-86&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;



&lt;span class=&quot;ot&quot;&gt;queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
    getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;queryBlips&lt;/code&gt; takes an input stream of strings and turns it into an output &lt;em&gt;blip stream&lt;/em&gt; that emits with a &lt;code&gt;Nick&lt;/code&gt; whenever the input stream contains a request in the form of &lt;code&gt;&amp;quot;@seen [nick]&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With these simple blocks, we can build our &lt;code&gt;seenBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- seenBot :: Monad m =&amp;gt; Auto m InMessage (Blip [Message])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L67-86&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;seenBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m
seenBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg _ time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    seens  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; trackSeens &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, time)

    queryB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; queryBlips &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; msg

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; respond ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        respond qry &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; M.lookup qry seens &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
                        &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; t  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [qry &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; last seen at &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show t &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]
                        &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;No record of &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; qry &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; respond &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; queryB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackSeens ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;)
    trackSeens &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; accum (\mp (nick, time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insert nick time mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we define &lt;code&gt;respond&lt;/code&gt; as a function that takes a &lt;code&gt;Nick&lt;/code&gt; and returns the output &lt;code&gt;[Message]&lt;/code&gt;. We could have also defined it outside as a helper function &lt;code&gt;respond :: Map Nick UTCTime -&amp;gt; Nick -&amp;gt; [Message]&lt;/code&gt;…but &lt;code&gt;seens&lt;/code&gt; is already in scope, so we might as well just do it there.&lt;/p&gt;
&lt;p&gt;For our output, we use the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams. &lt;code&gt;respond &amp;lt;$&amp;gt; queryB&lt;/code&gt; is a blip stream that emits whenever &lt;code&gt;queryB&lt;/code&gt; emits (so, whenever there is a query input), but replaces the emitted value with the result of the function on the value. So whenever &lt;code&gt;queryB&lt;/code&gt; emits, this whole thing emits with &lt;code&gt;respond&lt;/code&gt; applied to whatever &lt;code&gt;Nick&lt;/code&gt; was emitted — in this case, our &lt;code&gt;[Message]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Short, sweet, simple. In fact, &lt;code&gt;trackSeens&lt;/code&gt; and &lt;code&gt;queryBlips&lt;/code&gt; are small enough that their definition could really have been inlined. Breaking them down just allowed us to look at them individually for this tutorial.&lt;/p&gt;
&lt;p&gt;So that’s it for that; also, if we wanted &lt;code&gt;seenBot&lt;/code&gt; to serialize and persist across sessions, all we have to do is use:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seenbot.dat&amp;quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; seenBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, right?&lt;/p&gt;
&lt;p&gt;If we forsee ourselves adding more features to &lt;code&gt;seenBot&lt;/code&gt;, we can future-proof our &lt;code&gt;seenBot&lt;/code&gt; for now by only serializing &lt;code&gt;trackSeens&lt;/code&gt;, meaning replacing that line with:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;    seens &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seen.dat&amp;quot;&lt;/span&gt; trackSeens &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, time)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;serializing&#39; fp&lt;/code&gt; acts as a sort of “identity”, so you can drop it in anywhere and you’d expect it to behave the same.&lt;/p&gt;
&lt;h3 id=&quot;repbot&quot;&gt;repBot&lt;/h3&gt;
&lt;p&gt;Another common bot is a “reputation bot”, which allows users to increment or decrement another user’s reputation scores, and look up a user’s total score.&lt;/p&gt;
&lt;p&gt;Again there are two components — keeping track of the scores of all of the users, and responding to requests.&lt;/p&gt;
&lt;p&gt;This time though, our “score updates” only happen every once in a while, triggered by certain words in the message. Again, this pattern calls for a blip stream:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L103-118&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
    updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
        getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;



&lt;span class=&quot;ot&quot;&gt;updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
    getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;updateBlips&lt;/code&gt; takes in a &lt;code&gt;(Nick, Message)&lt;/code&gt; blip, with the person who is sending the message and their message, and emit with a &lt;code&gt;(Nick, Int)&lt;/code&gt; whenever the message is a command. The emitted &lt;code&gt;(Nick, Int)&lt;/code&gt; has the person to adjust, and the amount to adjust by. Note that we ignore commands where the person is trying to increase their own reputation because that’s just lame.&lt;/p&gt;
&lt;p&gt;We probably want to keep track of the scores as a &lt;code&gt;Map Nick Int&lt;/code&gt;, so we can do that with something like &lt;code&gt;accum&lt;/code&gt; again. However, &lt;code&gt;accum&lt;/code&gt; takes a stream of normal values, but we have a &lt;em&gt;blip stream&lt;/em&gt;, so we can use &lt;code&gt;scanB&lt;/code&gt; instead. &lt;code&gt;scanB&lt;/code&gt; is pretty much the same thing, but it collapses a blip stream into a value stream by holding the “current result” of the fold.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L112-118&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;



&lt;span class=&quot;ot&quot;&gt;trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, the “response” portion — we want to be able to respond to commands and look up the result. We basically had this identical pattern for &lt;code&gt;seenBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L82-86&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@seen&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;



&lt;span class=&quot;ot&quot;&gt;queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
    getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…now we can wrap it all together with a nice proc block:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- repBot :: Monad m =&amp;gt; Auto m InMessage (Blip [Message])&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L88-118&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;repBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;RoomBot&lt;/span&gt; m
repBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg _ _) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    updateB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; updateBlips &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, msg)

    reps    &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; trackReps   &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; updateB

    queryB  &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; queryBlips  &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; msg

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lookupRep ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        lookupRep nick &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; has a reputation of &amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; show rep &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.&amp;quot;&lt;/span&gt;]
          &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
            rep &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.findWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; nick reps

    id &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; lookupRep &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; queryB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    updateBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;))
    updateBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getUpdateCommand
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;-- updater is the person triggering the update blip&lt;/span&gt;
        getUpdateCommand (updater, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@addRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_ &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; nick &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; updater &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@subRep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_                   &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (nick, &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
            _                                  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackReps ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackReps &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp (nick, change) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick change mp) M.empty
&lt;span class=&quot;ot&quot;&gt;    queryBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;)
    queryBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts (getRequest &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; words)
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getRequest (&lt;span class=&quot;st&quot;&gt;&amp;quot;@rep&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;nick&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; nick
        getRequest _                &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again note that we take advantage of the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams to create a new blip stream (&lt;code&gt;lookupRep &amp;lt;$&amp;gt; queryB&lt;/code&gt;) that emits whenever &lt;code&gt;queryB&lt;/code&gt; emits, but replaces the value with &lt;code&gt;lookupRep&lt;/code&gt; applied to whatever &lt;code&gt;Nick&lt;/code&gt; was in the query blip. We also take advantage that &lt;code&gt;reps&lt;/code&gt; is in scope and define &lt;code&gt;lookupRep&lt;/code&gt; right there in the block.&lt;/p&gt;
&lt;h3 id=&quot;announcebot&quot;&gt;announceBot&lt;/h3&gt;
&lt;p&gt;Let’s just go over one more module…and I think you’ll be able to use your imagination to think of and implement your own from here.&lt;/p&gt;
&lt;p&gt;Let’s make an “announceBot”, that listens for “announcement” messages from anyone (even in private messages) and broadcasts them to all of the channels in the provided list. It rate-limits the announcements, though, so that a user is only limited to three announcements per day.&lt;/p&gt;
&lt;p&gt;We can start with our typical “blip stream that emits on a certain command” to start off everything:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L144-154&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
    announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
            _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
    newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange
&lt;span class=&quot;ot&quot;&gt;    trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty



&lt;span class=&quot;ot&quot;&gt;announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
        _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;announceBlips&lt;/code&gt; takes in a nick-message pair and emits an announcement &lt;code&gt;[Message]&lt;/code&gt; whenever the incoming message is an announcement command.&lt;/p&gt;
&lt;p&gt;Next, we’d like to keep track of how many times a user has made an announcement today. This is pretty much just &lt;code&gt;scanB&lt;/code&gt; again like with &lt;code&gt;repBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L153-154&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty



&lt;span class=&quot;ot&quot;&gt;trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we’d like to be able to “reset” this map whenever a new day arrives. For that, we can use &lt;code&gt;resetOn&lt;/code&gt; from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Switch.html&quot;&gt;&lt;code&gt;Control.Auto.Switch&lt;/code&gt;&lt;/a&gt;, which takes an &lt;code&gt;Auto&lt;/code&gt; and gives it a “reset channel” input blip stream, that resets the whole thing whenever the blip stream emits:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;resetOn ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a b &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (a        , &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; c) b

resetOn&lt;span class=&quot;ot&quot;&gt; trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; c) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(It doesn’t care about the actual value emitted, so we can leave it as a type variable &lt;code&gt;c&lt;/code&gt; conceptually.)&lt;/p&gt;
&lt;p&gt;Now the only thing we need is a blip stream that emits whenever there is a new day. For that, we can use &lt;code&gt;onChange&lt;/code&gt; from &lt;a href=&quot;http://hackage.haskell.org/package/auto/docs/Control-Auto-Blip.html&quot;&gt;&lt;code&gt;Control.Auto.Blip&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L151-154&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
    newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange
&lt;span class=&quot;ot&quot;&gt;    trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty


&lt;span class=&quot;ot&quot;&gt;newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;newDayBlips&lt;/code&gt; takes in a stream of &lt;code&gt;Day&lt;/code&gt;s (from &lt;code&gt;Data.Time&lt;/code&gt;) that we get from the &lt;code&gt;InMessage&lt;/code&gt; and outputs a blip stream that emits whenever the day changes. It emits with the new &lt;code&gt;Day&lt;/code&gt;…but we don’t really care about the emitted value, we’re just using it to triger &lt;code&gt;resetOn trackAnns&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, let’s wrap it all together!&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;announceBot&lt;/code&gt; is a full on &lt;code&gt;ChatBot m&lt;/code&gt;, and not a &lt;code&gt;RoomBot m&lt;/code&gt; anymore, so it has to say where it wants to send its messages.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- announceBot :: Monad m =&amp;gt; [Channel] -&amp;gt; Auto m InMessage OutMessages&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L120-154&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;announceBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
announceBot chans &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; proc (&lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; nick msg src time) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    announceB &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; announceBlips     &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick, msg)

    newDayB   &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; newDayBlips       &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; utctDay time

    annCounts &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; resetOn trackAnns &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; (nick &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; announceB, newDayB)

    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; hasFlooded  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; M.findWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; nick annCounts &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;        targetChans ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Channel&lt;/span&gt;]
        targetChans &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; hasFlooded &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [src]
                    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; chans

&lt;span class=&quot;ot&quot;&gt;        outB        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;]
        outB        &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; hasFlooded &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;: No flooding!&amp;quot;&lt;/span&gt;] &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; announceB
                    &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; announceB

&lt;span class=&quot;ot&quot;&gt;        outMsgsB    ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;
        outMsgsB    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (\out &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt; (M.fromList (map (,out) targetChans)))
                  &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; outB

    fromBlips mempty &lt;span class=&quot;fu&quot;&gt;-&amp;lt;&lt;/span&gt; outMsgsB
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    announceBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Message&lt;/span&gt;])
    announceBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; emitJusts getAnnounces
      &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getAnnounces (nick, msg) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; words msg &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&amp;quot;@ann&amp;quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;ann &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [nick &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot; says \&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; unwords ann &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;\&amp;quot;.&amp;quot;&lt;/span&gt;]
            _          &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    newDayBlips ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt;)
    newDayBlips &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; onChange
&lt;span class=&quot;ot&quot;&gt;    trackAnns ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Monad&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Blip&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt;) (&lt;span class=&quot;dt&quot;&gt;Map&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nick&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)
    trackAnns &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; scanB (\mp nick &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; M.insertWith (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt;) nick &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; mp) M.empty&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Only slightly more involved, but still pretty readable, right? We find out if things have flooded, and our target channels will be just the original source if true (a message as a reprimand); otherwise, all the channels in &lt;code&gt;chans&lt;/code&gt;. If they have flooded, then our &lt;code&gt;outB&lt;/code&gt; (blip stream of &lt;code&gt;[Message]&lt;/code&gt; to send to each room) will just be &lt;code&gt;[&amp;quot;No flooding!&amp;quot;]&lt;/code&gt; if yes, or the actual announcement otherwise.&lt;/p&gt;
&lt;p&gt;Finally, our &lt;code&gt;Blip OutMessages&lt;/code&gt; will be the &lt;code&gt;OutMessage&lt;/code&gt; formed by associating all of the channels in &lt;code&gt;targetChans&lt;/code&gt; with the message in &lt;code&gt;outB&lt;/code&gt;…emitting whenever &lt;code&gt;outB&lt;/code&gt; emits.&lt;/p&gt;
&lt;p&gt;Note here that we use &lt;code&gt;(&amp;lt;$)&lt;/code&gt; from the &lt;code&gt;Functor&lt;/code&gt; instance of blip streams. &lt;code&gt;x &amp;lt;$ fooB&lt;/code&gt; is a new blip stream that emits whenever &lt;code&gt;fooB&lt;/code&gt; emits…but instead &lt;em&gt;replaces the emitted value&lt;/em&gt;. So for &lt;code&gt;4 &amp;lt;$ fooB&lt;/code&gt;, if &lt;code&gt;fooB&lt;/code&gt; emits with &lt;code&gt;&amp;quot;hello&amp;quot;&lt;/code&gt;, &lt;code&gt;4 &amp;lt;$ fooB&lt;/code&gt; emits with &lt;code&gt;4&lt;/code&gt;. Emit at the same time, but pop out the value and put in your own.&lt;/p&gt;
&lt;p&gt;Finally we use &lt;code&gt;fromBlips&lt;/code&gt;, which we met before in the definition of &lt;code&gt;perRoom&lt;/code&gt;: the output is the &lt;code&gt;OutMessage&lt;/code&gt; in &lt;code&gt;outMsgsB&lt;/code&gt; whenever &lt;code&gt;outMsgsB&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; emit…or it’s &lt;code&gt;mempty&lt;/code&gt; (the empty map) when it doesn’t.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-it-all-up&quot;&gt;Wrapping it all up&lt;/h2&gt;
&lt;p&gt;We have three nice modules now. Now let’s wrap it all together.&lt;/p&gt;
&lt;p&gt;First, if you’ve been following around, you might have noticed that we needed &lt;code&gt;Serialize&lt;/code&gt; instances (from the &lt;em&gt;cereal&lt;/em&gt; library) for &lt;code&gt;UTCTime&lt;/code&gt; and &lt;code&gt;Day&lt;/code&gt; in order for &lt;code&gt;trackSeens&lt;/code&gt; and &lt;code&gt;newDayBlips&lt;/code&gt; to serialize properly. We can just write really rough versions of them for now for demonstration purposes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L201-207&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; read &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get      &lt;span class=&quot;co&quot;&gt;-- haha don&amp;#39;t do this in real life.&lt;/span&gt;
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; put &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; show

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Serialize&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Day&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    get &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ModifiedJulianDay&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; get
    put &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; put &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; toModifiedJulianDay&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, writing &lt;code&gt;chatBot&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L54-59&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;chatBot ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;chatbot.dat&amp;quot;&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; mconcat &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; [ perRoom seenBot
                    , perRoom repBot
                    , announceBot [&lt;span class=&quot;st&quot;&gt;&amp;quot;#jlebot-test&amp;quot;&lt;/span&gt;]
                    ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, to future-proof, in case we foresee adding new modules:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/auto/chatbot.hs#L61-65&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;chatBot&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadIO&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m
chatBot&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mconcat [ perRoom &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;seens.dat&amp;quot;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; seenBot
                   , perRoom &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;reps.dat&amp;quot;&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; repBot
                   ,           serializing&amp;#39; &lt;span class=&quot;st&quot;&gt;&amp;quot;anns.dat&amp;quot;&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; announceBot [&lt;span class=&quot;st&quot;&gt;&amp;quot;#jlebot-test&amp;quot;&lt;/span&gt;]
                   ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it!&lt;/p&gt;
&lt;h2 id=&quot;fin&quot;&gt;Fin&lt;/h2&gt;
&lt;p&gt;Hopefully, going over this project, you’re starting to see some common and powerful idioms and tools. I hope that a clear picture of how to approach and finish a program with the &lt;em&gt;auto&lt;/em&gt; library looks…and how beneficial the platform and what it offers is to streamlining the development process.&lt;/p&gt;
&lt;p&gt;Also, hopefully the “declarative” nature of everything is apparent. Especially for &lt;em&gt;proc&lt;/em&gt; blocks…everything just “looks like” a graph of relationships. This quantity is related to this quantitiy in this way, this quantity is related to that in that way, etc. It looks like you’re just specifying a graph of relationships, which is really what the core of &lt;em&gt;auto&lt;/em&gt; is all about. We assemble complex relationships by putting together small, simple relationships.&lt;/p&gt;
&lt;p&gt;Note that we didn’t just implement “easy” modules/components…these are actual working components that you might see in real bots, and not just toy ones.&lt;/p&gt;
&lt;p&gt;Where can we go from here? Well, you might actually want to maybe write “subscription” &lt;code&gt;Auto&lt;/code&gt;s that are updated every minute or so:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChronBot&lt;/span&gt; m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You call them every minute with the type, and it’s allowed to react with the the time and output an &lt;code&gt;OutMessages&lt;/code&gt;. You can use this bot to implement things like rss feed watchers/subscribers, for instance.&lt;/p&gt;
&lt;p&gt;Then, instead of using an input channel waiting for &lt;code&gt;InMessage&lt;/code&gt;, you might wait for &lt;code&gt;Either InMessage UTCTime&lt;/code&gt;…drop in &lt;code&gt;Left im&lt;/code&gt; whenever you get a message, and &lt;code&gt;Right time&lt;/code&gt; from a thread that just waits a minute and repeatedly throws in times.&lt;/p&gt;
&lt;p&gt;We can do this with minimal extra work by using the &lt;code&gt;(|||)&lt;/code&gt; combinator from &lt;code&gt;Control.Auto&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;(|||) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m a c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m b c &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; a         b      ) c
&lt;span class=&quot;ot&quot;&gt;(|||) ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChatBot&lt;/span&gt; m  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ChronBot&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; m (&lt;span class=&quot;dt&quot;&gt;Either&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;InMessage&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;UTCTime&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;OutMessages&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…you get it all for free! No extra work. Now both the &lt;code&gt;ChatBot&lt;/code&gt; and the &lt;code&gt;ChronBot&lt;/code&gt; will wait on the input stream, and the &lt;code&gt;Left&lt;/code&gt;s will be fed to the &lt;code&gt;ChatBot&lt;/code&gt; and the &lt;code&gt;Right&lt;/code&gt;s will be fed to the &lt;code&gt;ChronBot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, this post is long enough. Have fun exploring &lt;em&gt;auto&lt;/em&gt; on your own; I’m always happy to hear about any project you might be working on! You can find me on twitter as &lt;a href=&quot;https://twitter.com/mstk&quot; title=&quot;Twitter&quot;&gt;mstk&lt;/a&gt;. If you have any questions or comments/suggestions, feel free to leave a comment down below or drop by freenode’s &lt;em&gt;#haskell-auto&lt;/em&gt; or &lt;em&gt;#haskell-game&lt;/em&gt;, where I go by &lt;em&gt;jle`&lt;/em&gt;! And, as always, happy Haskelling!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;&lt;code&gt;scanB f x0 :: Auto m (Blip a) b&lt;/code&gt;, but there’s also &lt;code&gt;accumB f x0 :: Auto m a (Blip a) (Blip b)&lt;/code&gt;, which emits whenever the input emits only.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Projects</category><category>Auto</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/auto-building-a-declarative-chatbot-with-implicit-serialization.html</guid><pubDate>Tue,  1 Mar 2016 07:52:17 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Projects, Auto</dc:subject><dc:date>2016-03-01</dc:date></item><item><title>Functional Programming is Awesome: Parser Combinators</title><link>http://home.jle0.com:4111/entry/functional-programming-is-awesome-parser-combinators.html</link><description>&lt;p&gt;If you’ve spent your entire life programming imperatively, you could not even begin to imagine the vast worlds of thinking that are inaccessible because of restrictions in your thinking. Not “better”, or “harder” ways of thinking — possibly just as easy, but…different.&lt;/p&gt;
&lt;p&gt;Don’t believe me? Here is an example of an amazingly awesome and amazing and incomprehensibly mind-opeining design pattern that shines in functional programming: applicative combinators. In specific, we are going to write a small parser library! Yay!&lt;/p&gt;
&lt;p&gt;Now, if you are a sane person, you should know that &lt;em&gt;nobody&lt;/em&gt; enjoys writing parsers…imperatively. The whole deal is a mess; you have to keep track of multiple layers of state, work out back tracking and edge cases, and to top it off, parsers tend to be very uncomposable, and parsing two different things usually requires either source code surgery in the best case or a complete rewrite in the worst.&lt;/p&gt;
&lt;p&gt;But what if I told you that combinator-based parsers are so easy to work with and composable and intuitive that they are…well, fun? I’ll tease you:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- a parser for a special variable name, which can optionally start with an&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- `@` symbol, and then an alphabet character, followed by many alphanumeric&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- characters&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;variableName ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
variableName &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (optional &lt;span class=&quot;ch&quot;&gt;&amp;#39;@&amp;#39;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;:&amp;gt;&lt;/span&gt; alpha &lt;span class=&quot;fu&quot;&gt;&amp;lt;:&amp;gt;&lt;/span&gt; (many alphaNum)

&lt;span class=&quot;co&quot;&gt;-- usage:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- λ: parse variableName &amp;quot;9one&amp;quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- Nothing&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- λ: parse variableName &amp;quot;var01&amp;quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- Just (&amp;quot;var01&amp;quot;, &amp;quot;&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- λ: parse variableName &amp;quot;@var2&amp;quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- Just (&amp;quot;@var2&amp;quot;, &amp;quot;&amp;quot;)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- λ: parse variableName &amp;quot;@9one&amp;quot;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s take a look, shall we? We will first write our library, and then see how we build complex parsers out of smaller, simpler ones. And maybe learn a little bit of Haskell along the way — in particular, the magic of Functors and Applicative Functors (and maybe some Monads if we’re lucky).&lt;/p&gt;
&lt;p&gt;(Much of this post is taken from a University of Göteborg &lt;a href=&quot;http://www.cse.chalmers.se/edu/course/TDA452/FPLectures/Vid/&quot;&gt;lecture series&lt;/a&gt; available online; it has been slightly rephrased to be more applicative-centric than monad-centric)&lt;/p&gt;
&lt;h2 id=&quot;our-parser-type&quot;&gt;Our Parser Type&lt;/h2&gt;
&lt;p&gt;So; our goal here is to write a library for parsing that is powerful to be completely general and adaptable for any purpose. And also be very intuitive to use. Easy, right? Let’s start with the type of our Parser!&lt;/p&gt;
&lt;h3 id=&quot;our-parser-type-1&quot;&gt;Our Parser type&lt;/h3&gt;
&lt;p&gt;So our Parser type is going to be an object of type &lt;code&gt;Parser a&lt;/code&gt; that contains one thing: a parsing function. This parsing function will take in a string and return the parsed value of type &lt;code&gt;a&lt;/code&gt;, together with the “leftover” string that is unparsed.&lt;/p&gt;
&lt;p&gt;In Haskell, we represent this object as:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which reads “The type &lt;code&gt;Parser a&lt;/code&gt; is an object that you specify by saying ‘&lt;code&gt;P f&lt;/code&gt;’, where &lt;code&gt;f&lt;/code&gt; is a function that takes in a string and returns an &lt;code&gt;a&lt;/code&gt; with another string.&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hi! These asides are for people unfamiliar with Haskell syntax. Feel free to skip them if you already are comfortable.&lt;/p&gt;
If you’ve ever used an object-oriented language like Java or C++, &lt;code&gt;Parser a&lt;/code&gt; is a template, or generic, and would be written in those languages as the class &lt;code&gt;Parser&amp;lt;a&amp;gt;&lt;/code&gt;, with only one instance variable: a function taking a string and returning something of type &lt;code&gt;a&lt;/code&gt; with a leftover string.
&lt;/aside&gt;
&lt;p&gt;And we write a function &lt;code&gt;parse&lt;/code&gt; that will take any &lt;code&gt;Parser a&lt;/code&gt; object and any string, and return the parsed string:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;parse ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (a, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)              &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
parse (&lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; f) str &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f str                                 &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A bunch of Haskell syntax features here!&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;This first line says “the function &lt;code&gt;parse&lt;/code&gt; is a function that takes a &lt;code&gt;Parser a&lt;/code&gt; and a &lt;code&gt;String&lt;/code&gt; and return something of the value &lt;code&gt;(a, String)&lt;/code&gt;”&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now to define the function. It has two arguments; the first one is of the form &lt;code&gt;P f&lt;/code&gt;, and the second is just a string &lt;code&gt;str&lt;/code&gt;. Remember, &lt;code&gt;P f&lt;/code&gt; is how you specify a &lt;code&gt;Parser a&lt;/code&gt;; the &lt;code&gt;f&lt;/code&gt; is the function inside the object. We then call &lt;code&gt;f&lt;/code&gt; with &lt;code&gt;str&lt;/code&gt;, and that’s what we want.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;p&gt;Let’s say we had a parser &lt;code&gt;integerParser&lt;/code&gt; pre-made, that parses a string into an integer. Here is how we would use it in the interactive &lt;a href=&quot;http://en.wikipedia.org/wiki/Read-eval-print_loop&quot;&gt;repl&lt;/a&gt; prompt:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; integerParser
&lt;span class=&quot;ot&quot;&gt;integerParser ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse integerParser &lt;span class=&quot;st&quot;&gt;&amp;quot;12&amp;quot;&lt;/span&gt;
(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)                    &lt;span class=&quot;co&quot;&gt;-- returns the integer 12, with nothing leftover&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse integerParser &lt;span class=&quot;st&quot;&gt;&amp;quot;-82 zero&amp;quot;&lt;/span&gt;
(&lt;span class=&quot;dv&quot;&gt;82&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot; zero&amp;quot;&lt;/span&gt;)               &lt;span class=&quot;co&quot;&gt;-- returns the integer -82, with some leftovers&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse integerParser &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;??????&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;-- ??????&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this article, code that begins with &lt;code&gt;λ:&lt;/code&gt; means stuff entered at the interactive prompt, ghci. You enter an expression, and it is evaluated, its result printed.&lt;/p&gt;
&lt;code&gt;:type&lt;/code&gt; is a ghci command that returns the type of the thing in question.
&lt;/aside&gt;
&lt;p&gt;Hm. There’s a problem. Sometimes, the parse will fail. How can we indicate that a parse is failable?&lt;/p&gt;
&lt;p&gt;In most languages, we might return a &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; value. But this is not cool in Haskell because we like having type safety — having things be &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; willy-nilly means that your compiler can’t help you, and you open up the door to runtime errors.&lt;/p&gt;
&lt;p&gt;In Haskell, we have an object of type &lt;code&gt;Maybe a&lt;/code&gt;, which can either be &lt;code&gt;Just a&lt;/code&gt; (the object contains a value &lt;code&gt;a&lt;/code&gt;), or &lt;code&gt;Nothing&lt;/code&gt; (the object contains nothing). Let’s change our function so that it will return &lt;code&gt;Just a&lt;/code&gt; if our parse succeeds and &lt;code&gt;Nothing&lt;/code&gt; if it fails.&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
Again keeping with the analogies to Object-Oriented Programming, you can think of &lt;code&gt;Maybe a&lt;/code&gt; as a superclass, &lt;code&gt;Maybe&amp;lt;a&amp;gt;&lt;/code&gt;, with two subclasses: &lt;code&gt;Just a&lt;/code&gt; and &lt;code&gt;Nothing&lt;/code&gt;. &lt;code&gt;Just a&lt;/code&gt; contains one instance variable of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;Nothing&lt;/code&gt; contains…nothing.
&lt;/aside&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (a, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;))

&lt;span class=&quot;ot&quot;&gt;parse ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (a, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)
parse (&lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; f) str &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f str&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse integerParser &lt;span class=&quot;st&quot;&gt;&amp;quot;12&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)               &lt;span class=&quot;co&quot;&gt;-- succesfully returns the integer 12, inside a&lt;/span&gt;
                            &lt;span class=&quot;co&quot;&gt;-- Maybe object&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse integerParser &lt;span class=&quot;st&quot;&gt;&amp;quot;-82 zero&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;82&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot; zero&amp;quot;&lt;/span&gt;)         &lt;span class=&quot;co&quot;&gt;-- succesfully returns the integer -82&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse integerParser &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                     &lt;span class=&quot;co&quot;&gt;-- fails&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay, cool. Let’s get started.&lt;/p&gt;
&lt;h3 id=&quot;our-base-parsers&quot;&gt;Our base parsers&lt;/h3&gt;
&lt;p&gt;So remember, the whole point is to be able to somehow build complex parsers out of very simple ones. So let’s start with the simplest parsers of all: a parser that always fails.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;failure ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; a
failure &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; returnNothing                   &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        returnNothing _ &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse failure &lt;span class=&quot;st&quot;&gt;&amp;quot;12&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse failure &lt;span class=&quot;st&quot;&gt;&amp;quot;anything&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Remember, we specify/construct parsers as &lt;code&gt;P f&lt;/code&gt;, where &lt;code&gt;f&lt;/code&gt; is the parsing function.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; is a wildcard in Haskell; &lt;code&gt;returnNothing&lt;/code&gt; is a function that takes &lt;em&gt;anything&lt;/em&gt; and returns &lt;code&gt;Nothing&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;p&gt;Easy enough. How about some parsers that always succeeds with a pre-defined answer, and does not consume any of the string?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;successfulTrue ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
successfulTrue &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; returnTrue
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        returnTrue str &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, str)

&lt;span class=&quot;ot&quot;&gt;succesfulZero ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
succesfulZero &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; returnZero
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        returnZero str &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, str)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse succesfulTrue &lt;span class=&quot;st&quot;&gt;&amp;quot;12&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;12&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse succesfulZero &lt;span class=&quot;st&quot;&gt;&amp;quot;anything&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;anything&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have two parsers here, with two different parse functions. If you notice, they pretty much do the same thing, and have very similar structure. This is a key flag that we can probably abstract out some part of it. Let’s write a new parse function that covers both of them:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;successful ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; a
successful val &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; returnVal
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        returnVal str &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (val, str)

&lt;span class=&quot;ot&quot;&gt;succesfulTrue ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
succesfulTrue &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; succesful &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;succesfulZero ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
succesfulZero &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; succesful &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;successful val&lt;/code&gt; is a function that takes any value and gives us a &lt;code&gt;Parser a&lt;/code&gt; with the function &lt;code&gt;returnVal&lt;/code&gt; — &lt;code&gt;returnVal str&lt;/code&gt; yields a &lt;code&gt;Just&lt;/code&gt; with the &lt;code&gt;val&lt;/code&gt; we gave to &lt;code&gt;successful&lt;/code&gt;, with the string untouched. Let’s try it out.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse (successful &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse (successful &lt;span class=&quot;fl&quot;&gt;8.26&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;8.26&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; (successful &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;)
succesful &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the type of &lt;code&gt;succesful True&lt;/code&gt; is exactly the same type as our &lt;code&gt;succesfulTrue&lt;/code&gt; function. Which is what we would expect. Our &lt;code&gt;succesful val&lt;/code&gt; function takes a value and returns a parser that parses anything into that given value. So if we pass in &lt;code&gt;True&lt;/code&gt;, it will return a parser/function that parses anything into &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Okay, so our two base parses are nice, but it doesn’t sound like they are useful at all for any real parsing work. Let’s write our first somewhat-useful-kinda-maybe parser: &lt;code&gt;anyChar&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;anyChar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
anyChar &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; getFirst
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        getFirst (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x, xs)          &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
        getFirst []     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;               &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;If you call &lt;code&gt;getFirst&lt;/code&gt; on a non-empty list, it will set the &lt;code&gt;x&lt;/code&gt; to the first element and &lt;code&gt;xs&lt;/code&gt; to the rest of the list. Kind of like in C, a string is just an alias for a list of characters. So &lt;code&gt;getFirst &amp;quot;hello&amp;quot;&lt;/code&gt; will return &lt;code&gt;Just (&#39;h&#39;, &amp;quot;ello&amp;quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If you call &lt;code&gt;getFirst&lt;/code&gt; on an empty list, it fails.&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;p&gt;Let’s see it at work.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse anyChar &lt;span class=&quot;st&quot;&gt;&amp;quot;h&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse anyChar &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;ello&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse anyChar &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;anyChar&lt;/code&gt; parses a string into a…character. That’s…kind of boring, admittedly. I’m sure you could have written something that parses a one-letter string into a character in any language without a problem…one that would parse &lt;code&gt;&amp;quot;h&amp;quot;&lt;/code&gt;, the string, into &lt;code&gt;&#39;h&#39;&lt;/code&gt;, the character.&lt;/p&gt;
&lt;p&gt;Hm. Let’s try something else. Let’s try a parser that always fails &lt;em&gt;unless&lt;/em&gt; the taken character satisfies a certain condition:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;z ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; isA_z
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        isA_z (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;z&amp;#39;&lt;/span&gt;
                            &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x, xs)
                            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
        isA_z []     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;lowercase ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
lowercase &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; isLowercase
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        isLowercase (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;   &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; isLower x
                                    &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x, xs)
                                    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
        isLowercase []      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;   &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember that Haskell’s built-in &lt;code&gt;Data.Char&lt;/code&gt; module provides the function &lt;code&gt;isLower :: Char -&amp;gt; Bool&lt;/code&gt;, which is true if the given character is a lowercase letter and false otherwise.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse z &lt;span class=&quot;st&quot;&gt;&amp;quot;not z&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse lowercase &lt;span class=&quot;st&quot;&gt;&amp;quot;A&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse lowercase &lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But wait! Like in the case for &lt;code&gt;succesful&lt;/code&gt;, we notice a definite pattern…and we can abstract this out.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;satisfies ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
satisfies p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; passesPredicate
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        passesPredicate (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;xs) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p z
                                      &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x, xs)
                                      &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
        passesPredicate []     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;


&lt;span class=&quot;ot&quot;&gt;z ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies (&lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;z&amp;#39;&lt;/span&gt;)

&lt;span class=&quot;ot&quot;&gt;lowercase ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
lowercase &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies isLower&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
Similar in structure to &lt;code&gt;(*2)&lt;/code&gt;, &lt;code&gt;(== &#39;z&#39;)&lt;/code&gt; is a function that returns true if the input is equal to &lt;code&gt;&#39;z&#39;&lt;/code&gt; and false otherwise. That is, &lt;code&gt;(== &#39;z&#39;) &#39;a&#39;&lt;/code&gt; is false, while &lt;code&gt;(== &#39;z&#39;) &#39;z&#39;&lt;/code&gt; is true.
&lt;/aside&gt;
&lt;p&gt;Remember, just like in the case with &lt;code&gt;succesful&lt;/code&gt;: &lt;code&gt;satisfies p&lt;/code&gt; returns a &lt;code&gt;Parser Char&lt;/code&gt; that fails unless the first character satisfies the given predicate &lt;code&gt;p&lt;/code&gt;; &lt;code&gt;p&lt;/code&gt; has to be a function from &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;Bool&lt;/code&gt; — a predicate on &lt;code&gt;Char&lt;/code&gt;s. So then &lt;code&gt;satisfies isLower&lt;/code&gt; returns a new parser with the predicate &lt;code&gt;isLower&lt;/code&gt; as the “checker”.&lt;/p&gt;
&lt;p&gt;Let’s try this out with some more built-in predicates from &lt;code&gt;Data.Char&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse (satisfies isAlpha) &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;ello&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse (satisfies isDigit) &lt;span class=&quot;st&quot;&gt;&amp;quot;123abc&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;23abc&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse (&lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;) &lt;span class=&quot;st&quot;&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;ch&quot;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;bc&amp;quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In fact, some of these parsers are so useful, let’s name some:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;digit ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
digit &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies isDigit

&lt;span class=&quot;ot&quot;&gt;alphaNum ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
alphaNum &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies isAlphaNum

&lt;span class=&quot;ot&quot;&gt;alpha ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
alphaNum &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies isAlpha

&lt;span class=&quot;ot&quot;&gt;char ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
char c &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies (&lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; c)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The last one is particularly neat — it says “accept only the given character” — &lt;code&gt;char &#39;a&#39;&lt;/code&gt; generates a parser that succeeds only on the character &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that we even can rewrite &lt;code&gt;anyChar&lt;/code&gt; in terms of &lt;code&gt;satisfies&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;anyChar ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
anyChar &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies (const &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;const True :: a -&amp;gt; Bool&lt;/code&gt; is a function that ignores all its input and always returns true no matter what. &lt;code&gt;anyChar&lt;/code&gt; is a parser that will take any character, no matter what.&lt;/p&gt;
&lt;h3 id=&quot;now-were-cooking&quot;&gt;Now we’re cooking&lt;/h3&gt;
&lt;p&gt;Okay, so we are making baby steps. Here are our “base” parsers. They can’t really do much on their own; you can either always fail, always succeed, and parse any one-character string into a character. But the last one…the ability to &lt;em&gt;selectively&lt;/em&gt; parse a string into a character…that might be interesting. It’s not totally obvious yet how we can make it useful, but…I think we have enough base parsers to start building our &lt;em&gt;combinators&lt;/em&gt; — functions that combine and modify parsers.&lt;/p&gt;
&lt;h2 id=&quot;functors&quot;&gt;Functors&lt;/h2&gt;
&lt;p&gt;You have probably worked with functors before in your programming life with or without knowing it. Functors represent objects or data structures that “contain” data that can be “mapped over” — that is, functors are objects where you can apply functions to the values inside. The most famous functor in any language is the list, &lt;code&gt;[]&lt;/code&gt;; another neat one is &lt;code&gt;Maybe&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First of all, to clarify, &lt;code&gt;(*2)&lt;/code&gt; is a function that doubles whatever is passed to it — &lt;code&gt;(*2) 3&lt;/code&gt; is 6.&lt;/p&gt;
&lt;p&gt;Next, in haskell, we can use the &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; operator to say “apply this…‘inside’ of the structure”. This is analogous to the more-often-used &lt;code&gt;$&lt;/code&gt; operator:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which says “apply this (&lt;code&gt;(*2)&lt;/code&gt;)…to this (&lt;code&gt;3&lt;/code&gt;)”.&lt;/p&gt;
&lt;p&gt;Compare that to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; is the “container” version of &lt;code&gt;$&lt;/code&gt;. It is like &lt;code&gt;$&lt;/code&gt;, but “inside”.&lt;/p&gt;
&lt;p&gt;For more information, refer to adit’s &lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot;&gt;amazing article&lt;/a&gt; on the topic.&lt;/p&gt;
&lt;/aside&gt;
&lt;p&gt;You can probably see where I’m going with this.&lt;/p&gt;
&lt;h3 id=&quot;turning-our-parser-into-a-functor&quot;&gt;Turning our Parser into a Functor&lt;/h3&gt;
&lt;h4 id=&quot;what-does-that-even-mean&quot;&gt;What does that even mean?&lt;/h4&gt;
&lt;p&gt;Hopefully you saw this coming. Functors seem to be very cool. But does it even make sense that our Parser object is a functor? The &lt;code&gt;Parser Int&lt;/code&gt; object doesn’t “contain” any &lt;code&gt;Int&lt;/code&gt;s…does it?&lt;/p&gt;
&lt;p&gt;Well…it kind of “does”…in two ways, sorta kinda maybe.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;You could say that a &lt;code&gt;Parser Int&lt;/code&gt; “contains” the to-be-parsed integer.&lt;/li&gt;
&lt;li&gt;You could say that a &lt;code&gt;Parser Int&lt;/code&gt; “contains” the &lt;strong&gt;idea&lt;/strong&gt; of an integer…abstractly. Like, whoa, man.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So…does it make sense to apply a function “inside” a &lt;code&gt;Parser a&lt;/code&gt;? The answer is yes!&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;If a &lt;code&gt;Parser Int&lt;/code&gt; contains a to-be-parsed integer, then applying a function inside a &lt;code&gt;Parser Int&lt;/code&gt; would be like applying the function to the to-be-parsed integer!&lt;/li&gt;
&lt;li&gt;If a &lt;code&gt;Parser Int&lt;/code&gt; contains the &lt;em&gt;idea&lt;/em&gt; of an integer, then applying a function inside a &lt;code&gt;Parser Int&lt;/code&gt; would be applying the function to the idea of the integer.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Huh. This is kinda cool, isn’t it? So let’s say that when we apply a function “inside” our Parser…it means that we apply a function to the finished result of a succesful parse.&lt;/p&gt;
&lt;p&gt;Basically, we want something like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; succesfulSix &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; (succesful &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; succesfulSix
&lt;span class=&quot;ot&quot;&gt;succesfulSix ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse succesfulSix &lt;span class=&quot;st&quot;&gt;&amp;quot;something&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay, cool. So instead of &lt;code&gt;succesful 3&lt;/code&gt; always succeeding with a 3, it succeeds with &lt;code&gt;(*2) 3&lt;/code&gt;, which is 6. Still kinda boring but w/e.&lt;/p&gt;
&lt;p&gt;Let’s try something else…we’re going to take advantage of the &lt;code&gt;Data.Char&lt;/code&gt; method &lt;code&gt;digitToInt :: Char -&amp;gt; Int&lt;/code&gt;, which takes a &lt;code&gt;Char&lt;/code&gt; and returns the digit that it represents (for example, &lt;code&gt;digitToInt &#39;5&#39;&lt;/code&gt; is 5, the integer):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; digitInt &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; digitToInt &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; digit      &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; digitInt
&lt;span class=&quot;ot&quot;&gt;digitInt ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse digitInt &lt;span class=&quot;st&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse digitInt &lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Remember, we defined the parser &lt;code&gt;digit&lt;/code&gt; earlier, as a parser that only succeeds if the first character is a digit.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Did you just see that? That sounds genuinely useful! If we manage to implement &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; properly, we just have a way to selectively parse any digit character into a digit, and fail otherwise.&lt;/p&gt;
&lt;p&gt;Let’s try chaining &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;’s:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; digitIntDoubled &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; (digitToInt &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; digit)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; digitIntDoubled
&lt;span class=&quot;ot&quot;&gt;digitIntDoubled ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse digitIntDoubled &lt;span class=&quot;st&quot;&gt;&amp;quot;2&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse digitIntDoubled &lt;span class=&quot;st&quot;&gt;&amp;quot;a&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What just happened here?&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;digit&lt;/code&gt; is a parser that succeeds only on digit characters.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;digitToInt &amp;lt;$&amp;gt; digit&lt;/code&gt; is the result of applying &lt;code&gt;digitToInt&lt;/code&gt; on the value of a succesful parse. Basically, &lt;code&gt;digitToInt &amp;lt;$&amp;gt; digit&lt;/code&gt; is a &lt;em&gt;new parser&lt;/em&gt; that succeeds on digit characters, returning an integer.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(*2) &amp;lt;$&amp;gt; (digitToInt &amp;lt;$&amp;gt; digit)&lt;/code&gt; is the result of applying &lt;code&gt;(*2)&lt;/code&gt; (the doubling function) to &lt;code&gt;digitToInt &amp;lt;$&amp;gt; digit&lt;/code&gt;, the return-digit-as-int parser. The &lt;code&gt;(*2) &amp;lt;$&amp;gt;&lt;/code&gt; doubles the result of the return-digit-as-int parser. Essentially, the entire expression is a &lt;em&gt;new parser&lt;/em&gt; that succeeds on digit character, returning the doubled integer as the parse result.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;*Phew*. That was a conceptual doozy. But this seems like a good path. Do you see what we did? We turned old, boring parsers into new, interesting parsers by “transforming” them. This is the kind of thing we were looking for in the first place, right?&lt;/p&gt;
&lt;h4 id=&quot;implementing-the-functor-instance&quot;&gt;Implementing the Functor instance&lt;/h4&gt;
&lt;p&gt;That’s all fine and dandy. Now we have to actually implement &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Luckily in Haskell, there are mechanisms for uniting functor interfaces. That is, if you tell it that &lt;code&gt;Parser a&lt;/code&gt; is a functor, then you open up all sorts of powerful functor tools that were written for things like lists and maybe’s — now we can use them all on &lt;code&gt;Parser a&lt;/code&gt;, too.&lt;/p&gt;
&lt;p&gt;To do this, we “instance” the Functor &lt;em&gt;typeclass&lt;/em&gt;. A typeclass in Haskell is like an interface in Object-Oriented Programming. Basically, we say “&lt;code&gt;Parser a&lt;/code&gt; is a functor…treat it like one!” But in order to make it a valid functor, we must tell it how to &lt;code&gt;fmap&lt;/code&gt;. &lt;code&gt;fmap&lt;/code&gt; is basically &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; — it takes a function, a functor object, and returns a new functor object with that function applied “inside”. Once we define &lt;code&gt;fmap&lt;/code&gt;, then we get &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; for free. Or rather, Haskell knows that our parser is a functor, and knows how to use &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; on functors.&lt;/p&gt;
&lt;p&gt;Here’s how we do it. Hold on tight!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;                                       &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
    fmap f parser &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;P&lt;/span&gt; mapped_parser_function                        &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;            unmapped_result ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (a, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)
            unmapped_result &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; parse parser str                      &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;            mapped_parser_function ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (b, &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;)
            mapped_parser_function str &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; unmapped_result &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;                             &lt;span class=&quot;co&quot;&gt;-- 4&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (result, rest) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (f result, rest)    &lt;span class=&quot;co&quot;&gt;-- 5&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;             &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                  &lt;span class=&quot;co&quot;&gt;-- 6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;This line is syntax for “we are declaring that &lt;code&gt;Parser&lt;/code&gt; is a functor!”, so that Haskell can treat &lt;code&gt;Parser&lt;/code&gt; like a functor (and have &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; work).&lt;/li&gt;
&lt;li&gt;In order to declare something as a functor, we must define the function &lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; Parser a -&amp;gt; Parser b&lt;/code&gt;, which takes a function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt;, a &lt;code&gt;Parser a&lt;/code&gt;, and returns the mapped-over parser/parser with the function applied “inside”.&lt;/li&gt;
&lt;li&gt;Grab the result of the parse with the unmapped parser, first.&lt;/li&gt;
&lt;li&gt;Some more Haskell syntax. Basically, the result of &lt;code&gt;mapped_parser_function&lt;/code&gt; is dependent on what &lt;code&gt;unmapped_result&lt;/code&gt; is.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;unmapped_result&lt;/code&gt; is a &lt;code&gt;Just&lt;/code&gt;, then return the success, but apply &lt;code&gt;f&lt;/code&gt; to the result first.&lt;/li&gt;
&lt;li&gt;If &lt;code&gt;unmapped_result&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt;…well, you can’t apply anything to the result if the result is a failure (a &lt;code&gt;Nothing&lt;/code&gt;). Pass on the failure.&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;p&gt;And now we can use our &lt;code&gt;Parser a&lt;/code&gt; as a functor; all of our use cases above will now work.&lt;/p&gt;
&lt;h3 id=&quot;fun-with-functors&quot;&gt;Fun with functors&lt;/h3&gt;
&lt;p&gt;Let’s take a brief moment to see what kind of things we can do with only functors, and nothing else. It’s probably not going to be too much more useful than what you can write imperatively, but it is interesting what you can do by only ‘modifying’ simpler parsers…which is what the whole point of combinators are.&lt;/p&gt;
&lt;p&gt;With that in mind, let’s try out some neat use cases.&lt;/p&gt;
&lt;p&gt;What if you want to parse a digit and look it up in a list of keywords, and return that keyword?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;keywords ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;]
keywords &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;&amp;quot;debug&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;normal&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;warning&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;error&amp;quot;&lt;/span&gt;]

&lt;span class=&quot;ot&quot;&gt;digit ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Char&lt;/span&gt;
digit &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; satisfies isDigit

&lt;span class=&quot;ot&quot;&gt;digitInt ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
digitInt &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; digitToInt &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; digit

&lt;span class=&quot;ot&quot;&gt;keyword ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
keyword &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; keywords) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; digitInt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Aside&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;(!! keywords)&lt;/code&gt; is a function that looks up the given index in the given list. In our case, &lt;code&gt;(!! keywords) 2&lt;/code&gt; would return what in other languages is &lt;code&gt;keywords[2]&lt;/code&gt;, which is the string “warning”.
&lt;/aside&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse keyword &lt;span class=&quot;st&quot;&gt;&amp;quot;1&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&amp;quot;normal&amp;quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; parse keyword &lt;span class=&quot;st&quot;&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;!-- ~~~haskell --&gt;
&lt;!-- λ: parse keyword &quot;1&quot; --&gt;
&lt;!-- Just (&quot;normal&quot;, &quot;&quot;) --&gt;
&lt;!-- λ: parse keyword &quot;hello&quot; --&gt;
&lt;!-- Nothing --&gt;
&lt;!-- λ: parse keyword &quot;67&quot; --&gt;
&lt;!-- *** Exception: (!!): index too large --&gt;
&lt;!-- ~~~ --&gt;
&lt;!-- Oops!  We forgot that `!!` is an unsafe/partial function (it is undefined for --&gt;
&lt;!-- some inputs)...it should have been obvious becuase `!!` is a pretty --&gt;
&lt;!-- unsafe-looking name for a function.  It tried to find index 6 of the --&gt;
&lt;!-- list...but that index doesn&#39;t exist. --&gt;
&lt;!-- There are ways to take care of that kind of sloppily, but what we want is a --&gt;
&lt;!-- function that takes a parser, a condition (the number has to be less than --&gt;
&lt;!-- four, for instance), and returns a new parser with that condition built-in. --&gt;
&lt;!-- Some spoilers --- an object that has this ability is known as a &quot;monad&quot;. Let&#39;s --&gt;
&lt;!-- keep this in mind as we move forward with our applicative parsers. --&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/functional-programming-is-awesome-parser-combinators.html</guid><pubDate>Sun, 21 Feb 2016 05:10:53 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2016-02-21</dc:date></item><item><title>Looking forward: A Doctorate Program</title><link>http://home.jle0.com:4111/entry/looking-forward-a-doctorate-program.html</link><description>&lt;p&gt;So a bit of some personal news (which you can safely ignore if you’re not interested in my personal life!) — I’m excited to announce that I have decided to accept an offer to the Computational and Data Science Doctorate Program at &lt;a href=&quot;http://www.chapman.edu/&quot;&gt;Chapman University&lt;/a&gt; in California. I came to this decision after a decently long period of deliberation and thinking things over, and weighting opportunities at Chapman against my other offers. However, having just finalized everything this week, I am in my choice of Chapman as my home for my doctoral studies in the upcoming years.&lt;/p&gt;
&lt;p&gt;There are two main aspects to my decision — why computational science, and why Chapman?&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/chapman/williams-hall.jpg&quot; title=&quot;Williams Hall --- Chapman University (Photo by Tom Arthur)&quot; alt=&quot;Williams Hall — Chapman University (Photo by Tom Arthur)&quot; /&gt;&lt;figcaption&gt;Williams Hall — Chapman University (Photo by Tom Arthur)&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;why-computational-science&quot;&gt;Why Computational Science?&lt;/h2&gt;
&lt;h3 id=&quot;from-physics&quot;&gt;From Physics&lt;/h3&gt;
&lt;p&gt;For the first few years of my journey in higher education, I had always believed that I belonged in Physics. Well, all my friends were in Physics and I didn’t really know otherwise. But even before that, there was so much I had admired about the beauty of Physics. The quest for elegance in our models. The creation and taming of new mathematics to fit our purposes. The relentless and ages-long drive to unify everything into a single, beautiful framework with as few assumptions and axioms as possible, and the fact that from such simplicity, things weave themselves together to create such stunning complexity.&lt;/p&gt;
&lt;p&gt;It was, in some ways, not too long (and in other ways, not soon enough) before I realized that I was a little out of place amongst my peers, and (apparently) a long tradition of physicists.&lt;/p&gt;
&lt;p&gt;I had often remarked that I would have just as much joy in figuring out the “physics” of a made-up universe — that the joy was in finding the mathematical models that would describe it and finding out the implications.&lt;/p&gt;
&lt;p&gt;Apparently — and who knew! — these days, physicists are driven by a desire to understand our own physical world.&lt;/p&gt;
&lt;p&gt;I looked back on all of the physicists of history who I admired — Gauss, Gibbs, Metropolis, Heisenberg — I admired them for their ability to invent and draw from new mathematics to tackle their very real problems at hand. The fact that Gauss is almost just as popular in Mathematics as he is in Physics is a true testament to his genius. And while Gibbs is known for revolutionizing statistical mechanics and thermodynamics as we know it, I was more fascinated by the intricate maths that he pioneered and &lt;em&gt;invented&lt;/em&gt;, &lt;em&gt;just&lt;/em&gt; to solve the problems at hand.&lt;/p&gt;
&lt;p&gt;Maybe, instead of taming the world, I was more fascinated with taming thought?&lt;/p&gt;
&lt;h3 id=&quot;taming-thought&quot;&gt;Taming Thought&lt;/h3&gt;
&lt;p&gt;Anyways, over the course of the first half of my final year at my undergraduate university (when I was already, incidentally, working on my applications to physics doctoral programs), I talked to more and more people and received a lot of suggestions on what was for me. I ended up spending most of my time in the Applied Maths department of my school, and I eventually stumbled upon the field of “Computational Science”.&lt;/p&gt;
&lt;p&gt;Really, it seemed to represent everything that I had been interested in and was pursuing on my own time, for the past year or two. It represented everything that interested me in the “real” lab positions and jobs I took. In everything I did, I attempted to ask “how much of this problem can I turn into a problem in computational science?”&lt;/p&gt;
&lt;p&gt;The path sort of all clicked together — in Physics, I was always a bit more experienced in computation than my Physics peers. In Computer Science, I was always a bit more experienced in maths than my CS peers. My peers were often times better grounded than me in their respective fields, but I always recognized myself as one of the few with that specific and unique interdisciplinary blend. Surely, there were people like me — surely I wasn’t alone. And after finding out about Computational Science, as a field…I realized that I wasn’t.&lt;/p&gt;
&lt;p&gt;I knew that I could easily and eagerly spend my entire academic career focused on pioneering new methods and models and theories of computation and applied maths. And I knew that it was really what I had wanted to do all along.&lt;/p&gt;
&lt;p&gt;Not only was it what I was apparently passionate about this entire time, I saw it as a very important field in the coming ages. With computation and data science more important than ever in the fields of medicine, engineering, healthcare, economics, meteorology, defense, artificial intelligence, and in simply rethinking the way we live life — I was excited to be able to be a pioneer in this new field that had the potential to impact so many sectors of the world. It was exciting also because it was such a new field that there was much room for innovation, and people today still are only beginning to partially realize what was even possible with computational science. If I can look back in sixty years at the world around me and see a revolutionized world and believe that I had a part in it all, I don’t think I’d be regretting anything.&lt;/p&gt;
&lt;p&gt;These were big motivations, but most of all, I was motivated in my shift by just simply following my interests and passions. The rest is a nice bonus!&lt;/p&gt;
&lt;p&gt;In this decision, I sort of was saying goodbye to my first love, Physics. But in a way, I really wasn’t — this was the part of Physics that I loved this entire time, and I am not the first in History to make this choice. I was eager to apply all of the intuition and tools and insight that I learned from studying Physics and finishing a B.S. on it to this field that needed — more than any other — someone who came from exactly that background. I found my fit!&lt;/p&gt;
&lt;h2 id=&quot;why-chapman&quot;&gt;Why Chapman?&lt;/h2&gt;
&lt;p&gt;After doing the above soul-searching, it came time to finally send out my applications. I collected the best of my references and wrote out my best personal statements and submitted my applications to a very narrow and selective set of schools, from a variety of programs and fields — from Physics to Electrical Engineering to Computational Sciences (drawn from this &lt;a href=&quot;http://www.siam.org/students/resources/cse_programs.php&quot;&gt;useful SIAM journal list&lt;/a&gt;). I only picked programs where I felt I could apply what I mentioned above. I was even able to manage to get a much-appreciated recommendation from a distinguished person in the Haskell community that I admired very much, a professor at University of California, San Diego.&lt;/p&gt;
&lt;p&gt;The months passed and the offers and rejections came. I did not receive an offer from my few choices in pure Physics, but I received offers from places in Electrical Engineering and Computational Science — Chapman among them.&lt;/p&gt;
&lt;p&gt;Every place I received an offer from offered their own unique benefits — from the reputation of a big name to strong ties in favorable industries, and the like.&lt;/p&gt;
&lt;p&gt;Probably the first really impactful event in my becoming certain of Chapman was my meeting with the Chancellor, Daniele Struppa — a brilliant mathematician who literally embodied everything about the field that I loved. A chancellor who still was active in research, he showed me how he himself worked in the fields of biology, seismology, geology, meteorology, and ontology, and many more by simply looking at the problems and linking concepts of applied mathematics. With knowledge of the wider context of applied maths, he was able to look into problems and find just the tool that was missing.&lt;/p&gt;
&lt;p&gt;He shared with me his vision of Chapman’s future in the sciences, and much of it reflected his own philosophy. He dreamed of expanding Chapman as an established name into industries and fields I was excited to be a part of. And I saw myself able to not only be a part of a growing field but to also be a part of a new movement and a very grand vision of an up-and-coming science university, and maybe even being able to help shape it.&lt;/p&gt;
&lt;p&gt;The fact that Chapman was home to an impressive list of top world physicists (including a 2013 Nobel Laureate involved in discovering the Higgs mechanism) didn’t hurt either!&lt;/p&gt;
&lt;p&gt;Still, this wasn’t enough to clinch my decision. Other universities I had offers from weren’t just up-and-coming — they were already established!&lt;/p&gt;
&lt;p&gt;However, when I looked at their doctorate programs (in comparison to Chapman’s), I couldn’t help but feel like I’d be compromising myself. Other departments had aspects that I could apply what I was passionate about to; advisers and teams that I could, if I twisted myself just the right way, apply my interests. However, everything about Chapman’s program seemed to just fit like a glove. The objective, the courses, and the projects and advisers, as I began to realize, were almost as if they were lifted straight from my dream school — my dream program! If I could write my own doctoral program, environment, and culture, it would almost exactly match the environment, culture, and program of Chapman.&lt;/p&gt;
&lt;p&gt;When I realized that, I realized that I had made my decision.&lt;/p&gt;
&lt;h2 id=&quot;onward&quot;&gt;Onward&lt;/h2&gt;
&lt;p&gt;So…that’s it. I’ll probably be using this coming summer to transition into Chapman and the faculty there, and maybe find a team I could try to contribute to. And then I’ll be starting in the fall. I’m excited to see how this journey winds up in four years, but I know that this is the start of an exciting next stage of my life!&lt;/p&gt;</description><author>Justin Le</author><category>Personal</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/looking-forward-a-doctorate-program.html</guid><pubDate>Sun,  1 Jun 2014 09:40:17 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Personal</dc:subject><dc:date>2014-06-01</dc:date></item><item><title>Inside My World (Ode to Functor and Monad)</title><link>http://home.jle0.com:4111/entry/inside-my-world-ode-to-functor-and-monad.html</link><description>&lt;p&gt;I like Haskell because it lets me live inside my world.&lt;/p&gt;
&lt;p&gt;There are a lot of special worlds out there! And Haskell lets me stay in those worlds, and use all of the tools I normally have when I’m not there. I get to transform normal tools into tools that work in my world.&lt;/p&gt;
&lt;p&gt;(This post is meant to be approachable by people unfamiliar with Haskell! That being said, if there is a concept you don’t understand, feel free to leave a comment, &lt;a href=&quot;https://twitter.com/mstk&quot;&gt;tweet&lt;/a&gt; me, stop by on irc at freenode’s #haskell, or give &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;Learn You a Haskell&lt;/a&gt; a quick read!)&lt;/p&gt;
&lt;h2 id=&quot;stuck-in-maybe&quot;&gt;Stuck in Maybe&lt;/h2&gt;
&lt;p&gt;(Feel free to play along with the code in this section by &lt;a href=&quot;https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs&quot;&gt;loading it into ghci&lt;/a&gt;, the Haskell interpreter!)&lt;/p&gt;
&lt;p&gt;In Haskell, we have a type called &lt;code&gt;Maybe a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This says that &lt;code&gt;Maybe a&lt;/code&gt; is like an Enumerable type of sorts; The &lt;code&gt;|&lt;/code&gt; reads like “&lt;em&gt;or&lt;/em&gt;”.&lt;/p&gt;
&lt;p&gt;This is like saying&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to define a &lt;code&gt;Bool&lt;/code&gt; data type. If I have something of type &lt;code&gt;Bool&lt;/code&gt;, it can be (literally) &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt;. If I have something of type &lt;code&gt;Maybe a&lt;/code&gt;, it can be &lt;code&gt;Nothing&lt;/code&gt; (nothing is there, it’s empty) or &lt;code&gt;Just x&lt;/code&gt; (it contains a value &lt;code&gt;x&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;If you are used to an OOP language with templates or generics, this is similar to saying &lt;code&gt;Maybe&amp;lt;a&amp;gt;&lt;/code&gt; – &lt;code&gt;Maybe&amp;lt;a&amp;gt;&lt;/code&gt; is a parameterized type over some &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This type is useful for functions that might fail:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L23-41&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- divideMaybe: Takes two integers and returns -- possibly -- their integer&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      quotient. It succeeds if the denominator is not zero, and fails if&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      it is.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;divideMaybe ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
divideMaybe _ &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
divideMaybe x y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; y)

&lt;span class=&quot;co&quot;&gt;-- headMaybe: Takes a list and returns -- possibly -- its first element.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      Fails if the list is empty, and succeeds with the first element&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      otherwise.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;headMaybe ::&lt;/span&gt; [a] &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a
headMaybe []    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
headMaybe (x&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;_) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x

&lt;span class=&quot;co&quot;&gt;-- halveMaybe: Takes an integer and returns -- possibly -- its half.  Fails&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      if it is an odd number.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;halveMaybe ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halveMaybe x &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; x &lt;span class=&quot;ot&quot;&gt;`mod`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
             &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Oh hi!&lt;/p&gt;
&lt;p&gt;For people new to Haskell:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;foo ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
foo x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;declares a function named &lt;code&gt;foo&lt;/code&gt; of type &lt;code&gt;Int -&amp;gt; Bool&lt;/code&gt; — we use &lt;code&gt;::&lt;/code&gt; to specify type signatures. &lt;code&gt;Int -&amp;gt; Bool&lt;/code&gt; means that it takes an &lt;code&gt;Int&lt;/code&gt; (named &lt;code&gt;x&lt;/code&gt;) and returns a &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I’ll often just say &lt;code&gt;bar :: Bool&lt;/code&gt; to say “the value &lt;code&gt;bar&lt;/code&gt; (of type &lt;code&gt;Bool&lt;/code&gt;)”; you could just read &lt;code&gt;::&lt;/code&gt; as “type of”.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;divideMaybe :: Int -&amp;gt; Int -&amp;gt; Maybe Int&lt;/code&gt; means that &lt;code&gt;divideMaybe&lt;/code&gt; takes two &lt;code&gt;Int&lt;/code&gt;s and returns something of type &lt;code&gt;Maybe Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You might have also noticed the pattern matching construct, &lt;code&gt;headMaybe (x:_)&lt;/code&gt;. This matches the first element in the list to the name &lt;code&gt;x&lt;/code&gt;, and the rest of the list to the wildcard, &lt;code&gt;_&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;When you want to return a value of type &lt;code&gt;Maybe a&lt;/code&gt;, you can either return &lt;code&gt;Just x&lt;/code&gt; or &lt;code&gt;Nothing&lt;/code&gt; (where &lt;code&gt;x :: a&lt;/code&gt;) — they both are members of type &lt;code&gt;Maybe a&lt;/code&gt;. That’s what &lt;code&gt;Maybe Int&lt;/code&gt; means — an &lt;code&gt;Int&lt;/code&gt; that might or might not be there!&lt;/p&gt;
&lt;p&gt;If I had something of type &lt;code&gt;Maybe Int&lt;/code&gt;, would you know for sure if that &lt;code&gt;Int&lt;/code&gt; was there or not (from just the type)? You wouldn’t! You are living in the world of uncertainties.&lt;/p&gt;
&lt;p&gt;Welcome to the world of uncertainty.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-problem&quot;&gt;The Problem&lt;/h3&gt;
&lt;p&gt;Okay, well, I have a &lt;code&gt;Maybe Int&lt;/code&gt;. Which is nice and all…but…I want to do normal inty-things with it.&lt;/p&gt;
&lt;p&gt;That is…I have all these functions that work only on &lt;code&gt;Int&lt;/code&gt;!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L43-50&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;addThree ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
addThree &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)

&lt;span class=&quot;ot&quot;&gt;square ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
square &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)

showInt&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
showInt &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; show&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But…I can’t do these things on &lt;code&gt;Maybe Int&lt;/code&gt;!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThree (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SCARY&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; addThree takes an &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; but you gave it a &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;What&lt;/span&gt; are you trying to &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; anyway, wise guy&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In this post, commands at the interactive Haskell interpreter (REPL) ghci are prefaced with the prompt &lt;code&gt;ghci&amp;gt;&lt;/code&gt;. If you see &lt;code&gt;ghci&amp;gt;&lt;/code&gt;, it means that this is something you’d enter at ghci. If not, it is normal Haskell source code!&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;ghci&lt;/code&gt;, we also have this command &lt;code&gt;:t&lt;/code&gt; that you’ll be seeing often that lets you find the type of something:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In most other languages, to get around this, you would “exit” your uncertain world. That is, you would turn your uncertain 5 into either a certain 5 or an error. Or you would turn your uncertain 5 into either a certain 5 or some “default” value.&lt;/p&gt;
&lt;p&gt;That is, you would use functions like these to exit your world:&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L76-82&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;certaintify ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
certaintify (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
certaintify &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; error &lt;span class=&quot;st&quot;&gt;&amp;quot;Nothing was there, you fool!&amp;quot;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;certaintifyWithDefault ::&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a
certaintifyWithDefault _ (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; x
certaintifyWithDefault d &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; d&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then you can just willy-nilly use your normal &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt; functions on what you pull out…using various “error handling” mechanisms if it was &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThree (certaintify (headMaybe [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]))
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; square (certaintify (halveMaybe &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;))
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; was there, you fool&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; square (certaintifyWithDefault &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; (halveMaybe &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;))
&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But…work with me here. Let’s say I want to live in my uncertain world.&lt;/p&gt;
&lt;p&gt;There are a lot of reasons why one might want to do that.&lt;/p&gt;
&lt;p&gt;Let’s say you had a function that looked up a person from a database given their ID number. But not all ID numbers have a person attached, so the function might fail and not lookup anyone.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;personFromId ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Person&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And you also had a function that returned the age of a given person:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;age ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What if you wanted to write a function that looked up &lt;em&gt;the age of the person in that database with that ID&lt;/em&gt;. The result is going to also be in a &lt;code&gt;Maybe&lt;/code&gt;, because the given ID might not correspond to anyone to have an age for.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;ageFromId ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, it would make no sense to “exit” the world of uncertainty as soon as we get a &lt;code&gt;Maybe Person&lt;/code&gt;, and then “re-enter” it somehow when you return the &lt;code&gt;Maybe Int&lt;/code&gt;. Our entire answer is shrouded in uncertainty, so we need to &lt;em&gt;stay inside this world&lt;/em&gt; the entire time. We want to find a way to deal with values inside a world &lt;em&gt;without leaving it&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So we have a function &lt;code&gt;Person -&amp;gt; Int&lt;/code&gt;, and a &lt;code&gt;Maybe Person&lt;/code&gt;…darnit. How do we use our &lt;code&gt;age&lt;/code&gt; function, without leaving &lt;code&gt;Maybe&lt;/code&gt;? We certainly want to re-use the same function somehow, and not write it again from scratch!&lt;/p&gt;
&lt;h3 id=&quot;can-i-have-a-lift&quot;&gt;Can I have a lift?&lt;/h3&gt;
&lt;p&gt;So the problem: I have a function &lt;code&gt;a -&amp;gt; b&lt;/code&gt; that I want to be able to use on a &lt;code&gt;Maybe a&lt;/code&gt;…I want to stay in my &lt;code&gt;Maybe&lt;/code&gt; world and use that function on the uncertain value.&lt;/p&gt;
&lt;p&gt;If you look at this carefully, we want some sort of “function transformer”. Give our transformer an &lt;code&gt;a -&amp;gt; b&lt;/code&gt;, it’ll output a new function &lt;code&gt;Maybe a -&amp;gt; Maybe b&lt;/code&gt;. The new function takes an &lt;code&gt;a&lt;/code&gt; that may or may not be there, and outputs a &lt;code&gt;b&lt;/code&gt; that may or not be there.&lt;/p&gt;
&lt;p&gt;We want a function of type &lt;code&gt;(a -&amp;gt; b) -&amp;gt; (Maybe a -&amp;gt; Maybe b)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Let’s make one! It’ll apply the function to the value inside a &lt;code&gt;Just&lt;/code&gt;, and leave a &lt;code&gt;Nothing&lt;/code&gt; alone.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L84-88&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;inMaybe ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b)
inMaybe f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftedF
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    liftedF (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (f x)
    liftedF &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What can we do with it?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; addThreeInMaybe &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; inMaybe addThree
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThreeInMaybe (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThreeInMaybe &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (inMaybe square) (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;81&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (inMaybe showInt) &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (inMaybe showInt) (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;8&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Wow! We can now use normal functions and still stay inside my uncertain world. We could even write our &lt;code&gt;ageFromId&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L68-69&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;ageFromId ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ageFromId i &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (inMaybe age) (personFromId i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we are no longer afraid of dealing with uncertainty. It’s a scary realm, but as long as we have &lt;code&gt;inMaybe&lt;/code&gt;…all of our normal tools apply!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; headMaybe [&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]        &lt;span class=&quot;co&quot;&gt;-- x = Just 2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (inMaybe square) x       &lt;span class=&quot;co&quot;&gt;-- y = Just 4&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; z &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (inMaybe addThree) y     &lt;span class=&quot;co&quot;&gt;-- z = Just 7&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (inMaybe (&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)) z
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; halveMaybe &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;            &lt;span class=&quot;co&quot;&gt;-- x&amp;#39; = Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (inMaybe square) x&amp;#39;     &lt;span class=&quot;co&quot;&gt;-- y&amp;#39; = Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; z&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (inMaybe addThree) y&amp;#39;   &lt;span class=&quot;co&quot;&gt;-- z&amp;#39; = Nothing&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (inMaybe (&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)) z&amp;#39;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;functor&quot;&gt;Functor&lt;/h3&gt;
&lt;p&gt;This concept of “bringing functions into worlds” is actually a useful and generalizable concept. In fact, in the standard libraries, there’s a typeclass (which is like an interface, sorta, for you Java/OOP people) that provides a common API/interface for “worlds that you can bring functions into.”&lt;/p&gt;
&lt;p&gt;We call it &lt;code&gt;Functor&lt;/code&gt;, and this “bring into world” function is called &lt;code&gt;fmap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It should come as no surprise that &lt;code&gt;Maybe&lt;/code&gt; is a Functor, so &lt;code&gt;fmap&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; take any function &lt;code&gt;a -&amp;gt; b&lt;/code&gt; and “lifts” it into the &lt;code&gt;Maybe&lt;/code&gt; world, turning it into a &lt;code&gt;Maybe a -&amp;gt; Maybe b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fmap&lt;/code&gt; for &lt;code&gt;Maybe&lt;/code&gt; is incidentally exactly our &lt;code&gt;inMaybe&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (fmap square) (headMaybe [&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;])
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (fmap square) (halveMaybe &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Any “legitimate” instance of &lt;code&gt;Functor&lt;/code&gt; must satisfy a couple of properties — “laws”, so to speak. These laws basically ensure that whatever instance you define is useful and sensible, and follow what sort of meaning &lt;code&gt;fmap&lt;/code&gt; is supposed to convey.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;code&gt;fmap (f . g)&lt;/code&gt; should equal &lt;code&gt;fmap f . fmap g&lt;/code&gt;; that is, lifting composed functions be the same as composing lifted functions. (&lt;code&gt;(.)&lt;/code&gt; is the function composition operator)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fmap id thing&lt;/code&gt; should leave &lt;code&gt;thing&lt;/code&gt; unchanged.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;Some notes before we move on!&lt;/p&gt;
&lt;p&gt;First of all, even though we have been writing things like &lt;code&gt;(fmap f) x&lt;/code&gt;, the parentheses are actually unnecessary due to the way Haskell associates function calls. So &lt;code&gt;(fmap f) x&lt;/code&gt; is the same as &lt;code&gt;fmap f x&lt;/code&gt;, and we’ll be writing it that way from now on.&lt;/p&gt;
&lt;p&gt;Secondly, an infix operator alias for &lt;code&gt;fmap&lt;/code&gt; exists: &lt;code&gt;(&amp;lt;$&amp;gt;)&lt;/code&gt;. That way, you can write &lt;code&gt;fmap f x&lt;/code&gt; as &lt;code&gt;f &amp;lt;$&amp;gt; x&lt;/code&gt;, which is meant to look similar to &lt;code&gt;f $ x&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThree &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThree &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; addThree &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(For those unfamiliar, &lt;code&gt;f $ x&lt;/code&gt; = &lt;code&gt;f x&lt;/code&gt;)&lt;/p&gt;
&lt;h3 id=&quot;sort-of-a-big-deal&quot;&gt;Sort of a big deal&lt;/h3&gt;
&lt;p&gt;Let’s pause and reflect to see that this is sort of a big deal, and see what problem &lt;code&gt;Functor&lt;/code&gt; just solved.&lt;/p&gt;
&lt;p&gt;In another language, you might somehow have a &lt;code&gt;Maybe&amp;lt;Int&amp;gt;&lt;/code&gt; (using generics syntax). And you have lots and lots and lots of functions that take &lt;code&gt;Int&lt;/code&gt;s. Heck, why would you even ever have a function take a &lt;code&gt;Maybe&amp;lt;Int&amp;gt;&lt;/code&gt;? A function would be like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode java&quot;&gt;&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Monster {
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deal_damage&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; damage) {};
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where your &lt;code&gt;deal_damage&lt;/code&gt; function would take an integer. So &lt;code&gt;Maybe Int&lt;/code&gt; is useless! You either have to re-write &lt;code&gt;deal_damage&lt;/code&gt; to take a &lt;code&gt;Maybe Int&lt;/code&gt;, and have &lt;em&gt;two versions&lt;/em&gt; of it, or you turn your &lt;code&gt;Maybe Int&lt;/code&gt; into an &lt;code&gt;Int&lt;/code&gt; somehow.&lt;/p&gt;
&lt;p&gt;In this light, &lt;code&gt;Maybe&lt;/code&gt; is a huge nuisance. It is a big, annoying thing to deal with and it probably results in a lot of boilerplate, making you either duplicate functions or extract &lt;code&gt;Maybe&lt;/code&gt; values every time you get one.&lt;/p&gt;
&lt;p&gt;But now…&lt;em&gt;now&lt;/em&gt;, &lt;code&gt;Maybe&lt;/code&gt; is not a nuisance, and there is &lt;em&gt;no boilerplate&lt;/em&gt;. All your functions now…&lt;em&gt;just work&lt;/em&gt;, as they are!&lt;/p&gt;
&lt;p&gt;And this is a big deal.&lt;/p&gt;
&lt;h2 id=&quot;pre-lifting&quot;&gt;“Pre-lifting”&lt;/h2&gt;
&lt;p&gt;Okay, so we now can turn &lt;code&gt;a -&amp;gt; b&lt;/code&gt; into &lt;code&gt;Maybe a -&amp;gt; Maybe b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That might be nice, but if you scroll up just a bit, you might see that there are other functions that might be interesting to apply on a &lt;code&gt;Maybe a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What about &lt;code&gt;halveMaybe :: Int -&amp;gt; Maybe Int&lt;/code&gt;? Can I use &lt;code&gt;halveMaybe&lt;/code&gt; on a &lt;code&gt;Maybe Int&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; divideMaybe &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- x = Just 4 :: Maybe Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; halveMaybe x
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SCARY&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ERROR&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;!&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; halveMaybe takes an &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; but you gave it
&lt;span class=&quot;fu&quot;&gt;***&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;  &lt;span class=&quot;dt&quot;&gt;Please&lt;/span&gt; think about your life&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oh no! Maybe we can’t really stay inside our &lt;code&gt;Maybe&lt;/code&gt; world after all!&lt;/p&gt;
&lt;p&gt;This might be important! Let’s imagine this trip down our world of uncertainty — let’s say we wanted a function &lt;code&gt;halfOfAge&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halfOfAge ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That returns (possibly), half of the age of the person corresponding to that ID (and &lt;code&gt;Nothing&lt;/code&gt; if the person looked up has an odd age. Because odd ages don’t have halves, of course.). Well, we already have &lt;code&gt;ageFromId :: ID -&amp;gt; Maybe Int&lt;/code&gt;, but we want to apply &lt;code&gt;halveMaybe&lt;/code&gt; to that &lt;code&gt;Maybe Int&lt;/code&gt;. But we can’t! Because &lt;code&gt;halveMaybe&lt;/code&gt; only works on &lt;code&gt;Int&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;We can’t even use &lt;code&gt;fmap&lt;/code&gt;, because:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t fmap halveMaybe
fmap&lt;span class=&quot;ot&quot;&gt; halveMaybe ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Wrong wrong wrong! We don’t want a &lt;code&gt;Maybe Int -&amp;gt; Maybe (Maybe Int)&lt;/code&gt;, we want a &lt;code&gt;Maybe Int -&amp;gt; Maybe Int&lt;/code&gt;! &lt;code&gt;fmap&lt;/code&gt; lifts “both sides” of the function, but we only want, in this case, to “lift” the input.&lt;/p&gt;
&lt;p&gt;This is a disaster!&lt;/p&gt;
&lt;p&gt;But wait, calm down. We have overcome similar things before. With our recent journey to Functor enlightenment in mind, let’s try to look for a similar path.&lt;/p&gt;
&lt;p&gt;We had an &lt;code&gt;a -&amp;gt; b&lt;/code&gt; that we wanted to apply to a &lt;code&gt;Maybe a&lt;/code&gt;, we used &lt;code&gt;fmap&lt;/code&gt; to turn it into a &lt;code&gt;Maybe a -&amp;gt; Maybe b&lt;/code&gt;. So we have a &lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt; here that we want to apply to a &lt;code&gt;Maybe a&lt;/code&gt;. The plan is simple! We turn an &lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt; into a &lt;code&gt;Maybe a -&amp;gt; Maybe b&lt;/code&gt;. Let’s pretend we had such a function.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;liftInput ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How should we expect this to behave?&lt;/p&gt;
&lt;p&gt;Well, let’s think this through case-by-case.&lt;/p&gt;
&lt;p&gt;If we want to apply &lt;code&gt;halveMaybe&lt;/code&gt; to a number that isn’t there…well…it should also return a number that isn’t there. It should propagate the not-thereness.&lt;/p&gt;
&lt;p&gt;If we want to apply &lt;code&gt;halveMaybe&lt;/code&gt; to a number that &lt;em&gt;is&lt;/em&gt; there…well, just apply it to that number, and take that result! If the result is there, then you have a result there. If the result is not there, then you don’t.&lt;/p&gt;
&lt;p&gt;We have enough to write this out ourselves:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L90-94&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;liftInput ::&lt;/span&gt; (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b) &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; b)
liftInput f &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; liftedF
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    liftedF &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
    liftedF (&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; x) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t liftInput halveMaybe
&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; divideMaybe &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- x = Just 4 :: Maybe Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (liftInput halveMaybe) x
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; divideMaybe &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- y = Nothing :: Maybe Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (liftInput halveMaybe) y
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! Now we don’t have to fear &lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt;’s…we can use them and &lt;em&gt;still stay in our world&lt;/em&gt;, without leaving our world of uncertainty!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/maybe.hs#L71-72&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;halfOfAge ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halfOfAge i &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; (liftInput halveMaybe) (ageFromId i)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;monad&quot;&gt;Monad&lt;/h3&gt;
&lt;p&gt;Like with Functor and &lt;code&gt;fmap&lt;/code&gt;, this general pattern of turning an &lt;code&gt;a -&amp;gt; f b&lt;/code&gt; into an &lt;code&gt;f a -&amp;gt; f b&lt;/code&gt; is also useful to generalize.&lt;/p&gt;
&lt;p&gt;In general, you can think functions &lt;code&gt;a -&amp;gt; world b&lt;/code&gt; as functions that “bring you into your world”. We would like to turn it, in general, into &lt;code&gt;world a -&amp;gt; world b&lt;/code&gt;. Lifting the input only, so to speak.&lt;/p&gt;
&lt;p&gt;We say that if a world has such a way of lifting the input of such a function (plus some other requirements), it implements the &lt;code&gt;Monad&lt;/code&gt; typeclass&lt;a href=&quot;#fn3&quot; class=&quot;footnoteRef&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;!-- Now, you may or not have known this, but Monads have a...reputation.  You --&gt;
&lt;!-- might have heard that Monads were super scary and intimidating.  And you might --&gt;
&lt;!-- have tried (successfully or unsuccessfully) to &quot;get&quot; Monads.  Well, hopefully --&gt;
&lt;!-- you don&#39;t have to search too much further! --&gt;
&lt;p&gt;Monad is a typeclass (which is kinda like an interface), so that means that if &lt;code&gt;Maybe&lt;/code&gt; is a Monad, it “implements” that way to turn a &lt;code&gt;a -&amp;gt; Maybe b&lt;/code&gt; into a &lt;code&gt;Maybe a -&amp;gt; Maybe b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We call this &lt;code&gt;(a -&amp;gt; Maybe b) -&amp;gt; (Maybe a -&amp;gt; Maybe b)&lt;/code&gt; function “bind”.&lt;/p&gt;
&lt;p&gt;Now, embarrassingly enough, “bind” actually isn’t called &lt;code&gt;bind&lt;/code&gt; in the standard library…it actually only exists as an operator, &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;(Remember how there was an operator form of &lt;code&gt;fmap&lt;/code&gt;? We have both &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(&amp;lt;$&amp;gt;)&lt;/code&gt;? Well, in this case, we &lt;em&gt;only&lt;/em&gt; have the operator form of &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;. Yeah, I know. But we live with it just fine!).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; is exactly our &lt;code&gt;liftInput&lt;/code&gt; for &lt;code&gt;Maybe&lt;/code&gt;. Let’s try it out:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t (&lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt;) halveMaybe
&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; divideMaybe &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- x = Just 4 :: Maybe Int&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- use it as a prefix function&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt;) halveMaybe x
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; divideMaybe &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- y = Nothing :: Maybe Int&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- use it as an infix operator&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; halveMaybe &lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt; y
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now maybe we can finally rest easy knowing that we can “stay inside &lt;code&gt;Maybe&lt;/code&gt;” and never have to leave it.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The “other thing” that Monad has to have (the other thing that the “interface” demands, besides &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;) is a way to “bring a value into your world”.&lt;/p&gt;
&lt;p&gt;This function is called &lt;code&gt;return&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, for &lt;code&gt;Maybe&lt;/code&gt;, we need a way to take a normal value like an &lt;code&gt;Int&lt;/code&gt; and “bring it into” our world of uncertainty — an &lt;code&gt;Int -&amp;gt; Maybe Int&lt;/code&gt;. For &lt;code&gt;Maybe&lt;/code&gt;, semantically, to bring something like &lt;code&gt;7&lt;/code&gt; into the world of uncertainty…well, we already know the &lt;code&gt;7&lt;/code&gt; is there. So to bring a &lt;code&gt;7&lt;/code&gt; into &lt;code&gt;Maybe&lt;/code&gt;, it’s just &lt;code&gt;Just 7&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;For an instance of &lt;code&gt;Monad&lt;/code&gt; to be considered legitimate, there are a few rules/laws that &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; must obey when used together in order to be useful (just like for &lt;code&gt;Functor&lt;/code&gt;). If you define nonsensical &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, of course, your instance won’t be very useful anyway, and you wouldn’t be able to reason with how they work together. The laws sort of are some way of ensuring that your instance is useful and sensible, and that &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; make sense at all.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now, for some strange reason, it is actually much more popular to use &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; over &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;; &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; is just &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; backwards:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; halveMaybe &lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halveMaybe
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is really weird! I mean…really &lt;em&gt;really&lt;/em&gt; weird! Why would you ever put the function you are applying &lt;em&gt;after&lt;/em&gt; the value you are applying it to? That’s like having &lt;code&gt;x :: a&lt;/code&gt; and &lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, and doing &lt;code&gt;x f&lt;/code&gt; or something!&lt;/p&gt;
&lt;p&gt;Why is this style the norm? Who knows!&lt;a href=&quot;#fn4&quot; class=&quot;footnoteRef&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; People are just weird!&lt;/p&gt;
&lt;p&gt;For the rest of this article, we will be using &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;; just be aware that you might see &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; out in the wild more often!&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;/h2&gt;
&lt;p&gt;Thanks to Functor and Monad, we now have a way to confidently stay in our world of uncertainty and still use normal functions on our uncertain values — we only have to use the right “lifters”.&lt;/p&gt;
&lt;p&gt;If you have an &lt;code&gt;x :: Maybe a&lt;/code&gt; and you have a:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;f :: a -&amp;gt; b&lt;/code&gt;, then use &lt;code&gt;fmap&lt;/code&gt; or &lt;code&gt;(&amp;lt;$&amp;gt;)&lt;/code&gt; — &lt;code&gt;fmap f x&lt;/code&gt; or &lt;code&gt;f &amp;lt;$&amp;gt; x&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;f :: a -&amp;gt; Maybe b&lt;/code&gt;, then use &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; — &lt;code&gt;f =&amp;lt;&amp;lt; x&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Armed with these two, you can comfortably stay in &lt;code&gt;Maybe&lt;/code&gt; without ever having to “get out of it”!&lt;/p&gt;
&lt;h3 id=&quot;a-big-picture&quot;&gt;A big picture&lt;/h3&gt;
&lt;p&gt;Again, the big picture is this: sometimes we get values inside contexts, or worlds. But we have functions like &lt;code&gt;a -&amp;gt; world b&lt;/code&gt; that &lt;em&gt;produce values inside your world&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Which normally would leave you “high and dry”, because you can’t, say, apply that same function twice. You either have to write a new &lt;code&gt;world a -&amp;gt; world b&lt;/code&gt; version or some other boilerplate.&lt;/p&gt;
&lt;p&gt;With Functor, we can make normal functions treat our world values like normal values; with Monad, we can do the same with functions that “bring us into” worlds. With these two together…maybe contexted values aren’t so bad after all!&lt;/p&gt;
&lt;h2 id=&quot;other-worlds&quot;&gt;Other Worlds&lt;/h2&gt;
&lt;h3 id=&quot;on-worlds&quot;&gt;on Worlds&lt;/h3&gt;
&lt;p&gt;You might have noticed that up until now I have used the word “world” pretty vaguely.&lt;/p&gt;
&lt;p&gt;When I say that a value is “inside” a “world”, I mean that it “lives” inside the context of what that world represents. A &lt;code&gt;Maybe a&lt;/code&gt; is an &lt;code&gt;a&lt;/code&gt; living in the &lt;code&gt;Maybe&lt;/code&gt; “world” — it is an &lt;code&gt;a&lt;/code&gt; that can exist or not exist. &lt;code&gt;Maybe&lt;/code&gt; represents a context of existing-or-not-existing.&lt;a href=&quot;#fn5&quot; class=&quot;footnoteRef&quot; id=&quot;fnref5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;But there are other worlds, and other contexts too. And though I have shown you what Functor and Monad look like for &lt;code&gt;Maybe&lt;/code&gt;…you probably need to see a few more examples to be really convinced that these are general design patterns that you can apply to multiple “values in contexts”.&lt;/p&gt;
&lt;p&gt;It’s important to remember that &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; don’t really have any inherent semantic meaning…and their usefulness and “meaning” come from just the specific instance. We saw what they “did” for &lt;code&gt;Maybe&lt;/code&gt;, but their meaning came from &lt;code&gt;Maybe&lt;/code&gt; itself. For other worlds, as we will see, we can make them mean completely different things.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There are some important nuances that might trip you up! Though useful worlds are instances of Monad, it is improper to say that “Monads are worlds/values in contexts”. That’s not what Monads &lt;em&gt;are&lt;/em&gt;. Monads are just Monads (the two functions and their laws), no more and no less.&lt;/p&gt;
&lt;p&gt;In our usage here, Functor and Monad mean only “these things implement some sort of &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, etc., and those two are useful.” That is, the interface offered by Functor and Monad are useful for our specific world. But there are plenty of Functors and Monads that are not “worlds”.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Anyways, here is a whirlwind tour of different worlds, to help you realize how often you’ll actually want to live in these worlds in Haskell, and why having &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; are so useful!&lt;/p&gt;
&lt;h3 id=&quot;the-world-of-future-values&quot;&gt;The world of future values&lt;/h3&gt;
&lt;p&gt;(Play along with this section too by &lt;a href=&quot;https://github.com/mstksg/blog/tree/develop/code-samples/inside/reader.hs&quot;&gt;loading the source&lt;/a&gt;!)&lt;/p&gt;
&lt;p&gt;In Haskell, we have a &lt;code&gt;Reader r&lt;/code&gt; world. You can think of &lt;code&gt;(Reader r) a&lt;/code&gt; as a little machine that “waits” for something of type &lt;code&gt;r&lt;/code&gt;, then &lt;em&gt;uses&lt;/em&gt; it to (purely) make an &lt;code&gt;a&lt;/code&gt;. The &lt;code&gt;a&lt;/code&gt; doesn’t exist yet; it’s a future &lt;code&gt;a&lt;/code&gt; that will exist as soon as you give it an &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/reader.hs#L17-27&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- futureLength: A future `Int` that will be the length of whatever the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      list it is waiting for will be.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;futureLength ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- futureHead: An future `a` that will be the first element of whatever the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      list it is waiting for will be.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;futureHead   ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) a

&lt;span class=&quot;co&quot;&gt;-- futureOdd: A future `Bool` that will be whether the `Int` it is waiting&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      for is odd or not.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;futureOdd    ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;futureLength&lt;/code&gt; is a “future &lt;code&gt;Int&lt;/code&gt;”; an &lt;code&gt;Int&lt;/code&gt; waiting (for an &lt;code&gt;[a]&lt;/code&gt;) to be realized. &lt;code&gt;futureHead&lt;/code&gt; is a “future &lt;code&gt;a&lt;/code&gt;”, waiting for an &lt;code&gt;[a]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We use the function &lt;code&gt;runReader&lt;/code&gt; to “force” the &lt;code&gt;a&lt;/code&gt; out of the &lt;code&gt;(Reader r) a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- given a `(Reader r) a` and an `r`, uses that `r` to finally get the `a`:&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;runReader ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; r) a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; a&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureLength [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureHead [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureOdd &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureOdd &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Welcome to the world of future values.&lt;/p&gt;
&lt;div class=&quot;note&quot;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;It is important to note here that &lt;code&gt;(Reader Int) Bool&lt;/code&gt; and &lt;code&gt;(Reader [Int]) Bool&lt;/code&gt; &lt;em&gt;do not exist&lt;/em&gt; in the same world. One lives in a &lt;code&gt;Reader Int&lt;/code&gt; world — a world of future values awaiting an &lt;code&gt;Int&lt;/code&gt;. The other lives in a &lt;code&gt;Reader [Int]&lt;/code&gt; world — a world of future values awaiting an &lt;code&gt;[Int]&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Let’s say I have a future &lt;code&gt;Int&lt;/code&gt;. Say, &lt;code&gt;futureLength&lt;/code&gt;, waiting on an &lt;code&gt;[a]&lt;/code&gt;. And I have a function &lt;code&gt;(&amp;lt; 5) :: Int -&amp;gt; Bool&lt;/code&gt;. Can I apply &lt;code&gt;(&amp;lt; 5)&lt;/code&gt; to my future &lt;code&gt;Int&lt;/code&gt;, in order to get a future &lt;code&gt;Bool&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;At first, no! This future &lt;code&gt;Int&lt;/code&gt; is useless! I can’t even use it in &lt;em&gt;any&lt;/em&gt; of my normal functions! Time to reach for the exit button?&lt;/p&gt;
&lt;p&gt;Oh — but, because &lt;code&gt;Reader [a]&lt;/code&gt; is a Functor, I can use &lt;code&gt;fmap&lt;/code&gt; to turn &lt;code&gt;(&amp;lt; 5) :: Int -&amp;gt; Bool&lt;/code&gt; into &lt;code&gt;fmap (&amp;lt; 5) :: (Reader [a]) Int -&amp;gt; (Reader [a]) Bool&lt;/code&gt;!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/reader.hs#L34-38&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;futureShorterThan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
futureShorterThan n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fmap (&lt;span class=&quot;fu&quot;&gt;&amp;lt;&lt;/span&gt; n) futureLength

&lt;span class=&quot;ot&quot;&gt;futureShorterThan5 ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
futureShorterThan5 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; futureShorterThan &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureShorterThan5 [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader (futureShorterThan &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;) [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And voilà, we have a future &lt;code&gt;Bool&lt;/code&gt;. We turned an &lt;code&gt;Int -&amp;gt; Bool&lt;/code&gt; into a function that takes a future &lt;code&gt;Int&lt;/code&gt; and returns a future &lt;code&gt;Bool&lt;/code&gt;. We &lt;em&gt;applied &lt;code&gt;(&amp;lt; 5)&lt;/code&gt; to our future length&lt;/em&gt;, to get a future &lt;code&gt;Bool&lt;/code&gt; telling us if that length is less than 5.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;futureShorterThan&lt;/code&gt; is a function that takes an &lt;code&gt;Int&lt;/code&gt; and turns it into a future &lt;code&gt;Bool&lt;/code&gt;. Let’s go…deeper. What if I wanted to apply &lt;code&gt;futureShorterThan&lt;/code&gt; to a &lt;em&gt;future&lt;/em&gt; &lt;code&gt;Int&lt;/code&gt;? To &lt;em&gt;still&lt;/em&gt; get a future &lt;code&gt;Bool&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;I can’t apply &lt;code&gt;futureShorterThan&lt;/code&gt; to a future &lt;code&gt;Int&lt;/code&gt; straight-up, because it only takes &lt;code&gt;Int&lt;/code&gt;. Boo! But, wait — &lt;code&gt;Reader [Int]&lt;/code&gt; is a Monad, so that means I can take the &lt;code&gt;Int -&amp;gt; (Reader [a]) Bool&lt;/code&gt; and turn it into a &lt;code&gt;(Reader [a]) Int -&amp;gt; (Reader [a]) Bool&lt;/code&gt; using &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, we turned a function from &lt;code&gt;Int&lt;/code&gt; to a future &lt;code&gt;Bool&lt;/code&gt; to a function from a future &lt;code&gt;Int&lt;/code&gt; to a future &lt;code&gt;Bool&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;futureShorterThan       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;              &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
(&lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt;)&lt;span class=&quot;ot&quot;&gt; futureShorterThan ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [a]) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hm. Let’s try this out on a future &lt;code&gt;Int&lt;/code&gt; we have…we can use &lt;code&gt;futureHead :: (Reader [Int]) Int&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/reader.hs#L40-41&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;futureShorterThanHead ::&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Reader&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]) &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
futureShorterThanHead &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; futureShorterThan &lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt; futureHead&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, we are applying &lt;code&gt;futureShorterThan&lt;/code&gt; to the &lt;code&gt;Int&lt;/code&gt; we got from &lt;code&gt;futureHead&lt;/code&gt;. And so we get a future &lt;code&gt;Bool&lt;/code&gt; that tells us if that future &lt;code&gt;Int&lt;/code&gt; we got from the input list is shorter than the input list.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureShorterThanHead [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;
ghci&lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; runReader futureShorterThanHead [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat!&lt;/p&gt;
&lt;p&gt;Now, we can live in a world of “future values”, and now use all of our “normal” functions on future values!&lt;/p&gt;
&lt;p&gt;In another language, we might have had to do this complicated dance of “forcing” futures to get the value (to “exit” the world of future values), applying functions to that value, and going “back into” the future.&lt;/p&gt;
&lt;p&gt;But now, we &lt;em&gt;don’t have to be scared of future values&lt;/em&gt;. We can work with them just as well as if they were normal values, and “leave” them as futures the entire time, without ever forcing them until when we really need to, and only force them &lt;em&gt;once&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Who said futures were complicated, anyway?&lt;/p&gt;
&lt;h3 id=&quot;the-world-of-io&quot;&gt;The world of “IO”&lt;/h3&gt;
&lt;p&gt;(The source code for this section is &lt;a href=&quot;https://github.com/mstksg/blog/tree/develop/code-samples/inside/io.hs&quot;&gt;also available online&lt;/a&gt; for you to play with!)&lt;/p&gt;
&lt;p&gt;And now we go into the most infamous of Haskell worlds, &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IO&lt;/code&gt; is “kind of like” our &lt;code&gt;Reader r&lt;/code&gt; world — an &lt;code&gt;IO Int&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; that &lt;em&gt;doesn’t yet exist&lt;/em&gt;…but that will be computed by a CPU/computer &lt;em&gt;when a CPU executes it&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In this sense, an &lt;code&gt;IO Int&lt;/code&gt; is kind of like a little packet of Assembly or C code — it contains instructions (assembly commands, machine language) for a computer to do this and that and eventually produce an &lt;code&gt;Int&lt;/code&gt;. An &lt;code&gt;IO String&lt;/code&gt; could, for example, be a little packet of C code that reads a file and outputs the contents of that file. The &lt;code&gt;String&lt;/code&gt; doesn’t exist yet — but it will, once the computer executes those commands.&lt;/p&gt;
&lt;p&gt;If you’ve ever used a Unix operating system, there is a shell command &lt;code&gt;ls&lt;/code&gt; that lists the contents of a directory. The actual &lt;code&gt;ls&lt;/code&gt; program is kind of like an &lt;code&gt;IO [FilePath]&lt;/code&gt;. The &lt;code&gt;[FilePath]&lt;/code&gt; does not “exist” inside&amp;quot; &lt;code&gt;ls&lt;/code&gt; — rather, &lt;code&gt;ls&lt;/code&gt; is a program that promises a list of &lt;code&gt;FilePath&lt;/code&gt;s when it is executed by the computer or interpreter.&lt;/p&gt;
&lt;p&gt;So an &lt;code&gt;IO String&lt;/code&gt; doesn’t “contain” a &lt;code&gt;String&lt;/code&gt; — it is a program that &lt;em&gt;promises&lt;/em&gt; a &lt;code&gt;String&lt;/code&gt; in the future, when a computer eventually executes it,&lt;a href=&quot;#fn6&quot; class=&quot;footnoteRef&quot; id=&quot;fnref6&quot;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;One common IO object we are given is &lt;code&gt;getLine :: IO String&lt;/code&gt;. &lt;code&gt;getLine&lt;/code&gt; is kind of like the Unix program &lt;code&gt;cat&lt;/code&gt; — it promises a &lt;code&gt;String&lt;/code&gt;, and it gets that &lt;code&gt;String&lt;/code&gt; by taking in from standard input. That is, it is a program that, when executed by a computer, pulls a line from stdin, and returns that as the &lt;code&gt;String&lt;/code&gt; it promises. &lt;code&gt;getLine&lt;/code&gt; contains instructions for a computer to get a &lt;code&gt;String&lt;/code&gt; from stdin. A future/promised &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We want to apply &lt;code&gt;length :: String -&amp;gt; Int&lt;/code&gt; to that future/promised &lt;code&gt;String&lt;/code&gt;, to get us a future/promised &lt;code&gt;Int&lt;/code&gt;. Again, we can’t apply &lt;code&gt;length&lt;/code&gt; to &lt;code&gt;getLine&lt;/code&gt; directly — but because &lt;code&gt;IO&lt;/code&gt; is a Functor, we can use &lt;code&gt;fmap length :: IO String -&amp;gt; IO Int&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;getLine&lt;span class=&quot;ot&quot;&gt;             ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
length&lt;span class=&quot;ot&quot;&gt;              ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
fmap&lt;span class=&quot;ot&quot;&gt; length         ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
fmap length&lt;span class=&quot;ot&quot;&gt; getLine ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat!&lt;/p&gt;
&lt;p&gt;We had a function that only worked on &lt;code&gt;String&lt;/code&gt;, but we made it work the “future/promised” &lt;code&gt;String&lt;/code&gt; of &lt;code&gt;IO String&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Let’s look at a function returning an IO action &lt;code&gt;wc&lt;/code&gt;, which takes a filename and returns a program that, when executed, promises an &lt;code&gt;Int&lt;/code&gt; — the number of lines in that file.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/inside/io.hs#L19-19&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/inside-my-world&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;wc ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;wc &amp;quot;file.txt&amp;quot;&lt;/code&gt; would evaluate to a computation that, when executed by a computer, produces an &lt;code&gt;Int&lt;/code&gt; (by loading the file from disk using system calls, reading it, and counting the lines).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wc&lt;/code&gt; is a function that takes a (non-future, normal) &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But what if we wanted to apply &lt;code&gt;wc&lt;/code&gt; to &lt;code&gt;getLine&lt;/code&gt;, the &lt;code&gt;IO String&lt;/code&gt; we had? We want to apply &lt;code&gt;wc&lt;/code&gt; to that “future &lt;code&gt;String&lt;/code&gt;”. We can’t apply it directly. We want to turn our &lt;code&gt;String -&amp;gt; IO Int&lt;/code&gt; into an &lt;code&gt;IO String -&amp;gt; IO Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Luckily, &lt;code&gt;IO&lt;/code&gt; is a Monad, so we have &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; at our disposal.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;getLine&lt;span class=&quot;ot&quot;&gt;        ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;wc             ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
(&lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt;)&lt;span class=&quot;ot&quot;&gt; wc       ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
wc &lt;span class=&quot;fu&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; getLine ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat!&lt;/p&gt;
&lt;p&gt;What does &lt;code&gt;wc =&amp;lt;&amp;lt; getLine&lt;/code&gt; do, as a program? How does it compute that &lt;code&gt;Int&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Conceptually, it all sort of “makes sense” if you look at it from a high level view. &lt;code&gt;getLine&lt;/code&gt; is an &lt;code&gt;IO String&lt;/code&gt; — a future &lt;code&gt;String&lt;/code&gt;. &lt;code&gt;wc&lt;/code&gt; takes a &lt;code&gt;String&lt;/code&gt; and returns a future &lt;code&gt;Int&lt;/code&gt;. If we “applied &lt;code&gt;wc&lt;/code&gt; to &lt;code&gt;getLine&lt;/code&gt;”, we would be applying &lt;code&gt;wc&lt;/code&gt; to that future &lt;code&gt;String&lt;/code&gt;, to get a future &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And so there we have it — we &lt;em&gt;don’t ever have to&lt;/em&gt; actually work “directly” with computed values &lt;code&gt;a&lt;/code&gt; that are received from IO. All we ever have to do is work with &lt;code&gt;IO a&lt;/code&gt;, and we can use &lt;em&gt;all of our normal functions&lt;/em&gt; on that &lt;code&gt;IO a&lt;/code&gt;, as if they were normal &lt;code&gt;a&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;In that way, we don’t have to be scared of working with “future computable values” — we can use all of our normal tools on them!&lt;/p&gt;
&lt;h2 id=&quot;even-more&quot;&gt;Even more&lt;/h2&gt;
&lt;p&gt;There are lots of other worlds besides just &lt;code&gt;Maybe&lt;/code&gt;, &lt;code&gt;Reader r&lt;/code&gt;, and &lt;code&gt;IO&lt;/code&gt;. Each one comes with their own unique semantics/meanings/contexts, and their own answer for what &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; are supposed to “mean”.&lt;/p&gt;
&lt;p&gt;Here are some others — with brief descriptions.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;The world of &lt;code&gt;Either e&lt;/code&gt;, which is like &lt;code&gt;Maybe&lt;/code&gt; in which things may or may not be there. But in &lt;code&gt;Either e&lt;/code&gt;, when things aren’t there, they come with a reason why they are not (of type &lt;code&gt;e&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The world of &lt;code&gt;[]&lt;/code&gt;, where things are the results of computations that have ambiguous answers. I wrote a &lt;a href=&quot;http://blog.jle.im/entries/series/+monadplus-success-failure-monads&quot;&gt;series of posts&lt;/a&gt; on this :)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The world of &lt;code&gt;State s&lt;/code&gt;, which is a world of future things awaiting an &lt;code&gt;s&lt;/code&gt;, which modify the &lt;code&gt;s&lt;/code&gt; in the process.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The world of &lt;code&gt;Parser&lt;/code&gt;, which is a world of things that an input string will be parsed into.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are many more! The great thing about Haskell is that with &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, it is easy to work with values inside these worlds with all of your normal functions, without any real extra effort. Normal functions, normal values, values inside worlds…we have them all at our disposal.&lt;/p&gt;
&lt;p&gt;Haskell lets me stay &lt;em&gt;inside my world&lt;/em&gt;!&lt;/p&gt;
&lt;h2 id=&quot;final-notes&quot;&gt;Final Notes&lt;/h2&gt;
&lt;p&gt;For some further reading, Gabriel Gonzalez’s &lt;a href=&quot;http://www.haskellforall.com/2012/09/the-functor-design-pattern.html&quot;&gt;“Functor Design Pattern”&lt;/a&gt; post covers a similar concept for people more familiar with Haskell and explains it more elegantly than I ever could have.&lt;/p&gt;
&lt;p&gt;Don’t forget as you’re reading and moving on that it’s not correct to say “Functors are worlds”, or “Monads are worlds”. As I mentioned before in an aside, Monads aren’t “anything” other than the functions and the laws. Rather, if we look at &lt;code&gt;Maybe&lt;/code&gt;, etc. as a “world”, then &lt;em&gt;having a Monad interface/instance&lt;/em&gt; allows us to do cool things with that world.&lt;/p&gt;
&lt;p&gt;Feel free to again &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples/inside&quot;&gt;play around with&lt;/a&gt; the code used here and load it in ghci yourself!&lt;/p&gt;
&lt;p&gt;Experienced readers might have noted an unconventional omission of “Applicative Functors”, which (since 2008-ish) traditionally goes somewhere in between the section on Functor and the section on Monad. Applicative Functors, in this context, are handy in that they let you combine two values in worlds together; that is, if you have a &lt;code&gt;Maybe a&lt;/code&gt; and a &lt;code&gt;Maybe b&lt;/code&gt;, it allows you to use an &lt;code&gt;a -&amp;gt; b -&amp;gt; c&lt;/code&gt; to “squash” them into a &lt;code&gt;Maybe c&lt;/code&gt;. For the nuances of this, check out a great &lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot;&gt;tutorial by adit&lt;/a&gt; that explains the Applicative typeclass well; you should easily be able to connect Applicative Functors to the concepts discussed in this post and see how they are useful :)&lt;/p&gt;
&lt;p&gt;As always, if you have any questions, leave them in the comments, or come find me on freenode’s #haskell — I go by &lt;em&gt;jle`&lt;/em&gt; :)&lt;/p&gt;
&lt;p&gt;(Special thanks to c_wraith and rhaps0dy for their time reviewing this post)&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Dun dun dun!&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;In the standard libraries, &lt;code&gt;certaintify&lt;/code&gt; and &lt;code&gt;certaintifyWithDefault&lt;/code&gt; exist in the &lt;code&gt;Data.Maybe&lt;/code&gt; module as &lt;code&gt;fromJust&lt;/code&gt; and &lt;code&gt;fromMaybe&lt;/code&gt;, respectively.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn3&quot;&gt;&lt;p&gt;It also needs &lt;code&gt;return&lt;/code&gt;, which I will mention in due time.&lt;a href=&quot;#fnref3&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn4&quot;&gt;&lt;p&gt;I know! And I’m not telling! Just kidding.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; is actually a lot of times more useful than &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, despite its awkward reversed nature.&lt;/p&gt;
&lt;p&gt;One major reason is that things end up looking more “imperative” (which may or may not be desired). Imagine &lt;code&gt;divideMaybe 12 3 &amp;gt;&amp;gt;= halveMaybe &amp;gt;&amp;gt;= halveMaybe&lt;/code&gt; versus &lt;code&gt;halveMaybe =&amp;lt;&amp;lt; halveMaybe =&amp;lt;&amp;lt; divideMaybe 12 3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Believe it or not, usage of Monads was originally motivated by structuring IO actions. So, in that setting, it seemed natural to have an “imperative-y” feel.&lt;/p&gt;
&lt;p&gt;Also, in the popular “do notation” syntactical sugar, &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; is used in the desugaring and not &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, so &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; pops out naturally when reasoning about Monads coming through do notation.&lt;/p&gt;
&lt;p&gt;Also, whenever you use lambda syntax (like &lt;code&gt;(\x -&amp;gt; f x)&lt;/code&gt;), &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; might be nice, because lambda syntax carries some sort of inherent left-to-rightness in it with the arrow. It’s also tricky to write “chained binds” using lambda syntax using &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; — try writing &lt;code&gt;f &amp;gt;&amp;gt;= (\x -&amp;gt; g &amp;gt;&amp;gt;= (\y -&amp;gt; h x y))&lt;/code&gt; using &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; and you’ll see that it’s slightly less natural.&lt;/p&gt;
&lt;p&gt;Still, it is worth being aware that &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; is a is a bit “different” from the rest of the pack of normal Haskell function application and composition operators; it is unique in that it is the only one where the backwards form is more common than the normal one.&lt;/p&gt;
&lt;p&gt;Even the term “bind” is often used to refer to both.&lt;/p&gt;
&lt;p&gt;A general guideline is that you ever mix a bind with a &lt;code&gt;(&amp;lt;$&amp;gt;)&lt;/code&gt; and/or a &lt;code&gt;($)&lt;/code&gt; and &lt;code&gt;(.)&lt;/code&gt;, you should prefer &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;, to prevent your eyes from jumping directions.&lt;a href=&quot;#fnref4&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn5&quot;&gt;&lt;p&gt;In Haskell, “worlds” are represented at the type level as type constructors. &lt;code&gt;Maybe&lt;/code&gt; is a type constructor that takes a type like &lt;code&gt;Int&lt;/code&gt; and returns a new type, &lt;code&gt;Maybe Int&lt;/code&gt;. Not all type constructors represent Worlds, of course.&lt;a href=&quot;#fnref5&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn6&quot;&gt;&lt;p&gt;An important distinction between &lt;code&gt;IO&lt;/code&gt; and the other worlds we have looked at is that there is no way to “exit” the world of &lt;code&gt;IO&lt;/code&gt; within Haskell. That is, there is no meaningful &lt;code&gt;IO a -&amp;gt; a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you think about it for a while, it kind of makes sense. If &lt;code&gt;IO a&lt;/code&gt; is assembly code for a computer…the only thing that can “get” that &lt;code&gt;a&lt;/code&gt; is the computer itself — by shifting those registers, ticking that program clock, reading from IO…&lt;/p&gt;
&lt;p&gt;Remember, &lt;em&gt;a Haskell program can only “evaluate”&lt;/em&gt; expressions, &lt;em&gt;not “execute”&lt;/em&gt; them. The execution is the computer’s job. When you compile a Haskell program, the compiler takes whatever &lt;code&gt;IO ()&lt;/code&gt; is named &lt;code&gt;main&lt;/code&gt; in your program, &lt;em&gt;evaluates&lt;/em&gt; it, and compiles it into a binary. Then you, the computer user, can &lt;em&gt;execute&lt;/em&gt; that binary like any other binary (compiled from C or whatever). Because you can never “exit” &lt;code&gt;IO&lt;/code&gt; in your Haskell code, this makes &lt;code&gt;IO&lt;/code&gt; an extreme version of the worlds we mentioned before; in the others, we could “exit” the world if we really wanted to. We only used &lt;code&gt;fmap&lt;/code&gt; and &lt;code&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt; because it provided for beautiful abstractions. This topic is discussed in depth at an &lt;a href=&quot;http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity&quot;&gt;old blog post&lt;/a&gt; of mine.&lt;/p&gt;
&lt;p&gt;Because of this, if it weren’t for Functor and Monad, it would be extremely hard to do &lt;em&gt;anything&lt;/em&gt; useful with &lt;code&gt;IO&lt;/code&gt;! We literally can’t pass an &lt;code&gt;IO a&lt;/code&gt; into &lt;em&gt;any&lt;/em&gt; normal function. We need Functor and Monad for us to &lt;em&gt;ever&lt;/em&gt; work at all with our “future values” with normal functions!&lt;a href=&quot;#fnref6&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/inside-my-world-ode-to-functor-and-monad.html</guid><pubDate>Mon, 19 May 2014 17:46:22 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2014-05-19</dc:date></item><item><title>Blog engine updates: Markdown Preprocessor &amp; Fay Scripts</title><link>http://home.jle0.com:4111/entry/blog-engine-updates-markdown-preprocessor-fay-scripts.html</link><description>&lt;p&gt;I spent some time over the past week writing a preprocessor for the entry copy markdowns and getting Fay to deploy some simple scripts.&lt;/p&gt;
&lt;p&gt;The need for a preprocessor was sparked by a post I’m writing that sort of necessitated the features. I write &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/copy/entries&quot;&gt;all of my posts&lt;/a&gt; in markdown, and it all integrated well with the preprocessor. In addition I needed some javascript scripting to make the preprocessor actions worthwhile, so I buckled down and wrestled with getting Fay to work in a production environment. So I guess this post is to show off some new features of the blog engine?&lt;/p&gt;
&lt;p&gt;Here it is in action:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; !!!monad-plus/WolfGoatCabbage.hs &amp;quot;makeMove ::&amp;quot; &amp;quot;moveLegal ::&amp;quot; wolf-goat-cabbage&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yields:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/monad-plus/WolfGoatCabbage.hs#L37-58&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/wolf-goat-cabbage&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;makeMove ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]
makeMove p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    next &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]
    guard       &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; moveLegal p next
    guard &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; not &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; moveRedundant p next
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;
        p&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; p &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [next]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; safePlan p&amp;#39;
    return p&amp;#39;

&lt;span class=&quot;ot&quot;&gt;moveLegal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
moveLegal p (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
moveLegal p (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; c)       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; positionOf p c &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Mouse over or click them to see the full effect :) )&lt;/p&gt;
&lt;h2 id=&quot;code-quotinglinking-preprocessor&quot;&gt;Code quoting/linking preprocessor&lt;/h2&gt;
&lt;p&gt;So I find myself writing a lot of sample code for my posts, and then later copying and pasting them over to the &lt;a href=&quot;https://github.com/mstksg/inCode/tree/master/code-samples&quot;&gt;code-samples&lt;/a&gt; directory on the github in order to allow people to download them…and then later awkwardly putting a link saying “download these here!” afterwards and taking up space. Also linking to a live &lt;a href=&quot;https://www.fpcomplete.com/&quot;&gt;FPComplete&lt;/a&gt; version is a bit awkward too, right after the block.&lt;/p&gt;
&lt;p&gt;I was rather inspired by the interface on the code blocks for &lt;a href=&quot;http://weblog.luite.com/wordpress/?p=127&quot;&gt;luite’s blog&lt;/a&gt;, where every relevant code block has a little link box on the top right hand corner linking to the source and a working/running example.&lt;/p&gt;
&lt;p&gt;So I wrote a Haskell preprocessor to take in a specification of a code file and a what blocks in the code file to load, and then load it into the markdown file before it is processed by pandoc.&lt;/p&gt;
&lt;p&gt;The syntax is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; !!!path/to/code &amp;quot;keyword&amp;quot; &amp;quot;limited&amp;quot;n live_link&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where “keyword” is the text in the line to match for, &lt;code&gt;n&lt;/code&gt; is the number of lines after the keyword to display (if left off, it takes the next “block”, or the next continuous piece of code before a new non-indented line), and &lt;code&gt;live_link&lt;/code&gt; is a link to the live/interactive version on FPComplete.&lt;/p&gt;
&lt;h3 id=&quot;reflections&quot;&gt;Reflections&lt;/h3&gt;
&lt;p&gt;So…writing the parser for the syntax specification was pretty easy due to parsec and parser combinators:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/source/EntryPP.hs#L32-127&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SampleSpec&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SampleSpec&lt;/span&gt;  {&lt;span class=&quot;ot&quot;&gt; sSpecFile       ::&lt;/span&gt; FilePath
                              ,&lt;span class=&quot;ot&quot;&gt; _sSpecLive      ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
                              ,&lt;span class=&quot;ot&quot;&gt; _sSpecKeywords  ::&lt;/span&gt; [(&lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;)]
                              } &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;)

&lt;span class=&quot;ot&quot;&gt;sampleSpec ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SampleSpec&lt;/span&gt;
sampleSpec &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    filePath &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; noSpaces &lt;span class=&quot;fu&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;sample filePath&amp;quot;&lt;/span&gt;
    spaces
    keywords &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; many &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      keyword &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; char &lt;span class=&quot;ch&quot;&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;*&amp;gt;&lt;/span&gt; manyTill anyChar (char &lt;span class=&quot;ch&quot;&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;keyword&amp;quot;&lt;/span&gt;
      keylimit &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; optionMaybe (read &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; many1 digit &lt;span class=&quot;fu&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;keyword limit&amp;quot;&lt;/span&gt;)
      spaces
      return (keyword,keylimit)

    live &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; optionMaybe noSpaces &lt;span class=&quot;fu&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;live url&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;
      live&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mfilter (not &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; null) live

    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;SampleSpec&lt;/span&gt; filePath live&amp;#39; keywords
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    noSpaces &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; manyTill anyChar (space &lt;span class=&quot;fu&quot;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&quot;ch&quot;&gt;&amp;#39; &amp;#39;&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&lt;/span&gt; eof)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code to actually find the right code block to paste was complicated and horrifying at first, but after I sat down and really sorted out the logic, it wasn’t too bad. Still, it isn’t the cleanest code in the world and I wonder how I could have made it better, either with a Haskell library or even another language.&lt;/p&gt;
&lt;p&gt;This all left two little comment lines before the source code insert with the link to the source and interactive versions.&lt;/p&gt;
&lt;p&gt;All that was left was a front-end script to get the comments and turn them into floating divs.&lt;/p&gt;
&lt;h2 id=&quot;fay&quot;&gt;Fay&lt;/h2&gt;
&lt;p&gt;Ah okay, here was the fun part.&lt;/p&gt;
&lt;p&gt;Fay is actually pretty fun to use. And while it was perhaps complete overkill to use the entire Fay runtime and build system for just a simple script, but I was pretty inspired by &lt;a href=&quot;http://ocharles.org.uk/blog/posts/2013-12-23-24-days-of-hackage-fay.html&quot;&gt;ocharles’s post on fay&lt;/a&gt; and I thought this would be a good time to get to learn it.&lt;/p&gt;
&lt;p&gt;So there was a lot of cognitive friction going in, and trying to really get in the groove took a few days. There was also a rather unhelpful error message involving the ffi that I was able to bring up to the maintainers and be a part of getting the fix working.&lt;/p&gt;
&lt;p&gt;I converted as much of my current scripts as I could to fay. There was one that I couldn’t — a function call to a library that required a javascript object of function callbacks, and I couldn’t really get that to work cleanly and I decided it wasn’t worth the effort for now — maybe another day. If anything I could re-write the entire library (a Table of Contents generator) myself some day.&lt;/p&gt;
&lt;h3 id=&quot;reflections-1&quot;&gt;Reflections&lt;/h3&gt;
&lt;h4 id=&quot;fay-jquery&quot;&gt;fay-jquery&lt;/h4&gt;
&lt;p&gt;Here is a characteristic example of fay code with fay-jquery (0.6.0.2):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/source/entry.hs#L45-54&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;appendTopLinks ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fay&lt;/span&gt; ()
appendTopLinks &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
  mainContent &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select &lt;span class=&quot;st&quot;&gt;&amp;quot;.main-content&amp;quot;&lt;/span&gt;
  headings &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; childrenMatching &lt;span class=&quot;st&quot;&gt;&amp;quot;h2,h3,h4,h5&amp;quot;&lt;/span&gt; mainContent
  J.append topLink headings
  topLinks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select &lt;span class=&quot;st&quot;&gt;&amp;quot;.top-link&amp;quot;&lt;/span&gt;
  click (scrollTo &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;) topLinks
  return ()
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
    topLink &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;&amp;lt;a href=&amp;#39;#title&amp;#39; class=&amp;#39;top-link&amp;#39;&amp;gt;top&amp;lt;/a&amp;gt;&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, some of the method calls in fay-jquery seem a bit backwards…I keep on resisting the urge to write things like&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;container &lt;span class=&quot;ot&quot;&gt;`append`&lt;/span&gt; contained
container &lt;span class=&quot;ot&quot;&gt;`childrenMatching`&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;.contained&amp;quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which matches the JQuery calling model:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode javascript&quot;&gt;&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;container&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;append&lt;/span&gt;(contained)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;container&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&amp;#39;.contained&amp;#39;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But alas, the decision was made otherwise. I guess it is more Haskell-y to be able to play with partial application and do something like&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;
  appendIt &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; append container
&lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;
  appendIt contained1
  appendIt contained2
  appendIt contained3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So I guess that’s okay.&lt;/p&gt;
&lt;p&gt;However, something I was less understanding of was the ordering for event binding, which needed the handlers &lt;em&gt;before&lt;/em&gt; the object being binded.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/source/entry.hs#L112-119&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;processCodeBlocks ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Fay&lt;/span&gt; ()
processCodeBlocks &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
  blocks &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select &lt;span class=&quot;st&quot;&gt;&amp;quot;.main-content pre.sourceCode&amp;quot;&lt;/span&gt;
  flip each blocks &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \_ el &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    elJ &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; select el
    processBlock elJ
    return &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
  return ()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This one kind of bucks the convention that methods like &lt;code&gt;append&lt;/code&gt; maintain…and also needs those annoying &lt;code&gt;flips&lt;/code&gt; to have easy anonymous callbacks. I don’t want to have to name every little thing. Oh well. Maybe there is a good justification here? I just don’t see it. But then again, there is a reason why we have both &lt;code&gt;mapM&lt;/code&gt; and &lt;code&gt;forM&lt;/code&gt; in base.&lt;/p&gt;
&lt;h4 id=&quot;deploying-fay&quot;&gt;Deploying fay&lt;/h4&gt;
&lt;p&gt;Deploying fay ain’t all too bad. I &lt;a href=&quot;http://blog.jle.im/entry/deploying-medium-to-large-haskell-apps-to-heroku&quot;&gt;deploy binaries&lt;/a&gt;, however, so I was unable to ever process fay on my limited-access production server because it requires &lt;code&gt;ghc-pkg&lt;/code&gt; (installed under &lt;code&gt;/usr/local/bin&lt;/code&gt;) among other things…I probably could have gotten this to work, but I did not have the proper skills. You also need to provide the binaries and headers in &lt;code&gt;share&lt;/code&gt; for all of your fay libraries in order to use them when compiling to javascript. So while this isn’t so bad if you have the whole Haskell Platform and are compiling on your production server, I had to pre-compile my fay “binaries” before pushing…just like I have to pre-compile my regular binaries, interestingly enough.&lt;/p&gt;
&lt;p&gt;Of course, the fay javascript files were a bit larger than the normal javascript ones. Not too significantly, though, only about 80x. This actually puts them however at around the size of my image files (~100KB)…this is slightly worrisome, but I don’t really stress too much about one image, so I guess I shouldn’t stress too much about this either. Not ideal, but what else could I expect?&lt;/p&gt;
&lt;h2 id=&quot;future-stuff&quot;&gt;Future stuff&lt;/h2&gt;
&lt;p&gt;Hopefully I’m able to make &lt;a href=&quot;http://blog.jle.im/source/code-samples/source/entry_toc.js#L4-21&quot;&gt;that javascript call&lt;/a&gt; on fay one day, without having to rewrite the entire library in Fay (although it might be a fun exercise).&lt;/p&gt;
&lt;!-- ~~~javascript --&gt;
&lt;!-- !!!source/entry_toc.js &quot;#toc&quot;18 --&gt;
&lt;!-- ~~~ --&gt;
&lt;p&gt;If anyone knows how I can do this, I’d really appreciate any help!&lt;/p&gt;
&lt;p&gt;I’d also in the future like to make my preprocessor a bit more robust and take more languages. But…I probably wouldn’t do this until the need actually arises :)&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Meta</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/blog-engine-updates-markdown-preprocessor-fay-scripts.html</guid><pubDate>Mon, 27 Jan 2014 09:03:38 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Meta</dc:subject><dc:date>2014-01-27</dc:date></item><item><title>Code 2013</title><link>http://home.jle0.com:4111/entry/code-2013.html</link><description>&lt;p&gt;It’s a bit late, but, inspired by my own admittedly egregious &lt;a href=&quot;https://twitter.com/mstk/status/418179201091399680&quot;&gt;tweet&lt;/a&gt; in participation of the awesome &lt;a href=&quot;http://code2013.herokuapp.com/&quot;&gt;#code2013&lt;/a&gt; hashtag, here is a review of 2013 in terms of the programming languages I’ve worked on and a general wrap-up of the adventures that 2013 had to offer me. It was quite surely the most productive/adventurous year of programming of my entire life.&lt;/p&gt;
&lt;h2 id=&quot;scientific-computing&quot;&gt;Scientific Computing&lt;/h2&gt;
&lt;p&gt;This year was the year I began to take scientific computing seriously. I had already been using &lt;strong&gt;&lt;a href=&quot;http://www.wolfram.com/mathematica/&quot;&gt;Mathematica&lt;/a&gt;&lt;/strong&gt; for many years, for some basic modeling work on analytic and numeric systems. This year continued my studies; however, I also enrolled in a two-quarter class taught by the Physics department (my own field of study) at my university on scientific computing techniques and applications in the context of Computational Physics.&lt;/p&gt;
&lt;p&gt;However, this course would be relying heavily on parallel computing techniques as well as low-level compiled languages like C and Fortran, with simulations that would have decently long executing times.&lt;/p&gt;
&lt;h3 id=&quot;linux&quot;&gt;Linux&lt;/h3&gt;
&lt;p&gt;I quickly realized that I could not do very much with my little Windows laptop, so I procured for the first time in my life a persistent server. I used the lowest tier from &lt;a href=&quot;http://www.togglebox.com/&quot;&gt;ToggleBox&lt;/a&gt;, a great cloud hosting service that gave me a year free. This was my return to unix-based systems after a break of several years, and in doing this I sort of went crazy again writing several &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_(Unix_shell)&quot;&gt;Bash&lt;/a&gt;&lt;/strong&gt; scripts that I am continuing to &lt;a href=&quot;http://blog.jle.im/entry/log-sh-lightweight-command-line-note-logging&quot;&gt;open-source&lt;/a&gt;/publish today; many of my scripts revolved around the &lt;a href=&quot;http://todotxt.com/&quot;&gt;todo.txt&lt;/a&gt; framework.&lt;/p&gt;
&lt;p&gt;I did some work on parsing some of my custom journal entry files and things like that, and with this I returned to using &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Awk&quot;&gt;awk&lt;/a&gt;&lt;/strong&gt;, which I had worked with a few years ago for processing logs. I rather really liked the language and it seemed like a very perfectly adapted DSL. There are many problems that are solved most easily in awk and I have a lot of respect for the language.&lt;/p&gt;
&lt;h3 id=&quot;vim&quot;&gt;Vim&lt;/h3&gt;
&lt;p&gt;Also this year was the year I decided to begin taking vi/&lt;a href=&quot;http://www.vim.org/&quot;&gt;vim&lt;/a&gt; seriously. This is because I realized that I would be doing most of my coding through an ssh connection, so I needed to pick a good terminal editor. After a lot of research I settled on vim. I’ve been exclusively using vim for some time now and, while it has a lot of endearing flaws, I am happy with my choice. With a toolbelt of plugins and extensions as well as a firm grasp of the vanilla basics, vim has served me very well. I have even delved into some of my own personal plugin development in &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Vim_script&quot;&gt;vimscript&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;computation&quot;&gt;Computation&lt;/h3&gt;
&lt;p&gt;For the aforementioned course, we had the opportunity to use either C or Fortran. Because I had dabbled in C before and have worked in C-like languages all my life, I figured I would take the opportunity to learn a new language. So I learned &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Fortran&quot;&gt;Fortran&lt;/a&gt;&lt;/strong&gt; — specifically, F77. This decision ended up being a good one because many of the established numerical/computational libraries in Physics were written in the seventies, and almost all of them are in Fortran. This interoperability was very handy, and I was also able to dive into them and pick them apart.&lt;/p&gt;
&lt;p&gt;Upon further digging into Fortran I found that I actually really liked the semantics and syntax of the language. The language seemed to fit to the computational techniques and algorithms I was learning about like a glove, more so than with C or C++. Many things that felt awkward in C felt natural in Fortran, and the entire program execution model just seemed seamless and elegant.&lt;/p&gt;
&lt;p&gt;I still consider Fortran among my favorite imperative languages today.&lt;/p&gt;
&lt;p&gt;However, for group projects I was forced to work with &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C++&quot;&gt;C++&lt;/a&gt;&lt;/strong&gt;, specifically with its &lt;a href=&quot;http://www.nvidia.com/object/cuda_home_new.html&quot;&gt;Cuda&lt;/a&gt; hooks, on a parallel N-body simulation. I came to appreciate the ad-hoc binary serialization of data structures that many languages I had been using in the past lacked.&lt;/p&gt;
&lt;p&gt;And here is the appropriate time to mention my work in &lt;strong&gt;&lt;a href=&quot;http://www.gnuplot.info/&quot;&gt;gnuplot&lt;/a&gt;&lt;/strong&gt; for the presentation of the data generated by these course projects&lt;/p&gt;
&lt;p&gt;In another course on numerical analysis, there was much usage also of &lt;strong&gt;&lt;a href=&quot;http://www.mathworks.com/products/matlab/&quot;&gt;Matlab&lt;/a&gt;&lt;/strong&gt;, if only to demonstrate certain theorems and techniques. In addition to this, for some of my lab courses, I did much of my data analysis and modeling/presentation in matlab.&lt;/p&gt;
&lt;h3 id=&quot;java&quot;&gt;Java&lt;/h3&gt;
&lt;p&gt;I also took a beginning &lt;strong&gt;&lt;a href=&quot;https://www.java.com/en/&quot;&gt;Java&lt;/a&gt;&lt;/strong&gt; course during my spring quarter. Mostly to fill in some requirements for my degree, I didn’t actually learn too much. This section is just to make this post complete :) My most recent large-ish work on Java was for a Machine Learning/Artificial Intelligence course the year before. No new insights from Java gleamed this year that I can post here…except that I can appreciate in a perverse way Java’s stubbornness to keep a consistent story of &lt;a href=&quot;http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html&quot;&gt;nouns&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;haskell&quot;&gt;Haskell&lt;/h2&gt;
&lt;p&gt;Around the end of winter I stumbled upon &lt;strong&gt;&lt;a href=&quot;http://www.haskell.org/haskellwiki/Haskell&quot;&gt;Haskell&lt;/a&gt;&lt;/strong&gt;. I am not completely sure how, actually. Perhaps it is just fate. But it is probably one of the more significant life-changing discoveries of my programming life. This event will define the rest of my entire year; it also inspired this blog itself. Haskell is a beautifully expressive functional, pure, non-strict language that merges serious and practical programming and powerful mathematics. Writing fully about my reflections on Haskell is beyond the scope of this post. However, if you don’t yet know Haskell, why don’t you give &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;Learn You A Haskell&lt;/a&gt; a quick read? :) You won’t regret it!&lt;/p&gt;
&lt;p&gt;I began with trying to implement my Fortran Monte Carlo programs in Haskell for my course. I wasn’t quite skilled enough to really use the full power of Haskell before my computation course ended, I was able to really simplify my programs and appreciate even a small part of the elegance of Haskell.&lt;/p&gt;
&lt;h3 id=&quot;blog&quot;&gt;Blog&lt;/h3&gt;
&lt;p&gt;Over the summer I delved back into web development by deciding that my next big Haskell project would be a blog engine. The result is this blog!&lt;/p&gt;
&lt;p&gt;Actually, I have noticed that, more than for other languages, having and maintaining a blog is a rite of passage and is sort or embedded into the culture of the Haskell community. I also noticed that a lot of the work I was doing was novel in the sense that I couldn’t find any real established literature; I had to forge a lot of the way myself. I wanted to be able to be able to give back to the community (which is, by the way, one of the best programming language communities I have found) and maybe jot down some of these struggles or observations.&lt;/p&gt;
&lt;p&gt;(This is probably also the best place to drop my usage of &lt;strong&gt;&lt;a href=&quot;http://www.graphviz.org/&quot;&gt;graphviz&lt;/a&gt;&lt;/strong&gt;’s &lt;em&gt;dot&lt;/em&gt; DSL for some diagrams for some blog posts. I like it a lot actually, and its declarative model is pretty useful.)&lt;/p&gt;
&lt;p&gt;(Oh yes I found myself learning and using some &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL&quot;&gt;SQL&lt;/a&gt;&lt;/strong&gt; for this if only to better understand how to write joins in &lt;a href=&quot;http://hackage.haskell.org/package/esqueleto&quot;&gt;Esqueleto&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;web-development&quot;&gt;Web Development&lt;/h2&gt;
&lt;p&gt;I made a couple of forays into Web Development this year. This blog was one, but there was very little front-end development work actually.&lt;/p&gt;
&lt;p&gt;I made some small toy projects on &lt;strong&gt;&lt;a href=&quot;https://www.ruby-lang.org/en/&quot;&gt;ruby&lt;/a&gt;&lt;/strong&gt; on my favorite framework, &lt;a href=&quot;http://www.sinatrarb.com/&quot;&gt;Sinatra&lt;/a&gt;. These are mostly just simple file server and organization apps and GUI front-ends for native compiled programs (simulations and the like). These all involved somewhat minimal front-end &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;javascript&lt;/a&gt;&lt;/strong&gt; and are styled with &lt;strong&gt;&lt;a href=&quot;http://sass-lang.com/&quot;&gt;sass&lt;/a&gt;&lt;/strong&gt;, a CSS pre-processor that I was at first hesitant to use but am not more or less completely dependent on. (Maybe that was the reason I was hesitant in the first place? Oh well!)&lt;/p&gt;
&lt;p&gt;I actually really enjoy ruby; before Haskell, it was my favorite language for many years and my go-to scripting and one-off language. I also tended to “think” in ruby whenever approaching programming problems. I’ll always have a sort of nostalgic attachment to ruby, and in many cases you can’t beat its expressiveness and utility as a scripting language right off the bat (something that it gains from its perl influences).&lt;/p&gt;
&lt;p&gt;Some time in the fall, &lt;a href=&quot;http://www.intuit.com/&quot;&gt;Intuit&lt;/a&gt; came to my university and hosted a Hackathon. My team ended up rapidly prototyping our app using ruby with the &lt;a href=&quot;http://rubyonrails.org/&quot;&gt;Rails&lt;/a&gt; framework. So this is my most recent web dev adventure. This was actaully my first time using Rails, despite having used ruby for many years. The experience was sort of disorienting, much magic. A lot felt very un-ruby. I guess I’ll be sticking with Sinatra for now :)&lt;/p&gt;
&lt;h2 id=&quot;engineering&quot;&gt;Engineering&lt;/h2&gt;
&lt;p&gt;I had a summer job working at a Physics lab doing control theory work in the field of electrical engineering. Much of it was in Matlab, especially with the visual “language” of &lt;strong&gt;&lt;a href=&quot;http://www.mathworks.com/products/simulink/&quot;&gt;Simulink&lt;/a&gt;&lt;/strong&gt;. I used &lt;strong&gt;&lt;a href=&quot;http://www.ni.com/labview/&quot;&gt;LabVIEW&lt;/a&gt;&lt;/strong&gt; extensively as well; I guess I didn’t count those in my tweet but they probably deserve more recognition than graphviz at least.&lt;/p&gt;
&lt;p&gt;Simulink is a pretty amazing simulation system and I understand that it is very effectively used in its industry fields. I was able to do a lot with its platform and ecosystem right out of the box that would have taken much time to shoddily replicate in another language. Its integration with Matlab (and compiled Matlab) makes it extremely powerful for a very wide range of control applications. Wow.&lt;/p&gt;
&lt;p&gt;I also worked a lot on the &lt;a href=&quot;http://arduino.cc/&quot;&gt;Arduino&lt;/a&gt; platform, using &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/C_(programming_language)&quot;&gt;C&lt;/a&gt;&lt;/strong&gt;. It was very nice to work with. This is before I really knew much about dynamic memory allocation, but the work I did (simple image processing and pattern recognition alongside startup procedures) did not require it.&lt;/p&gt;
&lt;h2 id=&quot;fall-courses&quot;&gt;Fall Courses&lt;/h2&gt;
&lt;h3 id=&quot;cc-course&quot;&gt;C/C++ Course&lt;/h3&gt;
&lt;p&gt;I took a data structures in C and C++ course in the fall. It was pleasant because while I had dabbled in both, I actually had very little formal education. I was able to formalize my understanding of pointer-based data structures (in C) and the syntax, language semantics, and language philosophy of C++, being able to structure someone more-than-toy projects. I consider this my first real exposure to formal C++ and manual dynamic memory management (without the use of a garbage collector), and I gained a lot from slowing down to figure this all out.&lt;/p&gt;
&lt;h3 id=&quot;comparative-programming-languages-course&quot;&gt;Comparative Programming Languages Course&lt;/h3&gt;
&lt;p&gt;And now the final chapter!&lt;/p&gt;
&lt;p&gt;In my fall quarter I took my university’s comparative programming languages course.&lt;/p&gt;
&lt;h4 id=&quot;ocaml&quot;&gt;OCaml&lt;/h4&gt;
&lt;p&gt;The first language we went into was &lt;strong&gt;&lt;a href=&quot;http://ocaml.org/&quot;&gt;OCaml&lt;/a&gt;&lt;/strong&gt;, a member of the (typically) functional, strict, impure ML family of languages. Learning it was a pleasant experience that helped me appreciate the advances in language development that lead to Haskell. I was able to more formalized what I liked and didn’t like about Haskell. I grew an appreciation for Haskell’s IO model; I also thought it was interesting that OCaml did not have the stubborn insistence on making type notation mirror data notation that Haskell does. The Haskell tuple &lt;code&gt;(Int, Int)&lt;/code&gt; is the OCaml tuple &lt;code&gt;int * int&lt;/code&gt;; the Haskell type application &lt;code&gt;Maybe Int&lt;/code&gt; is in OCaml &lt;code&gt;int maybe&lt;/code&gt;. It gets rid of a lot of the confusion cased by mixing up type constructors and data constructors in Haskell. But having the two be parallel does alow for some interesting reasoning, and it also allows us to deal with Kinds in the same way that we deal with Types.&lt;/p&gt;
&lt;p&gt;But I’m getting a bit ahead of myself! And I am going on a tangent. There are a lot of interesting differences between OCaml and Haskell :)&lt;/p&gt;
&lt;p&gt;The culmination of our work in OCaml was using ocamlyacc to write an interpreter of a simple subset of a functional language. It was a nice contrast to how in Haskell we typically write our own parsers using parser combinators instead of outsourcing to a “compiled” DSL.&lt;/p&gt;
&lt;h4 id=&quot;python&quot;&gt;Python&lt;/h4&gt;
&lt;p&gt;Our next language was python! I do not have many good things to say about this language :P I was always sort of a ruby fanboy. I have a long list of complaints about python from a language design standpoint. But I’m here to praise its benefits. The idiomatic usage of decorators was something interesting and very python-esque. The object/class model was interesting in contrast to Javascript, Ruby, Java/C#, etc. There, I was nice :)&lt;/p&gt;
&lt;h4 id=&quot;prolog&quot;&gt;Prolog&lt;/h4&gt;
&lt;p&gt;(&lt;a href=&quot;http://www.swi-prolog.org/&quot;&gt;SWI-&lt;/a&gt;)&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Prolog&quot;&gt;Prolog&lt;/a&gt;&lt;/strong&gt; was exciting to work with. I had a lot of fun with it. I’ll just put &lt;a href=&quot;http://c2.com/cgi/wiki?PrologLanguage&quot;&gt;this quote&lt;/a&gt; here:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I used Prolog in a comparative languages course. The biggest program we did was a map-coloring one (color a map with only four colors so that no bordering items have the same color, given a mapping of things that border each other). I say biggest because we were given the most time with it. I started out like most people in my class trying to hack the language into letting me code a stinking algorithm to color a stinking map. Then I wrote a test function to check if the map was colored and, in a flash of prolog, realized that that was really all I needed to code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Really though, the language was a nice joy. I talked to some people about bigger applications and I read up on a way to run a web server with Prolog. It was a little interesting but I felt like at some point the language model might start interfering with its usages, instead of in Haskell where the language model enhances much of its usage. Maybe that was just because I hadn’t tried it enough. Still, Prolog remains a great (domain specific?) language for solving constraint problems and logic problems. Perhaps I will give it more of a look some time in the future!&lt;/p&gt;
&lt;h2 id=&quot;in-review&quot;&gt;2013 in Review&lt;/h2&gt;
&lt;p&gt;Welp, that’s it! My observations on the languages I used this year, sort of patched together to tell the story of my programming adventures this year.&lt;/p&gt;
&lt;p&gt;What were some of your own adventures this year, in relation to new/old languages?&lt;/p&gt;</description><author>Justin Le</author><category>Ramblings</category><category>Personal</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/code-2013.html</guid><pubDate>Fri, 10 Jan 2014 04:17:58 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Ramblings, Personal</dc:subject><dc:date>2014-01-10</dc:date></item><item><title>Pre-processor Tests</title><link>http://home.jle0.com:4111/entry/preprocessor-tests.html</link><description>&lt;p&gt;Testing the entry pre-processor. It is supposed to expand out code blocks.&lt;/p&gt;
&lt;p&gt;Lorum ipsum blah blah.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/machines/Auto.hs#L116-135&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/wolf-goat-cabbage&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;onFor ::&lt;/span&gt; forall a&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;
     (a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;-- test to see if an input &amp;#39;triggers&amp;#39;&lt;/span&gt;
  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- amount of time to stay True for&lt;/span&gt;
  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;-- An Auto that takes an `a` and returns a `Bool`&lt;/span&gt;
onFor p hold &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; wait
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    wait ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;                 &lt;span class=&quot;co&quot;&gt;-- the &amp;quot;waiting&amp;quot; state&lt;/span&gt;
    wait &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \input &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p input                        &lt;span class=&quot;co&quot;&gt;-- if triggered,&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, countdown (hold&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;co&quot;&gt;-- jump to &amp;quot;countdown&amp;quot; state&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, wait)              &lt;span class=&quot;co&quot;&gt;-- otherwise, stay waiting&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;    countdown ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; a &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;-- the &amp;quot;countdown&amp;quot; state&lt;/span&gt;
    countdown n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \input &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; p input                        &lt;span class=&quot;co&quot;&gt;-- if re-triggered&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, countdown (hold&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)) &lt;span class=&quot;co&quot;&gt;-- countdown all over again&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; n &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt;, wait)          &lt;span class=&quot;co&quot;&gt;-- If counted down, go wait again&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;, countdown (n&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))  &lt;span class=&quot;co&quot;&gt;-- otherwise, count down.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/machines/Auto.hs#L137-137&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Command&lt;/span&gt; k v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Insert&lt;/span&gt; k v &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Lookup&lt;/span&gt; k &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Delete&lt;/span&gt; k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Command&lt;/span&gt; k v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Insert&lt;/span&gt; k v &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Lookup&lt;/span&gt; k &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Delete&lt;/span&gt; k&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- source: https://github.com/mstksg/blog/tree/develop/code-samples/machines/Auto.hs#L137-163&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;-- interactive: https://www.fpcomplete.com/user/jle/wolf-goat-cabbage&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Command&lt;/span&gt; k v &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Insert&lt;/span&gt; k v &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Lookup&lt;/span&gt; k &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Delete&lt;/span&gt; k

&lt;span class=&quot;ot&quot;&gt;autoMap ::&lt;/span&gt; forall k v&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Ord&lt;/span&gt; k
    &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;              &lt;span class=&quot;co&quot;&gt;-- the maximum capacity of the map&lt;/span&gt;
    &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Command&lt;/span&gt; k v) (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; v)
autoMap cap &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; go Map.empty
  &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    go ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Map.Map&lt;/span&gt; k v &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Auto&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Command&lt;/span&gt; k v) (&lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; v)
    go m &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;ACons&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; \command &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; command &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;Insert&lt;/span&gt; key val &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; Map.size m &lt;span class=&quot;fu&quot;&gt;&amp;gt;=&lt;/span&gt; cap &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; key &lt;span class=&quot;ot&quot;&gt;`Map.notMember`&lt;/span&gt; m
            &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
              ( &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, go m )                 &lt;span class=&quot;co&quot;&gt;-- Map is full, no go!&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; m&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; Map.insert key val m     &lt;span class=&quot;co&quot;&gt;-- go for it!&lt;/span&gt;
              &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ( &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; val, go m&amp;#39; )
        &lt;span class=&quot;dt&quot;&gt;Lookup&lt;/span&gt; key &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          ( key &lt;span class=&quot;ot&quot;&gt;`Map.lookup`&lt;/span&gt; m, go m )
        &lt;span class=&quot;dt&quot;&gt;Delete&lt;/span&gt; key &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt;
          &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; result  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; key &lt;span class=&quot;ot&quot;&gt;`Map.lookup`&lt;/span&gt; m
              m&amp;#39;      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; key &lt;span class=&quot;ot&quot;&gt;`Map.delete`&lt;/span&gt; m
          &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt;  ( result, go m&amp;#39; )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mstksg/blog/tree/develop/code-samples/machines/Auto.hs#L137-163&quot;&gt;Autos&lt;/a&gt;.&lt;/p&gt;
&lt;!-- ~~~haskell --&gt;
&lt;!-- !!!machines/Auto.hs --&gt;
&lt;!-- ~~~ --&gt;
&lt;!-- !!!*machines/Auto.hs &quot;autoMap ::&quot; --&gt;</description><author>Justin Le</author><category>Tests</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/preprocessor-tests.html</guid><pubDate>Thu, 23 Jan 2014 02:07:43 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Tests</dc:subject><dc:date>2014-01-23</dc:date></item><item><title>Practical Fun with Monads — Introducing: MonadPlus!</title><link>http://home.jle0.com:4111/entry/practical-fun-with-monads-introducing-monadplus.html</link><description>&lt;p&gt;Monads. Haskell’s famous for them, but they are one of the most ill-understood concepts to the public. They are mostly shrouded in mystery because of their association with how Haskell models I/O. This reputation is undeserved. Monads don’t have anything to do with I/O.&lt;/p&gt;
&lt;p&gt;This series is a part of a global effort to pull away the shroud of mystery behind monads and show that they are fun! And exciting! And really just a way of chaining together functions that allow for new ways of approaching puzzles.&lt;/p&gt;
&lt;p&gt;The first sub-series (chapter?) will be on a specific class/family of monads known as &lt;em&gt;MonadPlus&lt;/em&gt;. At the end of it all, we are going to be solving the classic logic puzzle, as old as time itself, using &lt;strong&gt;only&lt;/strong&gt; the List monad instance, and no loops, queues, or fancy stuff like that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can’t leave the wolf alone with the goat, or the wolf will eat the goat. He can’t leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let us enter a brave new world!&lt;/p&gt;
&lt;h3 id=&quot;a-quick-review-of-monads&quot;&gt;A quick review of monads&lt;/h3&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Note&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This article is written for both beginners — people who have a fuzzy idea of monads and a minimal understanding of functional programming principles, but who have some experience in Object-Oriented Programming in a language like Java or C++ — and intermediate Haskell users — people who have a somewhat firm grasp on monads, but want to know about monads on a broader context (in particular, the MonadPlus typeclass).&lt;/p&gt;
&lt;p&gt;Intermediate Haskell users will most likely find this post to be review, and I’ll put a link in this paragraph when the next part is up so we can get to “real” Haskelling. However, this post might be beneficial if you read it while asking, at every point, “How can this be abstracted and generalized?”. It’s a fun exercise!&lt;/p&gt;
&lt;p&gt;This article attempts to explain all Haskell syntax that might be foreign to beginners. That being said, if you ever run into anything you can’t understand, feel free to either read the articles above, give &lt;a href=&quot;http://learnyouahaskell.com/&quot;&gt;Learn You A Haskell&lt;/a&gt; a quick read (you won’t regret it!), or leave a comment — I’d love to answer your questions or hear your responses!&lt;/p&gt;
This first post will cover the basics of MonadPlus with the simplest MonadPlus of all; the second part will explore the List MonadPlus, and the third will finally tackle the Wolf/Goat/Cabbage puzzle with our combined knowledge.
&lt;/aside&gt;
&lt;p&gt;Okay, so as a Haskell blogger, I’m actually not allowed to write any monad tutorials. Luckily for you, however, I don’t need too — there are a wealth of great ones. &lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot;&gt;Adit provides a great concise one&lt;/a&gt;, and, if you want, &lt;a href=&quot;http://www.haskell.org/haskellwiki/All_About_Monads&quot;&gt;a more in depth one&lt;/a&gt; is on the haskell.org wiki about all sorts of monads and using them in real life.&lt;/p&gt;
&lt;p&gt;Remember — different monads do not actually have any non-superficial relationship to one another. When we say monads, we just mean objects for which we have defined a way to chain together functions “inside” wrappers, containers, or contexts.&lt;/p&gt;
&lt;h2 id=&quot;maybe-maybe-not&quot;&gt;Maybe, maybe not&lt;/h2&gt;
&lt;p&gt;Monads are very useful when you are dealing with objects that are containers. Let’s look at the most obvious container – a &lt;code&gt;Maybe a&lt;/code&gt;. A &lt;code&gt;Maybe a&lt;/code&gt; is a container that can either be &lt;code&gt;Just x&lt;/code&gt; (representing a successful result &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt;) or a &lt;code&gt;Nothing&lt;/code&gt; (representing a failed result).&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hi! These “Welcome to Haskell” asides are going to be for you readers that are unfamiliar with Haskell syntax. Feel free to ignore them if you already feel comfortable.&lt;/p&gt;
Anyways, if you’ve ever done any object-oriented programming, you might be able to think of &lt;code&gt;Maybe a&lt;/code&gt; as an abstract/virtual superclass with templates/generics — &lt;code&gt;Maybe&amp;lt;a&amp;gt;&lt;/code&gt;, kinda. And that superclass has two subclasses: &lt;code&gt;Just&amp;lt;a&amp;gt;&lt;/code&gt;, which has one public instance variable &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;Nothing&lt;/code&gt;, which contains no instance variables.
&lt;/aside&gt;
&lt;p&gt;Often times you’ll have functions that fail, and you want to chain them. The easiest way is that any function that is chained onto a failed value will be skipped; a failure is the final result.&lt;/p&gt;
&lt;p&gt;Consider the &lt;code&gt;halve&lt;/code&gt; function, which returns &lt;code&gt;Just (x `div` 2)&lt;/code&gt; on a successful halving, or &lt;code&gt;Nothing&lt;/code&gt; on an unsuccessful halving:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halve ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;                       &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
halve x &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; even x    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; (x &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)          &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                   &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hi again! There are some quick syntax features here.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;This first line declares that the type of the function &lt;code&gt;halve&lt;/code&gt; is &lt;code&gt;Int -&amp;gt; Maybe Int&lt;/code&gt;, which means that it takes in an &lt;code&gt;Int&lt;/code&gt; and returns a &lt;code&gt;Maybe Int&lt;/code&gt; — an integer wrapped in a “Maybe” container.&lt;/li&gt;
&lt;li&gt;This says that if x is even, then return a successful &lt;code&gt;Just (x `div` 2)&lt;/code&gt;. &lt;code&gt;x `div` 2&lt;/code&gt; is x divided by two, in case you couldn’t guess already.&lt;/li&gt;
&lt;li&gt;Otherwise, return &lt;code&gt;Nothing&lt;/code&gt; — a failure.&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;p&gt;Because Maybe comes built-in as a monad, we can now chain &lt;code&gt;halve&lt;/code&gt;s on results of other &lt;code&gt;halves&lt;/code&gt;, and have any failures automatically propagate to the end and short circuit your entire computation:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                         &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                         &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                         &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can play with this yourself by &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/Halve.hs&quot;&gt;loading up the function yourself&lt;/a&gt;.&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
In this article, code that begins with &lt;code&gt;λ:&lt;/code&gt; represents commands to be entered at the interactive prompt, ghci. Code that doesn’t is actual source code.
&lt;/aside&gt;
&lt;p&gt;Remember, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; means “use the results of the last thing to calculate this next thing” — it “chains” the functions.&lt;/p&gt;
&lt;p&gt;How does this work, exactly? That’s not really in the scope of this article (any monad tutorial will explain this in more detail). But here are some interesting points:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Note that this command doesn’t even bother with the second &lt;code&gt;halve&lt;/code&gt;. It knows that the end result will be &lt;code&gt;Nothing&lt;/code&gt; no matter what (because &lt;code&gt;halve 7&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt;), so it just skips right past the second &lt;code&gt;halve&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; is a special variation of &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; says “take the result of the last thing and use it on this”, while &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; says “ignore the result of the last thing and always return this”. So &lt;code&gt;&amp;gt;&amp;gt; Nothing&lt;/code&gt; means “I don’t care what the last thing succeeded with, I’m going to fail right here.”&lt;/li&gt;
&lt;li&gt;Disastrous! Even though halving 32 four times usually is fine (giving &lt;code&gt;Just 2&lt;/code&gt;), having just one failure along the way means that the entire thing is a failure. &lt;code&gt;halve 32 &amp;gt;&amp;gt; Nothing&lt;/code&gt; is &lt;code&gt;Nothing&lt;/code&gt;, so the whole thing is just &lt;code&gt;(Nothing) &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve &amp;gt;&amp;gt;= halve&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can think of this failing phenomenon like this: At every step, Haskell attempts to apply &lt;code&gt;halve&lt;/code&gt; to the result of the previous step. However, you can’t &lt;code&gt;halve&lt;/code&gt; a &lt;code&gt;Nothing&lt;/code&gt; because a &lt;code&gt;Nothing&lt;/code&gt; has no value to halve!&lt;/p&gt;
&lt;h3 id=&quot;do-notation&quot;&gt;Do notation&lt;/h3&gt;
&lt;p&gt;Haskell provides a convenient way of writing chained &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;’s called do notation; here are a few samples matched with their equivalent &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; form:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; half &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     half &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;

λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     halve x
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;

λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve x
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve y
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     halve z
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;

λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve x
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve y
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     halve z
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this notation, &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;’s do not contain the &lt;code&gt;Just&lt;/code&gt;/&lt;code&gt;Nothing&lt;/code&gt;’s — they represent the actual &lt;strong&gt;Ints inside them&lt;/strong&gt;, so we can so something like &lt;code&gt;halve x&lt;/code&gt; (where &lt;code&gt;halve&lt;/code&gt; only takes Ints, not &lt;code&gt;Maybe Int&lt;/code&gt;’s)&lt;/p&gt;
&lt;p&gt;It kind of feels very imperative-y — “do &lt;code&gt;halve 32&lt;/code&gt; and assign the result (16) to &lt;code&gt;x&lt;/code&gt;…do &lt;code&gt;halve x&lt;/code&gt; and assign the result (8) to &lt;code&gt;y&lt;/code&gt;…” — but remember, it’s still just a bunch of chained &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;s in the end.&lt;/p&gt;
&lt;h2 id=&quot;failure-is-an-option&quot;&gt;Failure is an option&lt;/h2&gt;
&lt;p&gt;The important thing to note here is that “do” notation basically builds up one “giant” object. Remember the last two examples — the second to last one, all of those lines were in an effort to build one giant &lt;code&gt;Just 2&lt;/code&gt; value. In the last example, all of those lines were in an effort to build one giant &lt;code&gt;Nothing&lt;/code&gt; value. That’s why one &lt;code&gt;Nothing&lt;/code&gt; “ruined” the whole thing. The entire computation is one big &lt;code&gt;Maybe a&lt;/code&gt;. If at any point in your attempt to build that &lt;code&gt;Maybe a&lt;/code&gt;, you fail, then you have &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, remember, saying “x is a monad” just means “we have defined a way of chaining functions/operations on x”. Just like how we can now chain multiple functions that return Maybe’s (that don’t take Maybe’s as input). However, given any object, there is probably more than one way to meaningfully define this “chaining”.&lt;/p&gt;
&lt;p&gt;Sometimes, it’s useful to base your definition of chaining on the idea of a failure/success process. Sometimes it’s useful to define chaining as “We are building up either a success or a failure…and if at any point I fail, the whole thing is a failure”.&lt;/p&gt;
&lt;p&gt;There is a special name for this design pattern. In Haskell, we call something like this a “&lt;a href=&quot;http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus&quot;&gt;MonadPlus&lt;/a&gt;”&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I know, it’s an embarrassingly bad name, and it’s like this is for historical reasons (related to the footnote above). The name doesn’t even hint at a fail/succeedness. But we’re stuck with it for pretty much the entire foreseeable future, so when you chose to adopt a success/failure model for your chaining process, you have a &lt;em&gt;MonadPlus&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;There is a vocabulary we can use so we can talk about all MonadPlus’s in a general way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We call a success a “return”. Yeah…the name is super confusing because of how the word “return” is used in almost every other context in computer science. But hey. Oh well.&lt;/li&gt;
&lt;li&gt;We call a failure an “mzero”. Yes, this name is pretty lame too.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For Maybe, a “return” with the value &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;Just x&lt;/code&gt;, and an “mzero” is a &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Something cool about Haskell is that if we type &lt;code&gt;return x&lt;/code&gt;, it’ll interpret it as an auto-success of value &lt;code&gt;x&lt;/code&gt;. If we type &lt;code&gt;mzero&lt;/code&gt;, it’ll be an “alias” of whatever your failure is.&lt;/p&gt;
&lt;p&gt;That means that for Maybe, &lt;code&gt;return x&lt;/code&gt; is the same as &lt;code&gt;Just x&lt;/code&gt;, and &lt;code&gt;mzero&lt;/code&gt; is an alias for &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are familiar with object oriented languages like Java, MonadPlus is really like an &lt;strong&gt;interface&lt;/strong&gt;. That is, if something is a MonadPlus, there is a “guarantee” that that something will implement/define &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; for that particular object. In this way, &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; are &lt;em&gt;polymorphic functions&lt;/em&gt; that change their behavior based on what type you are talking about, and you can write code that works with all MonadPlus’s generically without worrying about their actual type by using only &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; (instead of say, &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Nothing&lt;/code&gt;).&lt;/p&gt;
In Haskell, the term we use (instead of “interface”) is “&lt;strong&gt;typeclass&lt;/strong&gt;”. There are some subtle differences — typeclasses are in general more powerful of a tool than interfaces — but the two concepts provide similar roles in their respective languages.
&lt;/aside&gt;
&lt;p&gt;As a small note, the term/command “return”/&lt;code&gt;return&lt;/code&gt; is shared by all monads. However, monads don’t ascribe any (general) conceptual “meaning” or “purpose” to return. For any old monad, it can mean whatever you want it to mean for that specific monad. However, in the context of MonadPlus, “return” has a very specific meaning: &lt;em&gt;succeed&lt;/em&gt;. Because of this, “return” and “succeed” will be treated as synonyms in this article.&lt;/p&gt;
&lt;h3 id=&quot;monadplus-examples&quot;&gt;MonadPlus examples&lt;/h3&gt;
&lt;p&gt;To see this in action, let’s revisit the last do block and make it more generic, and just rephrase it in a form that we are going to be encountering more when we solve our problem with the List monad (which is (spoilers) also a MonadPlus):&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halveThriceOops ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halveThriceOops n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;          &lt;span class=&quot;co&quot;&gt;-- call with n = 32&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve n                &lt;span class=&quot;co&quot;&gt;-- Just 16              -- 1&lt;/span&gt;
    mzero                       &lt;span class=&quot;co&quot;&gt;-- Nothing              -- 2&lt;/span&gt;
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve x                &lt;span class=&quot;co&quot;&gt;-- (skip)               -- 3&lt;/span&gt;
    z &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve y                &lt;span class=&quot;co&quot;&gt;-- (skip)&lt;/span&gt;
    return z                    &lt;span class=&quot;co&quot;&gt;-- (skip)               -- 4&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I’ve also included a line-by-line ‘trace’ of the do block with what the monad “is” at that point. It is what is calculated on that line, and it would be the value returned if you just exited at that step.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Business as usual. Halve &lt;code&gt;n&lt;/code&gt; if possible and place the reuslt in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is 32, then &lt;code&gt;x&lt;/code&gt; will be 16.&lt;/li&gt;
&lt;li&gt;The failure. Remember, &lt;code&gt;mzero&lt;/code&gt; means “fail here automatically”, which, in a Maybe object, means &lt;code&gt;Nothing&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Now from here on, nothing else even matters…the entire block is a failure!&lt;/li&gt;
&lt;li&gt;If possible, succeed with the value in &lt;code&gt;z&lt;/code&gt;. This is supposed to be a &lt;code&gt;Just&lt;/code&gt; with the value of &lt;code&gt;z&lt;/code&gt;. Unfortunately, the entire block failed a long time ago. So sad!&lt;/li&gt;
&lt;/ol&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Diversion&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A small diversion.&lt;/p&gt;
&lt;p&gt;This is a little nicety, but there is the common library monad function &lt;code&gt;sequence :: Monad m =&amp;gt; [m a] -&amp;gt; m [a]&lt;/code&gt;, which turns a &lt;code&gt;[Maybe a]&lt;/code&gt; into a &lt;code&gt;Maybe [a]&lt;/code&gt;. Conceptually, &lt;code&gt;sequence&lt;/code&gt; turns a list of monads into a monad containing a list.&lt;/p&gt;
&lt;p&gt;In the context of MonadPlus, it would be turning a list of Success/Failures into a succesful or failed list. It builds a succesful/failed list.&lt;/p&gt;
&lt;p&gt;From what we have learned, if any part of that building process is a failure, the entire thing is necessarily a failure. This is reflected in &lt;code&gt;sequence&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; sequence [&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; sequence [&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
If you already know a few other common library monad functions (like &lt;code&gt;replicateM&lt;/code&gt;, &lt;code&gt;forM&lt;/code&gt;, etc.), try reasoning about how they would work on Maybe’s and MonadPlus’s in general — they aren’t just for IO!
&lt;/aside&gt;
&lt;h3 id=&quot;guards&quot;&gt;Guards&lt;/h3&gt;
&lt;p&gt;It feels like just slapping in &lt;code&gt;mzero&lt;/code&gt; willy-nilly is not that useful, because then things just fail always no matter what. Wouldn’t it be handy to have a function that says “fail right…here, if this condition is not met”? Like &lt;code&gt;mzero&lt;/code&gt;, but instead of always failing, fails on certain conditions.&lt;/p&gt;
&lt;p&gt;Luckily, Haskell gives us one in the standard library:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;guard ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m ()        &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
guard &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; return ()
guard &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mzero&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;This is a type signature, like before. We say that &lt;code&gt;guard&lt;/code&gt; is a function that takes a &lt;code&gt;Bool&lt;/code&gt; and returns a &lt;code&gt;m ()&lt;/code&gt; — a monad containing &lt;code&gt;()&lt;/code&gt;. But we say that &lt;code&gt;m&lt;/code&gt;, the monad, must be a MonadPlus.&lt;/p&gt;
&lt;p&gt;For example, if we applied this to Maybe, the concrete signature would be &lt;code&gt;guard :: Bool -&amp;gt; Maybe ()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;p&gt;So &lt;code&gt;guard&lt;/code&gt; will make sure a condition is met, or else it fails the entire thing. If the condition is met, then it succeeds and places a &lt;code&gt;()&lt;/code&gt; in the value.&lt;/p&gt;
&lt;p&gt;We can use this to re-implement &lt;code&gt;halve&lt;/code&gt;, using do notation, aware of Maybe’s MonadPlus-ness:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halve ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halve n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;                &lt;span class=&quot;co&quot;&gt;-- &amp;lt;halve 8&amp;gt;   &amp;lt;halve 7&amp;gt;&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; even n          &lt;span class=&quot;co&quot;&gt;-- Just ()      Nothing&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;-- Just 4       (skip)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;guard $ even n&lt;/code&gt; seems confusing, but it is just shorthand for &lt;code&gt;guard (even n)&lt;/code&gt;. We just don’t like writing all those parentheses out.
&lt;/aside&gt;
&lt;p&gt;So, first, &lt;code&gt;halve&lt;/code&gt; is &lt;code&gt;Just ()&lt;/code&gt; (succeeds with a blank value &lt;code&gt;()&lt;/code&gt;) if &lt;code&gt;n&lt;/code&gt; is even, or else &lt;code&gt;Nothing&lt;/code&gt; (fails automatically) otherwise. Finally, if it has not yet failed, it attempts to succeed with &lt;code&gt;n `div` 2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can trust me when I say this works the exact same way! You can &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/HalveGuard.hs&quot;&gt;try it out yourself&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;As a friendly reminder, this entire block is “compiled”/desugared to:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;halve&lt;span class=&quot;ot&quot;&gt; n ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halve n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; guard (even n) &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; return (n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;a-practical-use&quot;&gt;A practical use&lt;/h2&gt;
&lt;p&gt;We aren’t where we need to be to begin tackling that Wolf/Goat/Cabbage puzzle yet…so to let this article not be a complete anticlimax (as a result of my bad planning — I had originally intended to do the entire three-part series as one article), let’s look at a practical problem that you can solve using the Maybe monad.&lt;/p&gt;
&lt;p&gt;The obvious examples are situations where it is useful to be able to chain failable operations such as retrieving things from a database or a network connection or applying partial functions (functions that only work on some values, like our &lt;code&gt;halve&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;However, here is a neat one.&lt;/p&gt;
&lt;p&gt;Let’s say we are making a game where you can lose health by being hit or gain health by picking up powerups. We want to calculate the final health at the end of the game. It seems a bit easy: just add up all the losses and gains! Unfortunately, it’s not so simple — it needs to be implemented such that if your health ever dips below 0, you are dead. Forever. No powerups will ever help you.&lt;/p&gt;
&lt;p&gt;Think about how you would implement this normally. You might have a state object that stores the current health as well as a flag with the current dead/alive state, and at every step, check if the health is 0 or lower; if it is, swap the flag to be dead and ignore all other updates.&lt;/p&gt;
&lt;p&gt;But let’s try doing this instead with the Maybe monad:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- die or fail immediately&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;die ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
die &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;                       &lt;span class=&quot;co&quot;&gt;-- or die = mzero&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- if not dead, sets the health to the given level&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;setHealth ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
setHealth n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; n                &lt;span class=&quot;co&quot;&gt;-- or setHealth n = return n&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- damage the player (from its previous health) and check for death&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hit ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
hit currHealth &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; newHealth &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; currHealth &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; newHealth &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- fail/die immediately unless newHealth&lt;/span&gt;
                                    &lt;span class=&quot;co&quot;&gt;--     is positive&lt;/span&gt;
    return newHealth                &lt;span class=&quot;co&quot;&gt;-- succeed with newHealth if not already&lt;/span&gt;
                                    &lt;span class=&quot;co&quot;&gt;--     dead&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- an alternative but identical definition of `hit`, using &amp;gt;&amp;gt;= and &amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;hit&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
hit&amp;#39; currHealth &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; guard (newHealth &lt;span class=&quot;fu&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; return newHealth
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        newHealth &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; currHealth &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;-- increase the player&amp;#39;s health from its previous health&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;powerup ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
powerup currHealth &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; currHealth &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; setHealth &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; hit &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; hit &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; setHealth &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; hit &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; hit &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; hit &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; setHealth &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; die &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; powerup
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h0 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; setHealth &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- Just 2&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h1 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; hit h0             &lt;span class=&quot;co&quot;&gt;-- Just 1&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h2 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; powerup h1         &lt;span class=&quot;co&quot;&gt;-- Just 2&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h3 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; hit h2             &lt;span class=&quot;co&quot;&gt;-- Just 1&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h4 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; hit h3             &lt;span class=&quot;co&quot;&gt;-- Nothing&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h5 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; powerup h4         &lt;span class=&quot;co&quot;&gt;-- (skip)&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     h6 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; powerup h5         &lt;span class=&quot;co&quot;&gt;-- (skip)&lt;/span&gt;
 &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt;     return h6                &lt;span class=&quot;co&quot;&gt;-- (skip)&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And voilà! &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/MaybeGame.hs&quot;&gt;Fire it up yourself&lt;/a&gt; if you want to test it out in person!&lt;/p&gt;
&lt;p&gt;You can think of the last do block conceptually this way: remember, &lt;code&gt;h3&lt;/code&gt; does not represent the &lt;code&gt;Just 1&lt;/code&gt; value — &lt;code&gt;h3&lt;/code&gt; represents the number &lt;em&gt;inside&lt;/em&gt; the &lt;code&gt;Just 1&lt;/code&gt; — the 1. So &lt;code&gt;h4&lt;/code&gt; is supposed to represent the number inside its value, too. But because &lt;code&gt;hit h3&lt;/code&gt; results in &lt;code&gt;Nothing&lt;/code&gt;; &lt;code&gt;Nothing&lt;/code&gt; has no value “inside”, so &lt;code&gt;h4&lt;/code&gt; doesn’t even have a value! So obviously it doesn’t even make sense to call &lt;code&gt;powerup h4&lt;/code&gt;…therefore &lt;code&gt;h5&lt;/code&gt; has no value either! It’s therefore meaningless to call &lt;code&gt;powerup h5&lt;/code&gt;, so meaningless to &lt;code&gt;return h6&lt;/code&gt;…the entire thing is a beautiful disaster. A fiasco. Mission accomplished!&lt;/p&gt;
&lt;p&gt;The whole thing works as expected; you can even die suddenly with &lt;code&gt;die&lt;/code&gt;, which ignores your current health.&lt;/p&gt;
&lt;p&gt;Interestingly enough, we could actually eliminate all references to Maybe altogether by always using &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; instead of &lt;code&gt;Just&lt;/code&gt; and &lt;code&gt;Nothing&lt;/code&gt;. And if we make our type signatures generic enough, we could use this with &lt;em&gt;any&lt;/em&gt; MonadPlus! But that is for another day.&lt;/p&gt;
&lt;h2 id=&quot;looking-forward&quot;&gt;Looking forward&lt;/h2&gt;
&lt;p&gt;Wow, who knew you could spend so much time talking about failure. Anyways, this is a good place to stop before we move onto how List is also a MonadPlus. Okay, so what have we learned?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Monads are just a way of chaining functions on objects, and of course, every object’s chaining process is different. In fact there might be even more than one way to meaningfully chain functions on an object!&lt;/li&gt;
&lt;li&gt;One useful “chaining approach” is to model things as success-failure chains, where you are building something from successes, but if you fail once in the process, the entire process fails. An object that uses this approach/design pattern is called a MonadPlus.&lt;/li&gt;
&lt;li&gt;The Maybe object is one such example. We can define ‘chaining’ failable functions as functions that continue if the previous function succeeded, or propagate a failure if the previous function fails. A failable function, for a Maybe object, is a function &lt;code&gt;:: a -&amp;gt; Maybe b&lt;/code&gt; or even &lt;code&gt;:: Maybe b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;There is a common vocabulary for talking about MonadPlus concepts — “return” means “succeed with this value”, and “mzero” means “fail now”.&lt;/li&gt;
&lt;li&gt;Due to Haskell’s polymorphism, we can “forget” we are using Maybe and in fact talk about/write for “general” MonadPlus’s, with &lt;code&gt;return x&lt;/code&gt; and &lt;code&gt;mzero&lt;/code&gt; resulting in the appropriate success/fail objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For the mean time, think about how it might make sense to chain operations on lists (ie, repeatedly applying functions &lt;code&gt;:: a -&amp;gt; [b]&lt;/code&gt; to lists).&lt;/p&gt;
&lt;p&gt;By this, I mean, given a function that turns a value into a list of values &lt;code&gt;f :: a -&amp;gt; [b]&lt;/code&gt;, find a way to meaningfully “chain” that function to a previous list and get a new list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; oldList &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f
newList             &lt;span class=&quot;co&quot;&gt;-- a new list based on old list; f &amp;quot;chained&amp;quot; to `oldList`.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is there more than one way to think about chaining them, even? And in what ways we can define this “chaining” to represent success/failure? Until next time!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;I have to give a fair disclaimer here. MonadPlus, as it is currently implemented, actually serves two functionalities/purposes. However, its functionality not related to success/failure is actually (except for a few cases) mostly redundant, due to another typeclass called &lt;a href=&quot;http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Alternative&quot;&gt;Alternative&lt;/a&gt; that now handles it in all nearly all modern usage. The redundancy actually stems from one of the more famous embarassing misakes in the design of the Haskell standard library — the infamous &lt;a href=&quot;http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal&quot;&gt;monad-applicative-functor hierarchy issue&lt;/a&gt;. In practice, however, simply using the appropriate typeclass for the appropriate property is the norm. For this article and this series, I will be addressing specifically this non-redundant functionality, the success/failureness; just be aware that in some other places, you will find other explanations of MonadPlus as a “whole” that includes the redundant parts.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Actually, there is one noteworthy success/failure monad that isn’t implemented as a MonadPlus in Haskell — the Either. Arguably, Either embodies the “spirit” of MonadPlus; the problem is that Haskell requires that “fail”/“mzero” must not take any parameters, and Either must always have a “reason” when it fails. However, one could easily instance their own Either instance with a “default reason” if the &lt;code&gt;Left&lt;/code&gt; type is known or constrained. The easiest way is to constrain the &lt;code&gt;Left&lt;/code&gt; type to be a monoid and make &lt;code&gt;mzero = Left mempty&lt;/code&gt;. Alternatively, if your Left is a String, you can just put in whatever default error message you want.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/practical-fun-with-monads-introducing-monadplus.html</guid><pubDate>Mon,  9 Dec 2013 18:09:26 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2013-12-09</dc:date></item><item><title>The List MonadPlus — Practical Fun with Monads (Part 2 of 3)</title><link>http://home.jle0.com:4111/entry/the-list-monadplus-practical-fun-with-monads-part.html</link><description>&lt;p&gt;Part two of an exploration of a very useful design pattern in Haskell known as MonadPlus, a part of an effort to make “practical” monads less of a mystery and fun to the good peoples of this earth.&lt;/p&gt;
&lt;p&gt;When we last left off on the &lt;a href=&quot;http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus&quot;&gt;MonadPlus introduction&lt;/a&gt;, we understood that there are times when you want to chain functions on objects in a way that “resembles” a failure/success process. We did this by exploring the most simple of all MonadPlus’s: a simple “dumb” container for a value is either in a success or a failure. We looked at how the MonadPlus design pattern really “behaved”.&lt;/p&gt;
&lt;p&gt;This time we’re going to look at another MonadPlus — the List. By the end of this series we’re going to be using nothing but the list’s MonadPlus properties to solve this classic logic problem:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can’t leave the wolf alone with the goat, or the wolf will eat the goat. He can’t leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let’s get to it!&lt;/p&gt;
&lt;h3 id=&quot;monadwhat-a-review&quot;&gt;MonadWhat? A review&lt;/h3&gt;
&lt;p&gt;Let’s take a quick review! Remember, a monad is just an object where you have defined a way to chain functions inside it. You’ll find that you can be creative this “chaining” behavior, and for any given type of object you can definitely define more than one way to “chain” functions on that type of object. One “design pattern” of chaining is MonadPlus, where we use this chaining to model success/failure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mzero&lt;/code&gt; means “failure”, and chaining anything onto a failure will still be a failure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return x&lt;/code&gt; means “succeed with &lt;code&gt;x&lt;/code&gt;”, and will return a “successful” result with a value of &lt;code&gt;x&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can read through the &lt;a href=&quot;http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus&quot;&gt;previous article&lt;/a&gt; for examples of seeing these principles in action and in real code.&lt;/p&gt;
&lt;p&gt;Without further ado, let us start on the list monad.&lt;/p&gt;
&lt;h2 id=&quot;starting-on-the-list-monad&quot;&gt;Starting on the List Monad&lt;/h2&gt;
&lt;p&gt;Now, when I say “list monad”, I mean “one way that you can implement chaining operations on a list”. To be more precise, I should say “haskell’s default choice of chaining method on lists”. Technically, &lt;strong&gt;there is no “the list monad”&lt;/strong&gt;…there is “a way we can make the List data structure a monad”.&lt;/p&gt;
&lt;p&gt;And what’s one way we can do this? You could probably take a wild guess. Yup, we can model lists as a MonadPlus — we can model chaining in a way that revolves around successes and failures.&lt;/p&gt;
&lt;p&gt;So, how can a list model success/failure? Does that even make sense?&lt;/p&gt;
&lt;p&gt;Let’s take a look at last article’s &lt;code&gt;halve&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;-- the built in function `guard`, to refresh your memory&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;guard ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m ()
guard &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; return ()
guard &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; mzero

&lt;span class=&quot;ot&quot;&gt;halve ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halve n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; even n
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, our success/fail mechanism was built into the Maybe container. Remember, first, it fails automatically if &lt;code&gt;n&lt;/code&gt; is not even; then, it auto-succeeds with &lt;code&gt;n `div` 2&lt;/code&gt; (which only works if it has not already failed). But note that we didn’t actually really “need” Maybe here…we could have used anything that had an &lt;code&gt;mzero&lt;/code&gt; (insta-fail, which is used in &lt;code&gt;guard&lt;/code&gt;) and a &lt;code&gt;return&lt;/code&gt; (auto-succeed).&lt;/p&gt;
&lt;p&gt;Let’s see what happens when we replace our Maybe container with a list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halve&amp;#39; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
halve&amp;#39; n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; even n
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is…the exact same function body. We didn’t do anything but change the type signature. But because you believe me when I say that List is a MonadPlus…this should work, right? &lt;code&gt;guard&lt;/code&gt; should work for &lt;em&gt;any&lt;/em&gt; MonadPlus, because every MonadPlus has an &lt;code&gt;mzero&lt;/code&gt; (fail). &lt;code&gt;return&lt;/code&gt; should work for any MonadPlus, too — it wouldn’t be a MonadPlus without &lt;code&gt;return&lt;/code&gt; implemented! (Remember, typeclasses are similar to interfaces in OOP) We don’t know exactly what failing and succeeding actually &lt;em&gt;looks&lt;/em&gt; like in a list yet…but if you know it’s a MonadPlus (which List is, in the standard library), you know that it &lt;em&gt;has&lt;/em&gt; these concepts defined somewhere.&lt;/p&gt;
&lt;p&gt;So, how is list a meaningful MonadPlus? Simple: a “failure” is an empty list. A “success” is a non-empty list.&lt;/p&gt;
&lt;p&gt;Watch:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
[]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39;
[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39;
[]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39;
[&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; mzero &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halve&amp;#39;
[]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So there we have it! &lt;code&gt;Nothing&lt;/code&gt; is just like &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;Just x&lt;/code&gt; is just like &lt;code&gt;[x]&lt;/code&gt;. This whole time! It’s all so clear now! Why does &lt;code&gt;Maybe&lt;/code&gt; even exist, anyway, when we can just use &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[x]&lt;/code&gt; for &lt;code&gt;Nothing&lt;/code&gt; and &lt;code&gt;Just x&lt;/code&gt; and be none the wiser? (Take some time to think about it if you want!)&lt;/p&gt;
&lt;p&gt;In fact, if we generalize our type signature for &lt;code&gt;halve&lt;/code&gt;, we can do some crazy things…&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;genericHalve ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
genericHalve n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; even n
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; genericHalve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; genericHalve &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; genericHalve &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Nothing&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; genericHalve &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
[]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
Now, when we say something like &lt;code&gt;genericHalve 8 :: Maybe Int&lt;/code&gt;, it means “I want &lt;code&gt;genericHalve 8&lt;/code&gt;…and I want the type to be &lt;code&gt;Maybe Int&lt;/code&gt;.” This is necessary here because in our &lt;code&gt;genericHalve&lt;/code&gt; can be &lt;em&gt;any&lt;/em&gt; MonadPlus, so we have to tell ghci which MonadPlus we want.
&lt;/aside&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/Halves.hs&quot;&gt;All three versions of &lt;code&gt;halve&lt;/code&gt; available for playing around with&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;So there you have it. Maybe and lists are one and the same. Lists &lt;em&gt;do&lt;/em&gt; too represent the concept of failure and success. So…what’s the difference?&lt;/p&gt;
&lt;h2 id=&quot;a-list-apart&quot;&gt;A List Apart&lt;/h2&gt;
&lt;p&gt;Lists can model failure the same way that Maybe can. But it should be apparent that lists can do a little “more” than Maybe…&lt;/p&gt;
&lt;p&gt;Consider &lt;code&gt;[3, 5]&lt;/code&gt;. Clearly this is to represent some sort of “success” (because a failure would be an empty list). But what kind of “success” could it represent?&lt;/p&gt;
&lt;p&gt;How about we look at it this way: &lt;code&gt;[3, 5]&lt;/code&gt; represents two separate &lt;em&gt;paths&lt;/em&gt; to success. When we look at a &lt;code&gt;Just 5&lt;/code&gt;, we see a computation that succeeded with a 5. When we see a &lt;code&gt;[3, 5]&lt;/code&gt;, we may interpret it as a computation that had two possible succesful paths: one succeeding with a 3 and another with a 5.&lt;/p&gt;
&lt;p&gt;You can also say that it represents a computation that &lt;em&gt;could have chosen&lt;/em&gt; to succeed in a 3, or a 5. In this way, the list monad is often referred to as “the choice monad”.&lt;/p&gt;
&lt;p&gt;This view of a list as a collection of possible successes or choices of successes is not the only way to think of a list as a monad…but it is the way that the Haskell community has adopted as arguably the most useful. (The other main way is to approach it completely differently, making list not even a MonadPlus and therefore not representing failure or success at all)&lt;/p&gt;
&lt;p&gt;Think of it this way: A value goes through a long and arduous journey with many choices and possible paths and forks. At the end of it, you have the result of every path that could have lead to a success. Contrast this to the Maybe monad, where a value goes through this arduous journey, but never has any choice. There is only one path — successful, or otherwise. A Maybe is deterministic…a list provides a choice in paths.&lt;/p&gt;
&lt;h2 id=&quot;halveordouble&quot;&gt;halveOrDouble&lt;/h2&gt;
&lt;p&gt;Let’s take a simple example: &lt;code&gt;halveOrDouble&lt;/code&gt;. It provides two successful paths if you are even: halving and doubling. It only provides one choice or possible path to success if you are odd: doubling. In this way it is slightly racist.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halveOrDouble ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
halveOrDouble n &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; even n    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, n &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
                &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; otherwise &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [n &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halveOrDouble &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
[ &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halveOrDouble &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
[   &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/HalveOrDouble.hs&quot;&gt;Play with this and other functions this section on your own&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;As you can see in the first case, with the 6, there are two paths to success: the halve, and the double. In the second case, with the 7, there is only one — the double.&lt;/p&gt;
&lt;p&gt;How about we subject a number to this halving-or-doubling journey twice? What do we expect?&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;The path of halve-halve only works if the number is divisible by two twice. So this is only a successful path if the number is divisible by four.&lt;/li&gt;
&lt;li&gt;The path of halve-double only works if the number is even. So this is only a successful path in that case.&lt;/li&gt;
&lt;li&gt;The path of double-halve will work in all cases! It is a success always.&lt;/li&gt;
&lt;li&gt;The path of double-double will also work in all cases…it’ll never fail for our sojourning number!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So…halving-or-doubling twice has two possible successful paths for an odd number, three successful paths for a number divisible by two but not four, and four successful paths for a number divisible by four.&lt;/p&gt;
&lt;p&gt;Let’s try it out:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halveOrDouble &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halveOrDouble
[       &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halveOrDouble &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halveOrDouble
[    &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; halveOrDouble &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; halveOrDouble
[ &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first list represents the results of all of the possible successful paths 5 could have taken to “traverse” the dreaded &lt;code&gt;halveOrDouble&lt;/code&gt; landscape twice — double-halve, or double-double. The second, 6 could have emerged successful with halve-double, double-halve, or double-double. For 8, all paths are successful, incidentally. He better check his privilege.&lt;/p&gt;
&lt;h3 id=&quot;do-notation&quot;&gt;Do notation&lt;/h3&gt;
&lt;p&gt;Let’s look at the same thing in do notation form to offer some possible insight:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halveOrDoubleTwice ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
halveOrDoubleTwice n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halveOrDouble n
    halveOrDouble x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Do notation describes &lt;strong&gt;a single path of a value&lt;/strong&gt;. This is slightly confusing at first. But look at it — it has the &lt;em&gt;exact same form&lt;/em&gt; as a Maybe monad do block.&lt;/p&gt;
&lt;p&gt;This thing describes, in general terms, the path of a &lt;strong&gt;single value&lt;/strong&gt;. &lt;code&gt;x&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; a list — it represents a single value, in the middle of its treacherous journey.&lt;/p&gt;
&lt;p&gt;Here is an illustration, tracing out “individual paths”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;halveOrDoubleTwice ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
halveOrDoubleTwice n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;-- halveOrDoubleTwice 6&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halveOrDouble n        &lt;span class=&quot;co&quot;&gt;-- x &amp;lt;-     Just 3          Just 12&lt;/span&gt;
    halveOrDouble x             &lt;span class=&quot;co&quot;&gt;--      Nothing  Just 6  Just 6  Just 24&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where you take the left path if you want to halve, and the right path if you want to double.&lt;/p&gt;
&lt;p&gt;Remember, just like in the Maybe monad, the &lt;code&gt;x&lt;/code&gt; represents the value “inside” the object — &lt;code&gt;x&lt;/code&gt; represents a 3 &lt;strong&gt;or&lt;/strong&gt; a 12 (but not “both”), depending on what path you are taking/are “in”. That’s why we can call &lt;code&gt;halveOrDouble x&lt;/code&gt;: &lt;code&gt;halveOrDouble&lt;/code&gt; only takes &lt;code&gt;Int&lt;/code&gt;s and &lt;code&gt;x&lt;/code&gt; is &lt;em&gt;one&lt;/em&gt; &lt;code&gt;Int&lt;/code&gt; along the path.&lt;/p&gt;
&lt;h3 id=&quot;a-winding-journey&quot;&gt;A winding journey&lt;/h3&gt;
&lt;p&gt;Note that once you bind a value to a variable (like &lt;code&gt;x&lt;/code&gt;), then that is the value for &lt;code&gt;x&lt;/code&gt; for the entire rest of the journey. In fact, let’s see it in action:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;hod2PlusOne ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
hod2PlusOne n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;              &lt;span class=&quot;co&quot;&gt;-- hod2plusOne 6&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halveOrDouble n        &lt;span class=&quot;co&quot;&gt;-- x &amp;lt;-     Just 3          Just 12&lt;/span&gt;
    halveOrDouble x             &lt;span class=&quot;co&quot;&gt;--      Nothing  Just 6  Just 6  Just 24&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;              &lt;span class=&quot;co&quot;&gt;--      (skip)   Just 4  Just 13 Just 13&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; hod2PlusOne &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
[   &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay! This is getting interesting now. What’s going on? Well, there are four possible “paths”.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;In the half-half path, &lt;code&gt;x&lt;/code&gt; (the result of the first halving) is 3. However, the half-half path is a failure — 6 cannot be halved twice. Therefore, even though &lt;code&gt;x&lt;/code&gt; is three, the path has already failed before we get to the &lt;code&gt;return (x + 1)&lt;/code&gt;. Just like in the case with Maybe, once something fails during the process of the journey, the entire journey is a failure.&lt;/li&gt;
&lt;li&gt;In the half-double path, &lt;code&gt;x&lt;/code&gt; is also 3. However, this journey doesn’t fail. It survives to the end. After the doubling, the value of the journey at that point is “Just 6”. Afterwards, it “auto-succeeds” and replaces the current value with the value of &lt;code&gt;x&lt;/code&gt; on that path (3) plus 1 — 4. This is just like how in the Maybe monad, we return a new value after the guard.&lt;/li&gt;
&lt;li&gt;In the double-halve path, &lt;code&gt;x&lt;/code&gt; (the result of the first operation, a double) is 12. The second operation makes the value in the journey a 6; At the end of it all, we succeed with whatever the value of &lt;code&gt;x&lt;/code&gt; is on that specific journey (12) is, plus one. 13.&lt;/li&gt;
&lt;li&gt;Same story here, but for double-double; &lt;code&gt;x&lt;/code&gt; is 12. At the end of it all, the journey never fails, so it succeeds with &lt;code&gt;x + 1&lt;/code&gt;, or 13.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;trying-out-every-path&quot;&gt;Trying out every path&lt;/h4&gt;
&lt;p&gt;If this doesn’t satisfy you, here is an example of four Maybe do blocks where we “flesh out” each possible path, with the value of the block at each line in comments:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;double ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
double n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; n

&lt;span class=&quot;ot&quot;&gt;halveHalvePlusOne ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halveHalvePlusOne n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;                &lt;span class=&quot;co&quot;&gt;-- n = 6&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve n                        &lt;span class=&quot;co&quot;&gt;-- Just 3 (x = 3)&lt;/span&gt;
    halve x                             &lt;span class=&quot;co&quot;&gt;-- Nothing&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;-- (skip)&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;halveDoublePlusOne ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
halveDoublePlusOne &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;                 &lt;span class=&quot;co&quot;&gt;-- n = 6&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; halve n                        &lt;span class=&quot;co&quot;&gt;-- Just 3 (x = 3)&lt;/span&gt;
    double x                            &lt;span class=&quot;co&quot;&gt;-- Just 6&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;-- Just 4&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;doubleHalvePlusOne ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
doubleHalvePlusOne &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;                 &lt;span class=&quot;co&quot;&gt;-- n = 6&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; double n                       &lt;span class=&quot;co&quot;&gt;-- Just 12 (x = 12)&lt;/span&gt;
    halve x                             &lt;span class=&quot;co&quot;&gt;-- Just 6&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;-- Just 13&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;doubleDoublePlusOne ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
doubleDoublePlusOne &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;                &lt;span class=&quot;co&quot;&gt;-- n = 6&lt;/span&gt;
    x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; double n                       &lt;span class=&quot;co&quot;&gt;-- Just 12 (x = 12)&lt;/span&gt;
    double x                            &lt;span class=&quot;co&quot;&gt;-- Just 6&lt;/span&gt;
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; x &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;                      &lt;span class=&quot;co&quot;&gt;-- Just 13&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;a-graphical-look&quot;&gt;A graphical look&lt;/h4&gt;
&lt;p&gt;This tree might also be a nice illustration, showing what happens at each stage of the journey.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/monad-plus/halvedouble.png&quot; title=&quot;hod2PlusOne 6&quot; alt=&quot;hod2PlusOne 6, all journeys illustrated&quot; /&gt;&lt;figcaption&gt;&lt;em&gt;hod2PlusOne 6&lt;/em&gt;, all journeys illustrated&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Every complete “journey” is a complete path from top to bottom. You can see that the left-left journey (the half-halve journey) fails. The left-right journey (the halve-double journey) passes, and at the end is given the value of &lt;code&gt;x + 1&lt;/code&gt; for the &lt;code&gt;x&lt;/code&gt; in that particular journey. The other journeys work the same way!&lt;/p&gt;
&lt;h2 id=&quot;solving-real-ish-problems&quot;&gt;Solving real-ish problems&lt;/h2&gt;
&lt;p&gt;That wasn’t too bad, was it? We’re actually just about ready to start implementing our solution to the Wolf/Goat/Cabbage puzzle!&lt;/p&gt;
&lt;p&gt;Before we end this post let’s build some more familiarity with the List monad and try out a very common practical example.&lt;/p&gt;
&lt;!-- That wasn&#39;t too bad!  We&#39;re *almost* ready to begin implementing our solution --&gt;
&lt;!-- to the Wolf/Goat/Cabbage puzzle. --&gt;
&lt;!-- Let&#39;s try one &quot;real&quot;-ish problem to build some more --&gt;
&lt;!-- But we&#39;re going to go through a couple more examples of branching journeys --&gt;
&lt;!-- first --- both as a way to build more familiarity with the &quot;branching journey --&gt;
&lt;!-- monad&quot; (list), and also as a nice conclusion to this post. --&gt;
&lt;!-- ### Testing multiple paths --&gt;
&lt;!-- Here&#39;s a fun one. --&gt;
&lt;!-- &quot;What operations on a number will make it a multiple of three?&quot; --&gt;
&lt;!-- ~~~haskell --&gt;
&lt;!-- isMultThree :: Int -&gt; Bool                              -- 1 --&gt;
&lt;!-- isMultThree a = a `mod` 3 == 0 --&gt;
&lt;!-- testNumber :: Int -&gt; [String] --&gt;
&lt;!-- testNumber n = do --&gt;
&lt;!--     (f, fName)  &lt;-  [ ((*2)         , &quot;times two&quot;)      -- 2 --&gt;
&lt;!--                     , ((*3)         , &quot;times three&quot;) --&gt;
&lt;!--                     , ((+2)         , &quot;plus two&quot;) --&gt;
&lt;!--                     , ((+3)         , &quot;plus three&quot;) --&gt;
&lt;!--                     , ((^2)         , &quot;square&quot;) --&gt;
&lt;!--                     , ((+1).(^2)    , &quot;square plus 1&quot;) --&gt;
&lt;!--                     , ((+1).(^3)    , &quot;cube plus 1&quot;) --&gt;
&lt;!--                     , (id           , &quot;stay the same&quot;) --&gt;
&lt;!--                     ] --&gt;
&lt;!--     let z = f n                                         -- 3 --&gt;
&lt;!--     guard $ isMultThree z                               -- 4 --&gt;
&lt;!--     return fName                                        -- 5 --&gt;
&lt;!-- ~~~ --&gt;
&lt;!-- ~~~haskell --&gt;
&lt;!-- λ: testNumber 4 --&gt;
&lt;!-- [&quot;times three&quot;, &quot;plus two&quot;] --&gt;
&lt;!-- λ: testNumber 5 --&gt;
&lt;!-- [&quot;times three&quot;, &quot;cube plus 1&quot;] --&gt;
&lt;!-- λ: testNumber 6 --&gt;
&lt;!-- [&quot;times two&quot;, &quot;times three&quot;, &quot;plus three&quot;, &quot;square&quot;, &quot;stay the same&quot;] --&gt;
&lt;!-- λ: testNumber 7 --&gt;
&lt;!-- [&quot;times three&quot;, &quot;plus two&quot;] --&gt;
&lt;!-- λ: testNumber 8 --&gt;
&lt;!-- [&quot;times three&quot;, &quot;cube plus 1&quot;] --&gt;
&lt;!-- ~~~ --&gt;
&lt;!-- [Play with it here!][testNumber] --&gt;
&lt;!-- [testNumber]: https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/TestNumber.hs --&gt;
&lt;!-- Let&#39;s go over this step-by-step: --&gt;
&lt;!-- 1.  First of all, define the utility function `isMultThree a`, which is true --&gt;
&lt;!--     when `a` is a multiple of three and false when it isn&#39;t. --&gt;
&lt;!-- 2.  The journey diverges immediately.  `f` and `fName` is now a value that --&gt;
&lt;!--     depends on the path we take.  If we take the first path, `f = (*2)` (the --&gt;
&lt;!--     doubling function) and `fName = &quot;times two&quot;`.  On the second path, `f = --&gt;
&lt;!--     (*3)` (the tripling function) and `fName = &quot;times three&quot;`, etc. --&gt;
&lt;!-- 3.  We alias `z` to be the function we chose applied to `x`.  If we had chosen --&gt;
&lt;!--     the path `f = (*2)`, `z` would be `(*2) x`, which is `x*2`.  This is --&gt;
&lt;!--     mainly for readability. --&gt;
&lt;!-- 4.  We check if `z` is a multiple of three.  If it isn&#39;t, the journey sadly --&gt;
&lt;!--     ends here.  For example, if we called the function with `n = 4`, and we --&gt;
&lt;!--     had chosen `f = (^2)` (the square function), this journey (involving the --&gt;
&lt;!--     choice of `(^2)`) would meet its failure here...but the journey with the --&gt;
&lt;!--     choice `f = (+2)` would not! --&gt;
&lt;!-- 5.  At the end of the weary journey, we return the name of the function we --&gt;
&lt;!--     chose.  This step is never reached for failed journeys. --&gt;
&lt;!-- Here is another diagram, similar to the last. --&gt;
&lt;!-- ![*testNumber 5*, all journeys illustrated](/img/entries/monad-plus/testnumber.png &quot;testNumber 5&quot;) --&gt;
&lt;h3 id=&quot;finding-the-right-combinations&quot;&gt;Finding the right combinations&lt;/h3&gt;
&lt;p&gt;Here is probably the most common of all examples involving the list monad: finding Pythagorean triples.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;triplesUnder n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    a &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]                     &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
    b &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [a&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]                     &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
    c &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [b&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]                     &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; a&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; b&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; c&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- 4&lt;/span&gt;
    return (a,b,c)                  &lt;span class=&quot;co&quot;&gt;-- 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/TriplesUnder.hs&quot;&gt;Download it and try it out yourself!&lt;/a&gt;)&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Our journey begins with picking a number between 1 and &lt;code&gt;n&lt;/code&gt; and setting it to &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Next, we pick a number between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; and set it to &lt;code&gt;b&lt;/code&gt;. We start from &lt;code&gt;a&lt;/code&gt; because if we don’t, we are probably going to be testing the same tuple twice.&lt;/li&gt;
&lt;li&gt;Next, we pick a number between &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;. This is our hypotenuse, and of course all hypontenii are larger than either side.&lt;/li&gt;
&lt;li&gt;Now, we mercilessly and ruthlessly end all journeys who were unfortunate enough to pick a non-Pythagorean combination — combinations where &lt;code&gt;a^2 + b^2&lt;/code&gt; is not &lt;code&gt;c^2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;For those successful journeys, we succeed with a tuple containing our victorious triple &lt;code&gt;(a,b,c)&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s try “following” this path with some arbitrary choices, looking at arbitrary journeys for &lt;code&gt;n = 10&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We pick &lt;code&gt;a&lt;/code&gt; as 2, &lt;code&gt;b&lt;/code&gt; as 3, and &lt;code&gt;c&lt;/code&gt; as 9. All is good until we get to the guard. &lt;code&gt;a^2 + b^2&lt;/code&gt; is 10, which is not &lt;code&gt;c^2&lt;/code&gt; (81), unfortunately. This &lt;code&gt;(2,3,10)&lt;/code&gt; journey ends here.&lt;/li&gt;
&lt;li&gt;We pick &lt;code&gt;a&lt;/code&gt; as 3, &lt;code&gt;b&lt;/code&gt; as 4, and &lt;code&gt;c&lt;/code&gt; as 5. On the guard, we succeed: &lt;code&gt;a^2 + b^2&lt;/code&gt; is 25, which indeed is &lt;code&gt;c^2&lt;/code&gt;. Our journey passes the guard, and then succeeds with a value of &lt;code&gt;(3,4,5)&lt;/code&gt;. This is indeed counted among the successful paths — among the victorious!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Paths like &lt;code&gt;a = 5&lt;/code&gt; and &lt;code&gt;b = 3&lt;/code&gt; do not even happen. This is because if we pick &lt;code&gt;a = 5&lt;/code&gt;, then in that particular journey, &lt;code&gt;b&lt;/code&gt; can only be chosen between &lt;code&gt;5&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; inclusive.&lt;/p&gt;
&lt;p&gt;Remember, the final result is the accumulation of &lt;strong&gt;all such successful journeys&lt;/strong&gt;. A little bit of combinatorics will show that there are &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B6%7D%20%5Ctimes%20%5Cfrac%7B%28n%2B2%29%21%7D%7B%28n-1%29%21%7D&quot; alt=&quot;\frac{1}{6} \times \frac{(n+2)!}{(n-1)!}&quot; title=&quot;\frac{1}{6} \times \frac{(n+2)!}{(n-1)!}&quot; /&gt; possible journeys to attempt. Only the ones that do not fail (at the guard) will make it to the end. Remember how MonadPlus works — one failure along the journey means that the &lt;em&gt;entire journey&lt;/em&gt; is a failure.&lt;/p&gt;
&lt;p&gt;Let’s see what we get when we try it at the prompt:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; triplesUnder &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;
[ ( &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;),( &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;) ]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; triplesUnder &lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;
[ ( &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;),( &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;),( &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;),( &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;24&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;)
 ,( &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;),( &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;),(&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;),(&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;) ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perfect! You can probably quickly verify that all of these solutions are indeed Pythagorean triples. Out of the 220 journeys undertaken by &lt;code&gt;triplesUnder 10&lt;/code&gt;, only two of them survived to the end to be successful. Out of the 2925 journeys in &lt;code&gt;triplesUnder 25&lt;/code&gt;, only eight of them made it to the end. The rest “died”/failed, and as a result we do not even observe their remains. It is a cruel and unforgiving world.&lt;/p&gt;
&lt;p&gt;While the full diagram of &lt;code&gt;triplesUnder 5&lt;/code&gt; has 35 branches, here is a diagram for those branches with &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?a%20%3E%202&quot; alt=&quot;a &amp;gt; 2&quot; title=&quot;a &amp;gt; 2&quot; /&gt;, which has 10:&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/monad-plus/triplesunder.png&quot; title=&quot;triplesUnder 5&quot; alt=&quot;triplesUnder 5, all journeys (where a &amp;gt; 2) illustrated&quot; /&gt;&lt;figcaption&gt;&lt;em&gt;triplesUnder 5&lt;/em&gt;, all journeys (where a &amp;gt; 2) illustrated&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;almost-there&quot;&gt;Almost There!&lt;/h2&gt;
&lt;p&gt;Let’s do a quick review:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can really treat List exactly as if it were Maybe by using the general MonadPlus terms &lt;code&gt;mzero&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. If you do this, &lt;code&gt;Nothing&lt;/code&gt; is equivalent to &lt;code&gt;[]&lt;/code&gt;, and &lt;code&gt;Just x&lt;/code&gt; is equivalent to &lt;code&gt;[x]&lt;/code&gt;. Trippy!&lt;/li&gt;
&lt;li&gt;However, whereas Maybe is a “deterministic” success, for a list, a list of successes represents the end results of &lt;em&gt;possible paths&lt;/em&gt; to success. Chaining two “path splits” results in the item having to traverse both splits one after another.&lt;/li&gt;
&lt;li&gt;If any of these paths meet a failure at some point in their journey, the entire path is a failure and doesn’t show up in the list of successes. &lt;em&gt;This&lt;/em&gt; is the “MonadPlus”ness of it all.&lt;/li&gt;
&lt;li&gt;When you use a do block (or reason about paths), it helps to think of each do block as representing one specific path in a Maybe monad, with arbitrary choices. Your &lt;code&gt;&amp;lt;-&lt;/code&gt; binds all represent &lt;em&gt;one specific element&lt;/em&gt;, &lt;em&gt;just&lt;/em&gt; like for Maybe.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The last point is particularly important and is pretty pivotal in understanding what is coming up next. Remember that all Maybe blocks and List blocks really essentially look &lt;em&gt;exactly the same&lt;/em&gt;. This keeping-track-of-separate-paths thing is all handled behind-the scenes.&lt;/p&gt;
&lt;p&gt;In fact you should be able to look at code like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;triplesUnder n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    a &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]
    b &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [a&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]
    c &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [b&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; a&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; b&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; c&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    return (a,b,c)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and see that it is structurally identical to&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;triplesUnder&amp;#39; n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    a &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
    b &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
    c &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; a&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; b&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; c&lt;span class=&quot;fu&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    return (a,b,c)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for any arbitrary choice of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, except instead of &lt;code&gt;Just 3&lt;/code&gt; (or &lt;code&gt;[3]&lt;/code&gt;), you have &lt;code&gt;[2,3,4]&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;In fact recall that this block:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;genericHalve ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MonadPlus&lt;/span&gt; m &lt;span class=&quot;ot&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
genericHalve n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; even n
    return &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; n &lt;span class=&quot;ot&quot;&gt;`div`&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is general enough that it works for both.&lt;/p&gt;
&lt;p&gt;Hopefully this all serves to show that &lt;strong&gt;in do blocks, Lists and Maybes are structurally identical&lt;/strong&gt;. You reason with them the exact same way you do with Maybe’s. In something like &lt;code&gt;x &amp;lt;- Just 5&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; represents a &lt;strong&gt;single value&lt;/strong&gt;, the 5. In something like &lt;code&gt;x &amp;lt;- [1,2,3]&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; &lt;em&gt;also&lt;/em&gt; represents a single value — the 1, the 2, or the 3, depending on which path you are currently on. Then later in the block, you can refer to &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; refers to &lt;em&gt;that&lt;/em&gt; one specific &lt;code&gt;x&lt;/code&gt; for that path.&lt;/p&gt;
&lt;h3 id=&quot;until-next-time&quot;&gt;Until next time&lt;/h3&gt;
&lt;p&gt;So I feel like we are at all we need to know to really use the list monad to solve a large class of logic problems (because who needs Prolog, anyway?).&lt;/p&gt;
&lt;p&gt;Between now and next time, think about how you would approach a logic problem like the Wolf/Goat/Cabbage problem with the concepts of MonadPlus? What would &lt;code&gt;mzero&lt;/code&gt;/fail be useful for? What would the idea of a success be useful for, and what would the idea of “multiple paths to success” in a journey even mean? What is the journey?&lt;/p&gt;
&lt;p&gt;Until next!&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/the-list-monadplus-practical-fun-with-monads-part.html</guid><pubDate>Wed, 18 Dec 2013 19:08:38 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2013-12-18</dc:date></item><item><title>Wolf, Goat, Cabbage: The List MonadPlus &amp; Logic Problems</title><link>http://home.jle0.com:4111/entry/wolf-goat-cabbage-the-list-monadplus-logic-problems.html</link><description>&lt;p&gt;Today we’re going to learn to solve the classic and ageless logic problems without any data structures besides List’s monadic properties as a MonadPlus!&lt;/p&gt;
&lt;p&gt;We are going to be solving this old-as-time logic puzzle, which &lt;a href=&quot;http://en.wikipedia.org/wiki/Fox,_goose_and_bag_of_beans_puzzle&quot;&gt;Wikipedia&lt;/a&gt; claims dates back to the 9th century:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can’t leave the wolf alone with the goat, or the wolf will eat the goat. He can’t leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We’re going to assume a somewhat basic familiarity with functional programming concepts and a basic understanding of monads (if you don’t know that much, check out &lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot;&gt;adit’s&lt;/a&gt; great concice guide). If you aren’t familiar with MonadPlus/Alternative (and how they work as monads) check out &lt;a href=&quot;http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus&quot;&gt;Part 1&lt;/a&gt; and &lt;a href=&quot;http://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part&quot;&gt;Part 2&lt;/a&gt;, which should provide all the background and most of the syntax. Most Haskell syntax is either be explained here as we get to it or in the previous parts. Still, if you have any questions, feel free to leave a comment, give &lt;a href=&quot;http://learnyouahaskell.com&quot;&gt;Learn You A Haskell&lt;/a&gt; a quick read, or stop by freenode’s friendly #haskell!&lt;/p&gt;
&lt;h3 id=&quot;a-monadplus-review&quot;&gt;A MonadPlus Review&lt;/h3&gt;
&lt;p&gt;The usefulness of a monad depends on how you define the characteristic “bind” or “chaining” behavior. For this article, MonadPlus refers to the design pattern (and Haskell typeclass) where you model this “chaining” as a “success/fail” process&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There is a common language with to talk about this process: &lt;code&gt;mzero&lt;/code&gt; means “fail here” and &lt;code&gt;return x&lt;/code&gt; means “succeed with a result of the value &lt;code&gt;x&lt;/code&gt; here”. So chaining is implemented such that chaining anything to a failure will propagate that failure forward. That is, &lt;code&gt;mzero &amp;gt;&amp;gt; return x&lt;/code&gt; = &lt;code&gt;mzero&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;our-approach&quot;&gt;Our Approach&lt;/h2&gt;
&lt;p&gt;So, armed with what we learned in &lt;a href=&quot;http://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part&quot;&gt;Part 2&lt;/a&gt;, let’s formulate a general plan for finding all solutions in &lt;code&gt;n&lt;/code&gt; moves.&lt;/p&gt;
&lt;p&gt;Now, in the List monad, we can think of things as “journeys” or stories: subject your value to a long and arduous journey, specifying at every step of the way what choices it has to continue. Then specify where journeys fail and end. At the end of it all, the result is a list of the finishing values of all trails that have completed the journey.&lt;/p&gt;
&lt;p&gt;With the List monad, we say “Here is the description of &lt;em&gt;a&lt;/em&gt; (single) journey. What journeys following this description succeed?”&lt;/p&gt;
&lt;p&gt;So what could this journey be for us? Well, we think of a journey in this situation as the accumulation of moves to a plan. We start out with a blank plan (“Do nothing”). The next step, we add one move to our plan (“Just move the fox”, for example). Then the next step, we add another move (“First move the fox, then move the farmer”).&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Start with a blank plan; a tabula rasa.&lt;/li&gt;
&lt;li&gt;Add a legal and safe move to it.&lt;/li&gt;
&lt;li&gt;Repeat Step 2 &lt;code&gt;n&lt;/code&gt; times&lt;/li&gt;
&lt;li&gt;Fail if you aren’t a solution; succeed if you are.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Simple, right? We just laid out &lt;em&gt;the path of a single plan&lt;/em&gt;, from its birth to its eventual death or ascension.&lt;/p&gt;
&lt;p&gt;This is the most significant thing about this approach: it allows you to describe &lt;strong&gt;one journey&lt;/strong&gt;, in general terms, and List will “automatically” find out all successful journeys that fit your mold. You don’t ever have to worry about the ensemble or manually deal with explicit branching or filtering. Cognitively, all you have to do is &lt;em&gt;write &lt;strong&gt;one&lt;/strong&gt; story&lt;/em&gt;. Just &lt;em&gt;one&lt;/em&gt;. That is the power of the List Monad abstraction.&lt;/p&gt;
&lt;h2 id=&quot;our-types&quot;&gt;Our Types&lt;/h2&gt;
&lt;p&gt;The first thing we do when writing any Haskell program: define our types!&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Character&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Enum&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;newtype&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Character&lt;/span&gt;                &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;                        &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;
    show (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;F&amp;quot;&lt;/span&gt;
    show (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;)    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;W&amp;quot;&lt;/span&gt;
    show (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;)    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;G&amp;quot;&lt;/span&gt;
    show (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&amp;quot;C&amp;quot;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt;]                              &lt;span class=&quot;co&quot;&gt;-- 4&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Position&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;West&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;                     &lt;span class=&quot;co&quot;&gt;-- 5&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;deriving&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;Show&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Eq&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;First, we define the enumerated type &lt;code&gt;Character&lt;/code&gt; all the characters we will be working with: the farmer, the wolf, the goat, and the cabbage.&lt;/li&gt;
&lt;li&gt;Next, we define a simple &lt;code&gt;Move&lt;/code&gt; container, which just contains a character. A &lt;code&gt;MoveThe Farmer&lt;/code&gt; will represent a movement of only the farmer, a &lt;code&gt;MoveThe Wolf&lt;/code&gt; will represent the movement of both the farmer and the wolf, etc.&lt;/li&gt;
&lt;li&gt;For the purposes of easy debugging, we’re going to define our own instance of &lt;code&gt;Show&lt;/code&gt; for moves so that we can use &lt;code&gt;print&lt;/code&gt; on them.&lt;/li&gt;
&lt;li&gt;A simple type synonym; a &lt;code&gt;Plan&lt;/code&gt; is just a list of &lt;code&gt;Move&lt;/code&gt;s. Note that we are not using this list as a MonadPlus — it’s just a plain dumb list of moves in our plan.&lt;/li&gt;
&lt;li&gt;A &lt;code&gt;Position&lt;/code&gt; type: either on the west bank or on the east bank of the river. Everyone starts out on the west bank, and we want them all to end up on the east bank.&lt;/li&gt;
&lt;/ol&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hi! These “Welcome to Haskell” asides are for people unfamiliar with Haskell, mostly for Haskell syntax stuff. If you already feel comfortable, feel free to skip them.&lt;/p&gt;
&lt;p&gt;There’s a lot of Haskell syntax and concepts here; mostly, all we are doing is declaring new types.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;We declare that &lt;code&gt;Character&lt;/code&gt; is “either” a &lt;code&gt;Farmer&lt;/code&gt;, &lt;code&gt;Wolf&lt;/code&gt;, &lt;code&gt;Goat&lt;/code&gt;, or &lt;code&gt;Cabbage&lt;/code&gt;. This is like saying that a &lt;code&gt;Bool&lt;/code&gt; is either a &lt;code&gt;False&lt;/code&gt; or a &lt;code&gt;True&lt;/code&gt;: in fact, you could define your own &lt;code&gt;Bool&lt;/code&gt; with something like this: (or even your own &lt;code&gt;Int&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;False&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;536870912&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;536870911&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;deriving&lt;/code&gt; syntax tells the compiler to automatically derive functions for printing the type (Show), testing for equality (Eq), and enumerating through them (Enum)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We declare a new type &lt;code&gt;Move&lt;/code&gt; which is just a wrapper around a &lt;code&gt;Character&lt;/code&gt;. We can create a new &lt;code&gt;Move&lt;/code&gt; by using &lt;code&gt;MoveThe&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Character&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;t &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;λ:&lt;/code&gt; represents a command at the interactive prompt ghci, and &lt;code&gt;:t&lt;/code&gt; asks for the type of whatever comes after it)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Here we define custom functions for printing out a &lt;code&gt;Move&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Here is a type synonym &lt;code&gt;Plan&lt;/code&gt;. Every time we use &lt;code&gt;Plan&lt;/code&gt; as a type, we really mean &lt;code&gt;[Move]&lt;/code&gt;, and the compiler treats the two things as the same.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Position&lt;/code&gt;: same deal as &lt;code&gt;Character&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/aside&gt;
&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;
&lt;h3 id=&quot;the-final-step&quot;&gt;The Final Step&lt;/h3&gt;
&lt;p&gt;We’re going to skip to the end and write our final step and what it is supposed to be, and then fill in the functions that are necessary to make it happen.&lt;/p&gt;
&lt;p&gt;The last stage of our journey is after we have made all &lt;code&gt;n&lt;/code&gt; moves, we end the journey if it is not a solution.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;makeNMoves ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]         &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;isSolution ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;findSolutions ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]      &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
findSolutions n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    p &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; makeNMoves n               &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; isSolution p            &lt;span class=&quot;co&quot;&gt;-- 4&lt;/span&gt;
    return p                        &lt;span class=&quot;co&quot;&gt;-- 5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;The type signatures of the helper functions we will be using.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;findSolutions n&lt;/code&gt; is going to be the all successful plans after &lt;code&gt;n&lt;/code&gt; moves.&lt;/li&gt;
&lt;li&gt;Let &lt;code&gt;p&lt;/code&gt; be a plan after &lt;code&gt;n&lt;/code&gt; moves have been added to it. Note that &lt;code&gt;makeNMoves&lt;/code&gt; is itself a journey — a sub-journey. So &lt;code&gt;p&lt;/code&gt; is a single plan that has &lt;em&gt;already gone through&lt;/em&gt; the &lt;code&gt;makeNMoves&lt;/code&gt; journey. We are continuing that journey.&lt;/li&gt;
&lt;li&gt;End the journey unless &lt;code&gt;p&lt;/code&gt; is a solution (all characters are on the east side)&lt;/li&gt;
&lt;li&gt;Succeed with &lt;code&gt;p&lt;/code&gt; if the journey has not yet ended.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hm. Sounds good! We’re done!&lt;/p&gt;
&lt;p&gt;So now we only need to implement &lt;code&gt;makeNMoves&lt;/code&gt; and &lt;code&gt;isSolution&lt;/code&gt;!&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Haskell is a functional language…but that “do” block sure looks very imperative to me. What gives?&lt;/p&gt;
&lt;p&gt;As explained in &lt;a href=&quot;http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus&quot;&gt;Part 1&lt;/a&gt;, all do blocks are just syntactical sugar for repeated applications of &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;findSolutions ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]
findSolutions &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
    makeNMoves n &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (\p &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; guard (isSolution p) &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; return p)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
And &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; is just the (hopefully) familiar bind. Again, look at &lt;a href=&quot;http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus&quot;&gt;Part 1&lt;/a&gt; or &lt;a href=&quot;http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html&quot;&gt;adit’s&lt;/a&gt; tutorial for a fuller explanation.
&lt;/aside&gt;
&lt;h3 id=&quot;makenmoves&quot;&gt;makeNMoves&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;makeNMoves&lt;/code&gt; is going to be the main logic of our program. We want it to be a journey, itself — a journey of a single plan going through &lt;code&gt;n&lt;/code&gt; additions of moves.&lt;/p&gt;
&lt;p&gt;That means we want something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;makeMove ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]

&lt;span class=&quot;ot&quot;&gt;startingPlan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;
startingPlan &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; []

&lt;span class=&quot;ot&quot;&gt;makeNMoves ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]
makeNMoves n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    m1 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; makeMove startingPlan
    m2 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; makeMove m1
    m3 &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; makeMove m2
    &lt;span class=&quot;co&quot;&gt;-- ... (n times)&lt;/span&gt;
    mn &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; makeMove mx
    return mn&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Which says “The journey of &lt;code&gt;makeNMoves&lt;/code&gt; is repeatedly making a move &lt;code&gt;n&lt;/code&gt; times.”&lt;/p&gt;
&lt;p&gt;Of course we have seen that particular type of &lt;code&gt;do&lt;/code&gt; block before, it is simply:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;makeNMoves ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]
makeNMoves n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
    makeMove startingPlan &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; makeMove
        &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; makeMove &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; makeMove   &lt;span class=&quot;co&quot;&gt;-- ...&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; makeMove                &lt;span class=&quot;co&quot;&gt;-- (n times)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Luckily there is a function in the standard library that allows us to repeatedly apply a function &lt;code&gt;n&lt;/code&gt; times: &lt;code&gt;iterate :: (a -&amp;gt; a) -&amp;gt; a -&amp;gt; [a]&lt;/code&gt;. &lt;code&gt;iterate f x&lt;/code&gt; takes a function &lt;code&gt;f :: a -&amp;gt; a&lt;/code&gt; and repeatedly applies it to a starting value &lt;code&gt;x :: a&lt;/code&gt; and yields the results as a list:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;iterate f x &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [ x, f x, f (f x), f (f (f x)) &lt;span class=&quot;fu&quot;&gt;...&lt;/span&gt; ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And so to get the &lt;code&gt;n&lt;/code&gt;th application, we use &lt;code&gt;iterate f x !! n&lt;/code&gt; (&lt;code&gt;!!&lt;/code&gt; being the indexing function, getting the &lt;code&gt;n&lt;/code&gt;th element of the list)&lt;/p&gt;
&lt;p&gt;So now we can define &lt;code&gt;makeNMoves&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;makeNMoves ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]
makeNMoves n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; iterate (&lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; makeMove) (return startingPlan) &lt;span class=&quot;fu&quot;&gt;!!&lt;/span&gt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We say “apply &lt;code&gt;(&amp;gt;&amp;gt;= makeMove)&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; times, starting the single starting plan”.&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember that &lt;code&gt;return x &amp;gt;&amp;gt;= f&lt;/code&gt; is the same as &lt;code&gt;f x&lt;/code&gt;. You can see this here:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;foo1 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    y &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; return x
    f y

&lt;span class=&quot;co&quot;&gt;-- identical&lt;/span&gt;
foo2 &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; f x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
Where &lt;code&gt;return x&lt;/code&gt; says “succeed with the value &lt;code&gt;x&lt;/code&gt;”, and &lt;code&gt;y &amp;lt;-&lt;/code&gt; says “set &lt;code&gt;y&lt;/code&gt; to the value of that success”. Of course, &lt;code&gt;y&lt;/code&gt; is just going to be &lt;code&gt;x&lt;/code&gt;, because we had just said “succeed with the value of &lt;code&gt;x&lt;/code&gt;. That means that &lt;code&gt;f y&lt;/code&gt; is the same as &lt;code&gt;f x&lt;/code&gt;.
&lt;/aside&gt;
&lt;p&gt;Even though the syntax is not the cleanest, it is important to remember here that what we are doing is simply defining the journey &lt;code&gt;makeNMoves&lt;/code&gt; as the result of taking &lt;code&gt;n&lt;/code&gt; &lt;code&gt;makeMove&lt;/code&gt; journeys one after the other. The same as that first do block.&lt;/p&gt;
&lt;h3 id=&quot;issolution&quot;&gt;isSolution&lt;/h3&gt;
&lt;p&gt;Let’s define our helper function &lt;code&gt;isSolution :: Plan -&amp;gt; Bool&lt;/code&gt;. Basically, we want to check if the positions of all of the characters are &lt;code&gt;East&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;First, we need a way to get the position of a farmer/animal after a given plan has been executed.&lt;/p&gt;
&lt;h4 id=&quot;positionof&quot;&gt;positionOf&lt;/h4&gt;
&lt;p&gt;Our function &lt;code&gt;positionOf :: Plan -&amp;gt; Character -&amp;gt; Position&lt;/code&gt; is going to take a &lt;code&gt;Plan&lt;/code&gt; and a &lt;code&gt;Character&lt;/code&gt;, and report what side of the river the character is on.&lt;/p&gt;
&lt;p&gt;Because every single move swaps the position of the farmer, the final position of the farmer depends only on the even-/odd-ness of the number of total moves. If it is even, then the farmer is on the west bank still (consider 0 moves, two moves, etc.). If it is odd, then the farmer is on the east bank.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;positionOf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Character&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Position&lt;/span&gt;
positionOf p c &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; c &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; positionFromCount &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; length p
    _       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; undefined
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        positionFromCount n &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; even n      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;West&lt;/span&gt;
                            &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; othherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, what if we want to know about non-farmers?&lt;/p&gt;
&lt;p&gt;Instead of finding the total number of moves, we only need to find the number of moves involving that given animal.&lt;/p&gt;
&lt;p&gt;Let’s first filter the Plan &lt;code&gt;p&lt;/code&gt; by moves involving the character &lt;code&gt;c&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;filter (&lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; c) p&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will return a new Plan, but with only the moves involving the character &lt;code&gt;c&lt;/code&gt;. We can then use the length of &lt;em&gt;that&lt;/em&gt;.&lt;/p&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;filter :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]&lt;/code&gt; is a common function that takes a predicate &lt;code&gt;a -&amp;gt; Bool&lt;/code&gt; and a list, and returns a new list with only the items for which the predicate returns true.&lt;/p&gt;
&lt;code&gt;(== MoveThe c)&lt;/code&gt; is a function that returns true if the move is equal to &lt;code&gt;MoveThe c&lt;/code&gt;.
&lt;/aside&gt;
&lt;p&gt;Putting it all together:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;positionOf ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Character&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Position&lt;/span&gt;
positionOf p c &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; c &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;  &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; positionFromCount &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; length &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; p
    c       &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; positionFromCount &lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt; length &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; filter (&lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; c) p
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        positionFromCount n &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; even n      &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;West&lt;/span&gt;
                            &lt;span class=&quot;fu&quot;&gt;|&lt;/span&gt; othherwise  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is &lt;code&gt;positionFromCount . length $ p&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;In Haskell, the &lt;code&gt;(.)&lt;/code&gt; operator represents function composition. &lt;code&gt;(f . g) x&lt;/code&gt; is equivalent to &lt;code&gt;f (g x)&lt;/code&gt;. “Apply &lt;code&gt;g&lt;/code&gt; first, then apply &lt;code&gt;f&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;Also recall that you can think of &lt;code&gt;$&lt;/code&gt; as adding an implicit parentheses around both sides of it. You visualize it like the spine of a butterfly — the “wings” are wrapped parentheses around either side of it. In that sense, &lt;code&gt;f . g $ x&lt;/code&gt; is the same as &lt;code&gt;(f . g) (x)&lt;/code&gt; (A rather lopsided butterfly).&lt;/p&gt;
&lt;p&gt;So, altogether, &lt;code&gt;positionFromCount . length $ p&lt;/code&gt; is the same as &lt;code&gt;(positionFromCount . length) p&lt;/code&gt;, which says “first, find the length of &lt;code&gt;p&lt;/code&gt;, then turn that length into a position.”&lt;/p&gt;
In the same way, &lt;code&gt;positionFromCount . length $ filter (== MoveThe c) p&lt;/code&gt; is &lt;code&gt;(positionFromCount . length) (filter (== MoveThe c) p)&lt;/code&gt; — find the length of the filtered list, then turn that length into a position. We use &lt;code&gt;$&lt;/code&gt; mostly because we don’t like writing parentheses everywhere when we don’t have to.
&lt;/aside&gt;
&lt;p&gt;Does this actually work? Let’s try out some examples.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;West&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;West&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It works! By the way, as an unrelated note, isn’t it cool that our &lt;code&gt;Plan&lt;/code&gt; literal reads a lot like English? MoveThe Goat, MoveThe Farmer, MoveThe Wolf…&lt;/p&gt;
&lt;h4 id=&quot;checking-the-path&quot;&gt;Checking the Path&lt;/h4&gt;
&lt;p&gt;Now we have to check that the plan is a solution.&lt;/p&gt;
&lt;p&gt;Simple — that means that all &lt;code&gt;Characters&lt;/code&gt; are on the east side.&lt;/p&gt;
&lt;p&gt;We can check this manually:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;isSolution ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
isSolution p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt;
    positionOf p &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hm. Rather ugly.&lt;/p&gt;
&lt;p&gt;We see a common pattern that we need &lt;code&gt;positionOf p c&lt;/code&gt; for all &lt;code&gt;c&lt;/code&gt;s. That looks like a map!&lt;/p&gt;
&lt;p&gt;We also compare all of them to &lt;code&gt;East&lt;/code&gt;. That sounds like a job for the prelude function &lt;code&gt;all :: (a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; Bool&lt;/code&gt;, which takes a predicate and a list and returns true if all items in the list satisfy the predicate.&lt;/p&gt;
&lt;p&gt;Let’s piece it all together:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;isSolution p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; all (&lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;East&lt;/span&gt;) positions
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        positions &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; map (positionOf p) [&lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; is probably the most ubiquitous concept in functional programming — it takes a function and a list and returns a new list with the function applied to every item.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;map f [x,y,z]&lt;/code&gt; = &lt;code&gt;[f x, f y, f z]&lt;/code&gt;. If we wanted to find the lengths of a list of strings, we’d do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map length [&lt;span class=&quot;st&quot;&gt;&amp;quot;alice&amp;quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&amp;quot;bob&amp;quot;&lt;/span&gt;]
&lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [length &lt;span class=&quot;st&quot;&gt;&amp;quot;alice&amp;quot;&lt;/span&gt;, length &lt;span class=&quot;st&quot;&gt;&amp;quot;bob&amp;quot;&lt;/span&gt;]
&lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So in our case:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;map (positionOf p) [&lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;]
&lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; [ positionOf p &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;         &lt;span class=&quot;co&quot;&gt;-- Position of the farmer&lt;/span&gt;
  , positionOf p &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- Position of the wolf&lt;/span&gt;
  , positionOf p &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- Position of the goat&lt;/span&gt;
  , positionOf p &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;-- Position of the cabbage&lt;/span&gt;
  ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/aside&gt;
&lt;p&gt;We use &lt;code&gt;[Farmer ..]&lt;/code&gt; as shorthand for &lt;code&gt;[Farmer, Wolf, Goat, Cabbage]&lt;/code&gt; — this is because &lt;code&gt;Character&lt;/code&gt; is an Enum, so it can be enumerated using enumeration syntax. It basically means “&lt;code&gt;Farmer&lt;/code&gt;, etc.”&lt;/p&gt;
&lt;h3 id=&quot;makemove&quot;&gt;makeMove&lt;/h3&gt;
&lt;p&gt;So let’s get down to the meat of our journey. How do we make a move?&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;makeMove ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;makeMove&lt;/code&gt; will be a function that takes a plan and returns all the successful ways you can add a move to that plan. It takes a plan and takes it through a journey of adding a move, and returns the results of all of the successful ways it can fulfill this journey. This is similar to our old &lt;code&gt;halveOrDouble :: Int -&amp;gt; [Int]&lt;/code&gt;, which takes an int and returns the successful paths our int could have taken (it could have been halved…or doubled).&lt;/p&gt;
&lt;p&gt;What does a plan have to “go through” in its journey in adding a move?&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;First, we get the move we want to add. We could pick a &lt;code&gt;MoveThe Farmer&lt;/code&gt;, a &lt;code&gt;MoveThe Goat&lt;/code&gt;, or anything!&lt;/li&gt;
&lt;li&gt;Then, we fail/end the journey if we pick a move that isn’t legal. For example, we can’t move the goat if the farmer is not on the same side of the river that the goat is on.&lt;/li&gt;
&lt;li&gt;Now, we add that move that we got to the plan.&lt;/li&gt;
&lt;li&gt;Then, we fail/end the journey if that new plan is “unsafe” — if it leaves either the Wolf and Goat alone on a riverbank or the Goat and Cabbage.&lt;/li&gt;
&lt;li&gt;At the end of it all, we succeed with the new plan.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let’s try this out:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;moveLegal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;           &lt;span class=&quot;co&quot;&gt;-- 1&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;safePlan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;makeMove ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt;]
makeMove p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
    next &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;] &lt;span class=&quot;co&quot;&gt;-- 2&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; moveLegal p next                &lt;span class=&quot;co&quot;&gt;-- 3&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt;
        p&amp;#39; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; p &lt;span class=&quot;fu&quot;&gt;++&lt;/span&gt; [next]                    &lt;span class=&quot;co&quot;&gt;-- 4&lt;/span&gt;
    guard &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; safePlan p&amp;#39;                     &lt;span class=&quot;co&quot;&gt;-- 5&lt;/span&gt;
    return p&amp;#39;                               &lt;span class=&quot;co&quot;&gt;-- 6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Here are the types of the helper functions we will be using.&lt;/li&gt;
&lt;li&gt;In this context, &lt;code&gt;MoveThe &amp;lt;$&amp;gt;&lt;/code&gt; means to apply &lt;code&gt;MoveThe&lt;/code&gt; to whatever we choose out of &lt;code&gt;[Farmer .. Cabbage]&lt;/code&gt;. Kind of an “intercept it on the way out, and turn it into a Move”. So &lt;code&gt;next&lt;/code&gt; is &lt;code&gt;MoveThe Farmer&lt;/code&gt; or &lt;code&gt;MoveThe Wolf&lt;/code&gt;, etc.; &lt;code&gt;next&lt;/code&gt; is &lt;em&gt;one&lt;/em&gt; of those. For every journey, we pick &lt;em&gt;one&lt;/em&gt; of the possible moves.&lt;/li&gt;
&lt;li&gt;We insta-fail if the move is not legal with the given plan. By this, we mean that we can’t possibly move an animal unless the farmer is on the same side as the animal.&lt;/li&gt;
&lt;li&gt;Let’s let &lt;code&gt;p&#39;&lt;/code&gt; be &lt;code&gt;next&lt;/code&gt; appended to the original plan &lt;code&gt;p&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We insta-fail unless the new plan is safe.&lt;/li&gt;
&lt;li&gt;If we haven’t failed yet, then we succeed with the new plan as the result.&lt;/li&gt;
&lt;/ol&gt;
&lt;aside&gt;
&lt;pre&gt;&lt;code&gt;###### Welcome to Haskell!&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, so I was slightly hand-wavey with &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt;. But it is true that something like:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;x &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will put 6 (&lt;code&gt;3 * 2&lt;/code&gt;) into &lt;code&gt;x&lt;/code&gt; — it’ll take out the 3 and then apply &lt;code&gt;(*2)&lt;/code&gt; to it before storing it in &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What’s going on under the hood is actually less magical. &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; basically says “apply inside”. It is like &lt;code&gt;$&lt;/code&gt;, but “inside”. Remember how we can do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to apply &lt;code&gt;(*2)&lt;/code&gt; to 3? We can then also do:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, if we think of a List like a list of possible successes, then applying a function “inside” means applying the function to all of the possible successes:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;]
[&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]

λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;]
[&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So when I say&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;next &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I really mean&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;next &lt;span class=&quot;ot&quot;&gt;&amp;lt;-&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
But still, it sometimes is cool to think of it as “Get the item inside, and then apply this function to it before you bind it to your variable”, if only for funsies.
&lt;/aside&gt;
&lt;h4 id=&quot;thought-experiment&quot;&gt;Thought experiment&lt;/h4&gt;
&lt;p&gt;So let’s say our plan is, currently, &lt;code&gt;[MoveThe Goat, MoveThe Farmer, MoveThe Wolf]&lt;/code&gt;. At the end of it all, our goat, wolf, and farmer are on the east bank, and the cabbage is on the west bank.&lt;/p&gt;
&lt;p&gt;What happens on a typical journey of &lt;code&gt;makeMove&lt;/code&gt;?&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;First, we pick something to move. Let’s say &lt;code&gt;next&lt;/code&gt; is &lt;code&gt;MoveThe Farmer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This move is legal (moving the farmer is always legal).&lt;/li&gt;
&lt;li&gt;Our new plan is &lt;code&gt;[MoveThe Goat, MoveThe Farmer, MoveThe Wolf, MoveThe Farmer]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;This plan is not safe. If we move the farmer, the goat and the wolf will be alone, and that is bad news for the goat. We fail at the second guard.&lt;/li&gt;
&lt;li&gt;We don’t return anything, because this journey is a total and utter failure.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Huh. How unfortunate. Let’s try again with another pick for &lt;code&gt;next&lt;/code&gt;:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Let’s pick &lt;code&gt;MoveThe Cabbage&lt;/code&gt; this time for &lt;code&gt;next&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This move isn’t even legal! The cabbage is on the west bank but the farmer is on the east. Failure!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Well, that’s kind of depressing. Let’s try another:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;We pick &lt;code&gt;MoveThe Goat&lt;/code&gt; for &lt;code&gt;next&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This move is legal; both the goat and the farmer are on the east bank.&lt;/li&gt;
&lt;li&gt;Our new plan is &lt;code&gt;[MoveThe Goat, MoveThe Farmer, MoveThe Wolf, MoveThe Goat]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;This plan is indeed safe. The goat and the cabbage are now on the west bank, but so is the farmer.&lt;/li&gt;
&lt;li&gt;Because all is well, we return our new plan!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hooray!&lt;/p&gt;
&lt;p&gt;As an exercise, see how the journey fares if we had picked &lt;code&gt;MoveThe Wolf&lt;/code&gt; for &lt;code&gt;next&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyways, at the end of it all, &lt;code&gt;makeMove&lt;/code&gt; will return all new plans from the successful journeys. So it won’t be returning the plans with &lt;code&gt;MoveThe Farmer&lt;/code&gt; and &lt;code&gt;MoveThe Cabbage&lt;/code&gt; added to it, but will likely be retuning the plans with &lt;code&gt;MoveThe Goat&lt;/code&gt; and &lt;code&gt;MoveThe Wolf&lt;/code&gt; added to it. And it’ll return those two together in a List structure.&lt;/p&gt;
&lt;p&gt;We’re almost there! Now to just define our helper predicates &lt;code&gt;moveLegal&lt;/code&gt; and &lt;code&gt;safePlan&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;movelegal&quot;&gt;moveLegal&lt;/h4&gt;
&lt;p&gt;What makes a move legal? Well, the farmer has to be on the same side as whatever is being moved.&lt;/p&gt;
&lt;p&gt;We can re-use our &lt;code&gt;positionOf :: Plan -&amp;gt; Character -&amp;gt; Position&lt;/code&gt; function here.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;moveLegal ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Move&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
moveLegal p (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;)  &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;True&lt;/span&gt;
moveLegal p (&lt;span class=&quot;dt&quot;&gt;MoveThe&lt;/span&gt; c)       &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; positionOf p c &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;safeplan&quot;&gt;safePlan&lt;/h4&gt;
&lt;p&gt;One last piece. How can we tell if a plan is safe or not?&lt;/p&gt;
&lt;p&gt;The plan is safe if nothing can eat anything else. That means if the wolf and goat or goat and cabbage sit on the same bank, so too must the farmer. Some boolean arithmetic will show that this is the same as if either the farmer is on the same side as the goat or the goat and cabbage are both “safe” (not on the side of their predators).&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;safePlan ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Plan&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Bool&lt;/span&gt;
safePlan p &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; goatPos &lt;span class=&quot;fu&quot;&gt;==&lt;/span&gt; farmerPos &lt;span class=&quot;fu&quot;&gt;||&lt;/span&gt; safeGoat &lt;span class=&quot;fu&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; safeCabbage
    &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt;
        goatPos     &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Goat&lt;/span&gt;
        farmerPos   &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Farmer&lt;/span&gt;
        safeGoat    &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; goatPos &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Wolf&lt;/span&gt;
        safeCabbage &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; positionOf p &lt;span class=&quot;dt&quot;&gt;Cabbage&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;/=&lt;/span&gt; goatPos&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that’s it! We finished!&lt;/p&gt;
&lt;h4 id=&quot;exercise&quot;&gt;Exercise&lt;/h4&gt;
&lt;p&gt;Notice that sometimes we are going to make “redundant moves”. For example, we could move the farmer or goat twice in a row. How can we add another guard to check if the move isn’t redundant? That is, that the move we are adding isn’t identical to the last move of the plan?&lt;/p&gt;
&lt;p&gt;The implementation is in the final solution later on, but think about how you would do it and compare the final solution to yours!&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;The final code for this project is available &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/WolfGoatCabbage.hs&quot;&gt;on Github&lt;/a&gt; so you can follow along yourself. You can also &lt;a href=&quot;https://www.fpcomplete.com/user/jle/wolf-goat-cabbage&quot;&gt;load it interactively online&lt;/a&gt; on FPComplete, a great online Haskell IDE where you can test your code right there in the browser.&lt;/p&gt;
&lt;p&gt;So…let’s test it!&lt;/p&gt;
&lt;h3 id=&quot;tests&quot;&gt;Tests&lt;/h3&gt;
&lt;p&gt;First, let’s load it up on ghci:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt;l WolfGoatCabbage.hs
&lt;span class=&quot;dt&quot;&gt;Ok&lt;/span&gt;, modules loaded&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s try a few plan lengths and see when we get one that has a valid solution:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; findSolutions &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;
[]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; findSolutions &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;
[]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; findSolutions &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;
[[&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;],[&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Great, we have two solutions of length 7. If we try them out, it seems like they both work! Notice that, interestingly enough, the two solutions are their own reverses. This makes sense, because any solution of getting from the west bank to the east bank must also be, backwards, a valid solution of getting from the east bank to the west bank.&lt;/p&gt;
&lt;p&gt;It turns out that the solutions of length 9 and 11 are both identical to the solutions for length 7, just with some redundant moves thrown in (moving the farmer twice in a row, moving the goat twice in a row, etc.). Also, note that all possible solutions are of odd lengths, because for even lengths, the farmer ends up on the west bank.&lt;/p&gt;
&lt;p&gt;If we add the filter on redundant moves mentioned earlier, the next valid solutions with no direct redundancies come at length 13, and then at 19:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; findSolutions &lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;
[[&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;]
,[&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;]]
λ&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; findSolutions &lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;
[[&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;]
,[&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;C&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;W&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;F&lt;/span&gt;,&lt;span class=&quot;dt&quot;&gt;G&lt;/span&gt;]]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again note that both of these solutions come in pairs, with one being the reverse of the other. Also curious is the fact that they are actually identical to the length 7 solutions, just with cycles of &lt;code&gt;W,G,C&lt;/code&gt; (or &lt;code&gt;C,G,W&lt;/code&gt;) over and over again in the middle.&lt;/p&gt;
&lt;h3 id=&quot;reflections&quot;&gt;Reflections&lt;/h3&gt;
&lt;p&gt;We have solved the classic logic puzzle without using any control flow other than the List’s MonadPlus instance. The solution isn’t necessarily optimal, but it is interesting that we can model something like this simply as saying: “Here is the description of a journey. What journeys following this description succeed?”&lt;/p&gt;
&lt;p&gt;With the List MonadPlus, you can solve any problem that can be described as the result of a nondeterministic journey with choices and pitfalls along the way.&lt;/p&gt;
&lt;p&gt;In this particular puzzle, you could have done something similar from the start using only maps and filters. However, sometimes it is more useful or more insightful to, instead of using maps and filters, use abstractions that help you frame the problem in a more meaningful way.&lt;/p&gt;
&lt;p&gt;Hopefully as a result of this three part series and through playing around with the source code, you can appreciate the wonders of Succeed/Fail and MonadPlus!&lt;/p&gt;
&lt;h3 id=&quot;the-future&quot;&gt;The future&lt;/h3&gt;
&lt;p&gt;Where to go from here? You might want to take a look at the &lt;a href=&quot;http://hackage.haskell.org/package/base/docs/Control-Applicative.html&quot;&gt;Alternative&lt;/a&gt; typeclass/design pattern, which also deals with the concept of success/failure — just not with their consecutive chaining, like MonadPlus. It deals with their parallel choices, actually, as the name implies. This functionality is redundantly implemented in MonadPlus in Haskell today (2013), and the parallel-choice operator &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; for Alternative is &lt;code&gt;mplus&lt;/code&gt; for MonadPlus. I might write something on the matter some day. Anyways, learning about Alternative will help you see more about the usefulness of the success/fail design pattern, and it might help you gain the perspective which much of the early Haskell implementors apparently lacked: not everything is a monad!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;You might be aware that in the current Haskell standard library organization, the implementation of MonadPlus also provides separate functionality — the “Plus”. We won’t be focusing on this part, because it is commonly regarded that it is more of a characteristic of the &lt;em&gt;Alternative&lt;/em&gt; typeclass/design pattern. For the purposes of this article, MonadPlus is essentially “MonadZero”, as it should have been.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/wolf-goat-cabbage-the-list-monadplus-logic-problems.html</guid><pubDate>Thu, 26 Dec 2013 19:43:50 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2013-12-26</dc:date></item><item><title>The Compromiseless Reconciliation of I/O and Purity</title><link>http://home.jle0.com:4111/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html</link><description>&lt;p&gt;One of the crazy ideals of functional programming is the idea that your program is simply a list of definitions of mathematical functions. And like real math functions, FP functions are &lt;strong&gt;pure&lt;/strong&gt;. That means that (1) they cannot affect any state, and (2) that they must return the same thing every time they are called with the same arguments.&lt;/p&gt;
&lt;p&gt;When you first learn functional programming, this manifests as “your variables are immutable and you can’t do loops; use recursion instead.” And if you do that, everything is “fine”.&lt;/p&gt;
&lt;p&gt;However, there is an apparent glaring problem with this adherence to purity: &lt;strong&gt;I/O&lt;/strong&gt;. Input and output are inherently stateful.&lt;/p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;For the obvious (input) example, consider &lt;code&gt;getchar()&lt;/code&gt; in C. It returns the character that a user enters. Obviously, if &lt;code&gt;getchar()&lt;/code&gt; returned the same thing every time, you’d have an extraordinarily useless function. Input &lt;em&gt;inherently violates&lt;/em&gt; purity, it seems. (Also, consider a &lt;a href=&quot;http://xkcd.com/221/&quot;&gt;function generating random numbers&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;The idea of output violates purity as well. Consider calling &lt;code&gt;printf()&lt;/code&gt; in C. You’re going to change the state of the terminal. A benign example, of course; but what about a function &lt;code&gt;add_database_row()&lt;/code&gt; that adds a row to your database? A call of &lt;code&gt;get_database_row()&lt;/code&gt; will now return something different than it would have returned before. &lt;code&gt;get_database_row()&lt;/code&gt; now returns two different things when run at two different times — impure! Blasphemy!&lt;/p&gt;
&lt;p&gt;Of course, it should be obvious that not being able to perform IO means that your program is essentially useless in most real world applications. But purity is pretty cool, and it gives us guarantees that let us &lt;a href=&quot;http://u.jle.im/19JxV5S&quot;&gt;reason with our code&lt;/a&gt; in ways that are impossible with impure code, and with unprecedented safety. It opens the doors to previously inaccessible models of parallel, concurrent, and distributed programming. It allows the compiler to do crazy optimization tricks. It allows for powerful mathematical analysis of our programs. The full benefits of purity are beyond the scope of this article, but you can trust me when they say that they are too much to give up over a technicality.&lt;/p&gt;
&lt;p&gt;So how can we reconcile the idea of a pure language with &lt;del&gt;anything useful&lt;/del&gt; I/O?&lt;/p&gt;
&lt;h2 id=&quot;a-functional-program&quot;&gt;A Functional “Program”&lt;/h2&gt;
&lt;h3 id=&quot;declarations&quot;&gt;Declarations&lt;/h3&gt;
&lt;p&gt;Let’s look at an almost-typical Haskell program.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;--  factorial n: n!&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;factorial ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
factorial &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
factorial n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; n &lt;span class=&quot;fu&quot;&gt;*&lt;/span&gt; factorial (n&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;--  fib n: the nth Fibonacci number&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;fib ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;
fib &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
fib &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
fib n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; fib (n&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;fu&quot;&gt;+&lt;/span&gt; fib (n&lt;span class=&quot;fu&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;--  first_n_fibs n: a list of the first n Fibonacci numbers&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;first_n_fibs ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt;]
first_n_fibs n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; map fib [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;..&lt;/span&gt;n]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One of the first things you should notice is that this looks strikingly similar to a list of math equations…and almost not like a program.&lt;/p&gt;
&lt;p&gt;Notice one important thing about this (at least, in Haskell): there is no inherent ordering in any of these statements. By this, I mean that &lt;code&gt;factorial&lt;/code&gt;, &lt;code&gt;fib&lt;/code&gt;, and &lt;code&gt;first_n_fibs&lt;/code&gt; can be defined in any order. When you write declarations of mathematical objects on paper, the order in which you declare them should have no bearing on what they represent. These are functions. Immortal, unchanging, ethereal, separate from time and space. It is simply nonsensical to talk about order in this context.&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;!-- Thanks to evincarofautum of reddit for pointing out that the ordering of the --&gt;
&lt;!-- pattern matches in this example actually do matter. --&gt;
&lt;p&gt;Also note that these declarations don’t always declare integers/numbers. &lt;code&gt;first_n_fibs&lt;/code&gt; actually declares a data structure — a list that contains integers. Of course this is no big problem…mathematical functions can map integers to matrices, or matrices to functions, anything you can think of. We aren’t limited to simply defining primitive things. We can also define structures that contain things.&lt;/p&gt;
&lt;p&gt;Of course, this “program” doesn’t actually &lt;em&gt;do&lt;/em&gt; anything. Let’s look at some more programs and see if we can address this.&lt;/p&gt;
&lt;h3 id=&quot;representing-actions&quot;&gt;Representing Actions&lt;/h3&gt;
&lt;p&gt;There are a lot of data structures/data types that may be expressed in Haskell. One in particular is called &lt;code&gt;IO&lt;/code&gt;. &lt;code&gt;IO a&lt;/code&gt; represents a computation that returns something of type &lt;code&gt;a&lt;/code&gt;. There are a couple of pre-packaged computations included in the standard library. Let’s write another almost-typical Haskell program with some.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;--  getStringFromStdin: returns a computation that represents the act of&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      getting a string from stdin.  or rather, a series of instructions on&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      interacting with the computer and generating a String.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getStringFromStdin ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
getStringFromStdin &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getLine

&lt;span class=&quot;co&quot;&gt;--  printFibN: returns a computation that represents the act of printing the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      nth Fibonacci number to stdout and returns () (Nothing).  or rather,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      a series of instruction on interacting with the computer to get it to&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      print a Fibonacci number and returning nothing.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;printFibN ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
printFibN n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print (fib n)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s look at these.&lt;/p&gt;
&lt;p&gt;These are simply functions/declarations, just like the ones above. Although instead of returning an integer or a list data structure, it returns a special data structure that represents a computation. &lt;code&gt;[a]&lt;/code&gt; represents a list of &lt;code&gt;a&lt;/code&gt;’s. &lt;code&gt;IO a&lt;/code&gt; represents an abstract computation (or a series of system instructions) that returns an &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These declarations and functions are also simply “math” functions. Instead of returning a set or a matrix or a vector, it returns another type of object.&lt;/p&gt;
&lt;p&gt;Note that this has nothing to do with execution. &lt;code&gt;printFibN&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; execute a print statement. No more than writing &lt;code&gt;printFibN&lt;/code&gt; on a piece of paper will cause it to magically evaluate. It does not execute anything: it is simply an abstract data structure representing a computation.&lt;/p&gt;
&lt;p&gt;Note again that there is no inherent ordering involved. Whether you define one or the other first, it does not change what the two names really &lt;em&gt;represent&lt;/em&gt;. Just like if you defined two matrices on a piece of paper in a different order, it does not change the matrices they represent.&lt;/p&gt;
&lt;p&gt;Also note that all of these declarations are completely pure. &lt;code&gt;getStringFromStdin&lt;/code&gt; will return the exact same &lt;em&gt;representation of a computation&lt;/em&gt; every single time. &lt;code&gt;printFibN n&lt;/code&gt; will return the exact same &lt;em&gt;computation representation&lt;/em&gt; for every &lt;code&gt;n&lt;/code&gt; every single time. The exact same instruction sequence every single time for every &lt;code&gt;n&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And yes, the objects themselves don’t actually execute anything. That’s like saying writing down a matrix executes something in the real world.&lt;/p&gt;
&lt;h3 id=&quot;data-structures-not-commands&quot;&gt;Data Structures, Not Commands&lt;/h3&gt;
&lt;p&gt;To illustrate the difference between a data structure representing a computation and a computation itself, let’s look at a possible confusion that might arise from mixing up the two.&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;getStringAndPrint ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
getStringAndPrint &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print (getStringFromStdin)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What would you expect to happen here?&lt;/p&gt;
&lt;p&gt;Remember, &lt;code&gt;print&lt;/code&gt; is an IO instruction prints out what it is passed. &lt;code&gt;getStringFromStdin&lt;/code&gt; is a computation object that gives a string when executed.&lt;/p&gt;
&lt;p&gt;In another language, which deals with computations (and not representations of them), you would expect it to get a string from stdin and then print it. Sort of like an echo.&lt;/p&gt;
&lt;p&gt;However, this is not the case in Haskell. What is &lt;code&gt;getStringFromStdin&lt;/code&gt;? It is &lt;em&gt;not&lt;/em&gt; a string — it is a computation object.&lt;/p&gt;
&lt;p&gt;What will happen is that &lt;code&gt;print&lt;/code&gt; (when executed by a computer) won’t print the result of &lt;code&gt;getStringFromStdin&lt;/code&gt;. &lt;code&gt;print&lt;/code&gt; will print out the &lt;strong&gt;representation of the computation&lt;/strong&gt;! It’ll print out the &lt;em&gt;data structure representing the computation&lt;/em&gt;, or some string “representing” the act of the computation!&lt;/p&gt;
&lt;p&gt;(At least, that’s what it’s supposed to do. Unfortunately, &lt;code&gt;IO&lt;/code&gt; data structures do not come built-in with a method for their string representation in vanilla Haskell. But the point remains that &lt;code&gt;print&lt;/code&gt; would &lt;em&gt;try&lt;/em&gt; to print out the data structure itself somehow, and not the actual result of the computation)&lt;/p&gt;
&lt;h2 id=&quot;instructions-as-data-structures&quot;&gt;Instructions as Data Structures&lt;/h2&gt;
&lt;p&gt;Let’s take a step back and think about what it even means to have a data structure representing computation.&lt;/p&gt;
&lt;p&gt;You can think about it as some kind of list/nested tree (or more accurately, a graph) of instructions for someone to follow. For the case of &lt;code&gt;IO Int&lt;/code&gt;, you can see it as, internally, some kind of tree/nested instruction set for someone to follow in order to produce an &lt;code&gt;Int&lt;/code&gt;. In the case of &lt;code&gt;IO&lt;/code&gt;, for GHC, the “someone” is a computer. Or more specifically, a processor. GHC directly translates any standalone IO object into assembly code (or even a less optimal C code).&lt;/p&gt;
&lt;p&gt;Technically, you &lt;em&gt;could&lt;/em&gt; “think” of every IO object as a self-contained and encapsulated little packet of assembly or C code that you can compose and nest and merge, etc. with other such packets, without worrying about the lower level code itself. But don’t do this, or you risk confusing a possible representation of an object for the actual abstract object itself. (Think about it like saying that a mathematical matrix is a series of pencil swirls on a piece of paper.) But yes, at any time, you can “compile”/make concrete an IO object into standalone C code with GHC. This is actually a fact, and every IO object can be said to correspond directly with a chunk of C code.&lt;/p&gt;
&lt;p&gt;Really, though, there are many ways to “translate” this data structure into instructions for anyone to follow. &lt;a href=&quot;http://hackage.haskell.org/package/haste-compiler&quot;&gt;Haste&lt;/a&gt;, for example, takes &lt;code&gt;IO&lt;/code&gt; data structure and turns it into something that can be run in a Javascript interpreter. That is, it takes something like &lt;code&gt;printFibN n&lt;/code&gt;, takes the internal tree instruction set, and writes it out concretely in javascript.&lt;/p&gt;
&lt;p&gt;In fact it would not be too hard to imagine a compiler that would take any arbitrary &lt;code&gt;IO&lt;/code&gt; structure and translate it into human-followable (yet very verbose) instructions on a piece of paper, written in plain English. Or French, for that matter.&lt;/p&gt;
&lt;p&gt;That is because that’s all &lt;code&gt;IO&lt;/code&gt; &lt;em&gt;is&lt;/em&gt; — a tree/graph data structure representing an instruction series, that we assemble/build/compose using Haskell code. The same way you would assemble/build an array, or a dictionary, or a linked list in any other language.&lt;/p&gt;
&lt;h3 id=&quot;other-examples&quot;&gt;Other Examples&lt;/h3&gt;
&lt;p&gt;It might help to think about similar “instruction-like” data structures.&lt;/p&gt;
&lt;p&gt;Take &lt;a href=&quot;http://hackage.haskell.org/package/persistent&quot;&gt;Persistent&lt;/a&gt;, which (in some variants) provides the &lt;code&gt;SqlPersistM&lt;/code&gt; data structure. This data structure represents an interaction with an SQL Database. In other words, it represents a tree of instructions for interacting with one. When you give it to the Persistent library, it’ll translate that &lt;code&gt;SqlPersistM&lt;/code&gt; into a series of &lt;strong&gt;SQL queries&lt;/strong&gt;! Yes, it produces actual SQL query strings, using the instructions from the data structure, executes them, and returns the result. An &lt;code&gt;SqlPersistM Int&lt;/code&gt; is an SQL interaction that returns an Int when run with the Persistent library.&lt;/p&gt;
&lt;p&gt;Then you have &lt;a href=&quot;http://hackage.haskell.org/package/parsec&quot;&gt;Parsec&lt;/a&gt;, which provides a &lt;code&gt;Parsec&lt;/code&gt; data structure, which are &lt;em&gt;instructions for Parsec to parse a string&lt;/em&gt;. A &lt;code&gt;Parsec Int&lt;/code&gt; structure&lt;a href=&quot;#fn2&quot; class=&quot;footnoteRef&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; represents instructions for parsing a string into an &lt;code&gt;Int&lt;/code&gt;. When you give a &lt;code&gt;Parsec Int&lt;/code&gt; and a string to parse to the Parsec library, it will run the parse specified by the &lt;code&gt;Parsec&lt;/code&gt; object and return (hopefully) a parsed &lt;code&gt;Int&lt;/code&gt;. Remember, a &lt;code&gt;Parsec Int&lt;/code&gt; object does &lt;em&gt;not&lt;/em&gt; actually “parse” anything; It is &lt;em&gt;used by Parsec&lt;/em&gt; to parse a string and return an &lt;code&gt;Int&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;The reason why we use these data structures in Haskell, instead of actually writing SQL queries and parsing rules from scratch, is because they become &lt;em&gt;composable&lt;/em&gt;. SQL queries? Not very composable. Parsing rules? Not exactly, either. In this way, you can build complex SQL queries without ever touching a query string by composing simple queries. You can create very complex and intricate parsing rules without every having to “worry” about actually writing the parser: you just compose simple, smaler parsers.&lt;/p&gt;
&lt;p&gt;And this is really what Haskell “does best” (and possibly what Haskell was really made for): assembling and composing these possibly complex instruction data structures in a pure way and “passing them on” to things that can take them and use them to do great things. An &lt;code&gt;SqlPersistM&lt;/code&gt; is used by Persistent, a &lt;code&gt;Parsec&lt;/code&gt; is used by Parsec, and an &lt;code&gt;IO&lt;/code&gt; is used by…well, what? A computer!&lt;/p&gt;
&lt;h2 id=&quot;the-main-point&quot;&gt;The “Main” Point&lt;/h2&gt;
&lt;p&gt;So now we see that Haskell has no problems returning a data structure that represents computer instructions (well, at least, Haskell’s standard library handles all of it for us by giving us useful instruction primitives that we can build more complex instructions from).&lt;/p&gt;
&lt;p&gt;Now we have an instruction object. How do we actually get a computer to use and execute it?&lt;/p&gt;
&lt;p&gt;For this, we rely on convention (or arbitrary specification, however you like to see it). A Haskell compiler will “understand” your data structures, and it picks &lt;strong&gt;one&lt;/strong&gt; of them to compile into a binary format for your computer (or whatever format your executing environment reads best). Out of all of the IO objects you can return/represent, the Haskell compiler chooses one of them to be the one it actually compiles into computer-readable code.&lt;/p&gt;
&lt;p&gt;And by convention/specification, it is the IO object with the name “main”:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;--  printFibN: returns a computation that represents the act of printing the&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      nth Fibonacci number to stdout and returns () (Nothing).&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;printFibN ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
printFibN n &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print (fib n)

&lt;span class=&quot;co&quot;&gt;--  main: The IO object that we agree that the compiler will actually compile.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; printFibN &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And here we are. A full, executable Haskell program. You can &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/io-purity/IO-Purity.hs&quot;&gt;download and run it yourself&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As we can see, every function or declaration that makes up our program is completely pure and side-effectless. In fact, the assembly of &lt;code&gt;main&lt;/code&gt; itself is side-effectless and pure. We assemble the &lt;code&gt;IO ()&lt;/code&gt; that &lt;code&gt;main&lt;/code&gt; returns in a pure way. &lt;code&gt;printFibN 10&lt;/code&gt; will return the exact same computation representation every single time we run it.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;printFibN 10&lt;/code&gt; is &lt;strong&gt;pure&lt;/strong&gt;. Every time we &lt;em&gt;evaluate&lt;/em&gt; &lt;code&gt;printFibN 10&lt;/code&gt;, we get the exact same computation representation/instruction list.&lt;/p&gt;
&lt;p&gt;Therefore, &lt;code&gt;main&lt;/code&gt; is pure, as well. Every time we evaluate &lt;code&gt;main&lt;/code&gt;, we get the exact same computational data structure.&lt;/p&gt;
&lt;h3 id=&quot;purity-challenged&quot;&gt;Purity challenged?&lt;/h3&gt;
&lt;p&gt;Now consider:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;co&quot;&gt;--  getStringFromStdin: returns a computation that represents the act of&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;--      getting a string from stdin&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;getStringFromStdin ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;String&lt;/span&gt;
getStringFromStdin &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getLine

&lt;span class=&quot;co&quot;&gt;--  main: The IO object that we agree that the compiler will actually compile.&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; getStringFromStdin &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (\result &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; print result)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Sample can be &lt;a href=&quot;https://github.com/mstksg/inCode/blob/master/code-samples/io-purity/Challenge.hs&quot;&gt;downloaded and run&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;(An aside: &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; here is an operator that takes the result of the left hand side’s computation and passes it as a parameter to the right hand side. Essentially, it turns two IO computation data structures and combines/chains them into one big one. The &lt;code&gt;(\x -&amp;gt; print x)&lt;/code&gt; syntax says “take the &lt;code&gt;x&lt;/code&gt; passed to you and use it in &lt;code&gt;print x&lt;/code&gt;”)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; gets something from the standard input, and then prints it.&lt;/p&gt;
&lt;p&gt;Oh wait. This means that if I type something different into standard input, the program will return something different, right? How is this pure?&lt;/p&gt;
&lt;p&gt;Here is the crucial difference between &lt;strong&gt;evaluation&lt;/strong&gt; and &lt;strong&gt;execution&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; will always &lt;strong&gt;evaluate&lt;/strong&gt; to the exact same computation data structure.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; will always be the &lt;em&gt;exact&lt;/em&gt; same program, no matter when you run it. (In particular, the program that gets a string from stdin and prints it)&lt;/p&gt;
&lt;p&gt;The computer/processor — which is given a binary representation of the IO data structure, and is completely separate from the language itself — now &lt;strong&gt;executes&lt;/strong&gt; this binary/compiled data structure/program. Its execution of this binary is, of course, potentially unpredictable and in general non-deterministic, and can depend on things like the temperature, the network connection, the person at the keyboard, the database contents, etc. The &lt;em&gt;instructions/binary&lt;/em&gt; that it follows will be the same every time. The &lt;em&gt;result&lt;/em&gt; of those instructions will be different every time (as someone who has ever attempted to bake a cake can testify).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; is a function that returns/evaluates deterministically to a data structure representing a computation.&lt;/p&gt;
&lt;p&gt;The computation that it represents is not necessarily deterministic.&lt;/p&gt;
&lt;p&gt;This distinction between &lt;strong&gt;evaluation&lt;/strong&gt; and &lt;strong&gt;execution&lt;/strong&gt; is what sets apart this I/O model that permits its purity.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; is a pure value. The instruction data structure &lt;code&gt;main&lt;/code&gt; represesents impure instructions.&lt;/p&gt;
&lt;p&gt;And &lt;em&gt;that&lt;/em&gt; is how we can deal with I/O in Haskell while remaining a pure language.&lt;/p&gt;
&lt;h3 id=&quot;illustrating-the-difference&quot;&gt;Illustrating the difference&lt;/h3&gt;
&lt;p&gt;To really understand the difference between evaluation and execution, let’s look at this example:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;ignoreAndSayHello ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
ignoreAndSayHello to_ignore &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; print &lt;span class=&quot;st&quot;&gt;&amp;quot;Hello!&amp;quot;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ignoreAndSayHello getStringFromStdin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What does this program do?&lt;/p&gt;
&lt;p&gt;Naively, we expect it to ask for a string from standard input, ignore the result, and print “Hello!”.&lt;/p&gt;
&lt;p&gt;Actually, this is &lt;strong&gt;not&lt;/strong&gt; what it does.&lt;/p&gt;
&lt;p&gt;This is because &lt;code&gt;ignoreAndSayHello getStringFromStdin&lt;/code&gt; will evaluate to &lt;code&gt;print &amp;quot;Hello&amp;quot;&lt;/code&gt; (remember, it ignores its argument). So &lt;code&gt;main&lt;/code&gt; evaluates to one single IO action: &lt;code&gt;print &amp;quot;Hello!&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So your program returns the simple IO action &lt;code&gt;print &amp;quot;Hello!&amp;quot;&lt;/code&gt; — the computation returned by &lt;code&gt;main&lt;/code&gt; therefore simply prints “Hello!”. This computation does not represent anything that would ask for input.&lt;/p&gt;
&lt;p&gt;The “real” way to do this would be:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;&lt;pre class=&quot;sourceCode haskell&quot;&gt;&lt;code class=&quot;sourceCode haskell&quot;&gt;&lt;span class=&quot;ot&quot;&gt;ignoreAndSayHello ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; a &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
ignoreAndSayHello to_ignore &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; to_ignore &lt;span class=&quot;fu&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (\result &lt;span class=&quot;ot&quot;&gt;-&amp;gt;&lt;/span&gt; print &lt;span class=&quot;st&quot;&gt;&amp;quot;Hello!&amp;quot;&lt;/span&gt;)

&lt;span class=&quot;ot&quot;&gt;main ::&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;IO&lt;/span&gt; ()
main &lt;span class=&quot;fu&quot;&gt;=&lt;/span&gt; ignoreAndSayHello getStringFromStdin&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; “combines” two IO objects into one. It returns a new IO object that takes the result of the left-hand side and uses it as an argument to the right hand side. Easy, right?&lt;/p&gt;
&lt;h2 id=&quot;ordering&quot;&gt;Ordering&lt;/h2&gt;
&lt;p&gt;One major implication that is apparent throughout this entire process is that statements in Haskell have &lt;strong&gt;no inherent order&lt;/strong&gt;. As we saw, we had a list of declaration of many different IO actions — none of which were necessarily evaluated or executed. There is no sense of “this function is ‘first’, this function is ‘second’”. Indeed, the idea of ordering makes no sense when you think of things as mathematical functions.&lt;/p&gt;
&lt;p&gt;While there is no “first” or “second”, there is a &lt;code&gt;main&lt;/code&gt;, which is the function the compiler/interpreter passes to the runtime environment as the computation we agree to run. “Order” arrives at this point. We explicity “create” an IO data structure and specify the ordering implicitly with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;. More specifically, &lt;code&gt;print&lt;/code&gt; requires the result of &lt;code&gt;getStringFromStdin&lt;/code&gt;, so there arises the first semblances of “ordering”: in the explicit composition of different IO actions into one big one.&lt;/p&gt;
&lt;p&gt;As it turns out, there is a &lt;a href=&quot;http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/&quot;&gt;nice blog post&lt;/a&gt; by Chris Taylor illustrating how this wordering ordering could be implemented in the internal data structure of IO.&lt;/p&gt;
&lt;p&gt;Long story short, &lt;code&gt;IO&lt;/code&gt;’s interface provides features to chain and combine IO actions into one big IO action, as we did before with &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;. This interface creates dependency trees in the internal IO data structure that enforces ordering.&lt;/p&gt;
&lt;p&gt;But the real story is that outside of the internals of a single &lt;code&gt;IO&lt;/code&gt;, there is no inherent ordering — not even between different &lt;code&gt;IO&lt;/code&gt; objects!&lt;/p&gt;
&lt;h2 id=&quot;resolution&quot;&gt;Resolution&lt;/h2&gt;
&lt;p&gt;In retrospect, the solution seems obvious. A functional program does what it does best — return an object, purely. This object is the actual computation itself, which can be pure or impure, deterministic or nondeterministic — we just pass it off, and the execution environment can do whatever it wants with it. Not our problem anymore! This is the difference between evaluation (the pure process) and execution (the impure one).&lt;/p&gt;
&lt;p&gt;We have the best of both worlds. Purity and…well, usefulness!&lt;/p&gt;
&lt;p&gt;In fact, because of how Haskell is structured…an impure function does not even make sense. How would one even write a traditional “impure” function in this language? The language itself is centered around the idea of composing computation instruction data types. What would an impure function even look like? Even if it were possible, impurity would be a jarring, unnatural adjustment to the language that doesn’t even really “make sense”.&lt;/p&gt;
&lt;p&gt;More importantly, however, there isn’t really any other way Haskell could handle this and still feel Haskell. The reason for this is that this is why Haskell succeeds where other languages struggle: Though we have only seen a glimpse of this in this in this article, Haskell provides very specialized tools for assembling and composing complex instruction data structures that make it extremely simple, expressive, and elegant. Tools for combining two parsing rules into one. Tools for combining two SQL operations into one. For a language that handles computational data structures so well, &lt;em&gt;not&lt;/em&gt; handling IO this way would be a real shame!&lt;/p&gt;
&lt;h3 id=&quot;why&quot;&gt;Why?&lt;/h3&gt;
&lt;p&gt;One might ask about the usefulness of this whole thing. After all, don’t most languages “compile” to the same assembly code every time? Why this game?&lt;/p&gt;
&lt;p&gt;The reason is that we can now deal with programs — entire chunks of assembly code — as first-class objects. You can pass in computational instruction objects to a function the same way you can pass any normal object. You can have two separate little “assembly code chunks” in complete isolation…and then you can combine them if you want, as well. You can easily introduce parallel forks — you can always pass in an “assembly code chunk”, so why not pass an IO object into a fork function? Every separate IO object is self-contained and manipulatable. This fact is also true for the other “instruction set”-like objects mentioned earlier. You can build them up and compose them and pass them as first-class things.&lt;/p&gt;
&lt;p&gt;And like we said before, you get all the benefits of &lt;a href=&quot;http://u.jle.im/19JxV5S&quot;&gt;equational reasoning&lt;/a&gt; because you’re dealing with pure “inert” compositions — this is something you could never get if you dealt with executing the actual functions themselves!&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;So, the astute reader will note that I am slightly blurring the line between purity and non-strictness/laziness. While it is true that pure languages can be strict, and ordering &lt;em&gt;can&lt;/em&gt; matter, this demonstration is to mostly illustrate that declarations of items and objects don’t &lt;em&gt;necessarily&lt;/em&gt; have to correspond to evaluation, execution and IO — an important point for the next section.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&quot;fn2&quot;&gt;&lt;p&gt;Technically, the full type would be &lt;code&gt;ParsecT s u m Int&lt;/code&gt;.&lt;a href=&quot;#fnref2&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/the-compromiseless-reconciliation-of-i-o-and-purity.html</guid><pubDate>Tue, 12 Nov 2013 19:37:27 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Haskell, Ramblings</dc:subject><dc:date>2013-11-12</dc:date></item><item><title>A Brief Primer on Classical and Quantum Mechanics for Numerical Techniques</title><link>http://home.jle0.com:4111/entry/a-brief-primer-on-classical-and-quantum-mechanics.html</link><description>&lt;p&gt;Okay! In this series we will be going over many subjects in both physics and computational techniques, including the Lagrangian formulation of classical mechanics, basic principles of quantum mechanics, the Path Integral formatulion of quantum mechanics, the Metropolis-Hastings Monte Carlo method, dealing with entropy and randomness in a pure language, and general principles in numerical computation! Fun stuff, right?&lt;/p&gt;
&lt;p&gt;The end product will be a tool for deriving the ground state probability distribution of arbitrary quantum systems, which is somewhat of a big deal in any field that runs into quantum effects (which is basically every modern field). But the real goal will be to hopefully impart some insight that can be applied to broarder and more abstract applications. I am confident that these techniques can be applied to many problems in computation to great results.&lt;/p&gt;
&lt;p&gt;I’m going to assume little to no knowledge in Physics and a somewhat intermediate working knowledge of programming. We’re going to be working in both my favorite imperative language and my favorite functional language.&lt;/p&gt;
&lt;p&gt;In this first post I’m just going to go over the basics of the physics before we dive into the simulation. Here we go!&lt;/p&gt;
&lt;h2 id=&quot;classical-mechanics&quot;&gt;Classical Mechanics&lt;/h2&gt;
&lt;h3 id=&quot;newtonian-mechanics&quot;&gt;Newtonian Mechanics&lt;/h3&gt;
&lt;p&gt;Mechanics has always been a field in physics that has held a special place in my heart. It is most likely the field most people are first exposed to in a physics course. To me, there really is no more fundamental and pure form of physics. I mean…it’s the study of how things move under forces. How can you get any deeper to the heart of physics than that?&lt;/p&gt;
&lt;p&gt;When most people think of mechanics, they think of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt;, inertia, and that every reaction has an equal and opposite re-action. These are Newton’s “Laws of Motion” and they provide what can be referred to as a “state-updating function”: Given a state of the world at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0&quot; alt=&quot;t_0&quot; title=&quot;t_0&quot; /&gt;, Newton’s laws can be used to “generate” the state of the world at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0%20%2B%20%5CDelta%20t&quot; alt=&quot;t_0 + \Delta t&quot; title=&quot;t_0 + \Delta t&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;This sounds pretty useful, but it wasn’t long before physicists began wishing they had other tools with which to study the mechanics of certain systems. Newton’s equations worked very well for the cases that made it famous, but were surprisingly unuseful, impractical, or clumsy in many others. And when we talk about relativity, where things like &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5CDelta%20t&quot; alt=&quot;\Delta t&quot; title=&quot;\Delta t&quot; /&gt; can’t even be trivially defined, it is almost completely useless without complicated modifications.&lt;/p&gt;
&lt;p&gt;So it was almost exactly one hundred years after Newton’s laws that two people named &lt;a href=&quot;http://en.wikipedia.org/wiki/Joseph-Louis_Lagrange&quot;&gt;Lagrange&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Leonhard_Euler&quot;&gt;Euler&lt;/a&gt; (who is the “e” in &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?e&quot; alt=&quot;e&quot; title=&quot;e&quot; /&gt;) followed a wild hunch that ended up paying off.&lt;/p&gt;
&lt;h3 id=&quot;lagrangian-mechanics&quot;&gt;Lagrangian Mechanics&lt;/h3&gt;
&lt;p&gt;To understand Lagrangian Mechanics, we must abandon our idea of “force” as the fundamental phenomenon. Instead of forces, we deal with “potential fields”.&lt;/p&gt;
&lt;p&gt;You can imagine potential fields as a roller coaster track, or as a landscape of rolling grassy hills. The height of a track or a landscape at that point corresponds to the value of the potential at that point. Potential fields work like this: Every object “wants” to go &lt;em&gt;downwards&lt;/em&gt; in a potential field — it will want to go in the direction (backwards/forwards for the roller coaster, north/south/east/west for the hilly landscape) that will take it downwards. We don’t care why, or how — it just “wants” to. And the steeper the downwardness, the greater the compulsion.&lt;/p&gt;
&lt;p&gt;We call this potential field &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?U%28%5Cvec%7Br%7D%29&quot; alt=&quot;U(\vec{r})&quot; title=&quot;U(\vec{r})&quot; /&gt;, which means “&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?U&quot; alt=&quot;U&quot; title=&quot;U&quot; /&gt; at the point &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cvec%7Br%7D&quot; alt=&quot;\vec{r}&quot; title=&quot;\vec{r}&quot; /&gt;”. (&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cvec%7Br%7D&quot; alt=&quot;\vec{r}&quot; title=&quot;\vec{r}&quot; /&gt; denotes a point in space)&lt;/p&gt;
&lt;p&gt;Relating this to &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt;, the force on the object is now equal to the steepness of the potential field at the point where the object is, and in the direction that would allow the object to go downwards in potential. Objects always wish to minimize their potential, and do so as fast as they can. In mathematical terminology, we say that &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%28%5Cvec%7Br%7D%29%20%3D%20-%20%5Cvec%7B%5Cnabla%7D%20U%28%5Cvec%7Br%7D%29&quot; alt=&quot;F(\vec{r}) = - \vec{\nabla} U(\vec{r})&quot; title=&quot;F(\vec{r}) = - \vec{\nabla} U(\vec{r})&quot; /&gt;.&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/path-integral-intro/potential3d.png&quot; title=&quot;An example of a 2D potential $U(\vec{r})$.&quot; alt=&quot;An example of a 2D potential U(\vec{r}).&quot; /&gt;&lt;figcaption&gt;An example of a 2D potential &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?U%28%5Cvec%7Br%7D%29&quot; alt=&quot;U(\vec{r})&quot; title=&quot;U(\vec{r})&quot; /&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
&lt;img src=&quot;/img/entries/path-integral-intro/gradient.png&quot; title=&quot;Top-down view of the potential in the previous figure, overlayed with arrows indicating the direction and magnitude of $F(\vec{r})$.&quot; alt=&quot;Top-down view of the potential in the previous figure, overlayed with arrows indicating the direction and magnitude of F(\vec{r}).&quot; /&gt;&lt;figcaption&gt;Top-down view of the potential in the previous figure, overlayed with arrows indicating the direction and magnitude of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%28%5Cvec%7Br%7D%29&quot; alt=&quot;F(\vec{r})&quot; title=&quot;F(\vec{r})&quot; /&gt;.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;Now, for Lagrangian Mechanics:&lt;/p&gt;
&lt;p&gt;Let’s say I tell you an object’s location at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0&quot; alt=&quot;t_0&quot; title=&quot;t_0&quot; /&gt;, and its location later at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_1&quot; alt=&quot;t_1&quot; title=&quot;t_1&quot; /&gt;, and the potential energy field. What path did that object take to get from point A to point B?&lt;/p&gt;
&lt;p&gt;A pretty open question, right? You don’t really have that much information to go off of. You just know point A and point B. It could have taken any path, for all we know! If we only knew &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt;, not only would we be at a complete loss at how to even start, but we wouldn’t even know if there was only one or even a hundred valid paths a particle could have taken.&lt;/p&gt;
&lt;p&gt;The solution to this problem is actually rather unexpected. Consider every single path/curve from point A to point B. Every single one. Now, assign each path a number known as the &lt;strong&gt;Action&lt;/strong&gt;:&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;For every point, add up the “Kinetic Energy” at that point, which, for classical mechanics, is the square of the object’s speed multiplied by &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cfrac%7B1%7D%7B2%7D%20m&quot; alt=&quot;\frac{1}{2} m&quot; title=&quot;\frac{1}{2} m&quot; /&gt;.&lt;/li&gt;
&lt;li&gt;For every point, add up &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?U%28%5Cvec%7Br%7D%29&quot; alt=&quot;U(\vec{r})&quot; title=&quot;U(\vec{r})&quot; /&gt; at that point.&lt;/li&gt;
&lt;li&gt;Subtract (2) from (1).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Think about every possible path. Calculate the action for each one. The path that the object takes is &lt;em&gt;the path with the lowest action&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It’s almost as if the object “does the math” in its head: “I’m going to go from here to there…let me calculate which path I can take has the lowest action. Okay, got it!”&lt;/p&gt;
&lt;p&gt;Lagrangian Mechanics provides for us a way to find out just what path an object must have taken to get from point A to point B.&lt;/p&gt;
&lt;p&gt;As it turns out, looking at things this way opens up entire worlds of understanding. For example, just from this, we find that &lt;em&gt;total energy is conserved&lt;/em&gt; over time for a closed system (trust me on this; the calculus is slightly tricky). We also have a formulation that works fine under Special Relativity in all frames of reference with almost no tweaks. And yes, if you actually do find the path of lowest action, the path will somehow magically always follow the state-updating equations &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt;. It’s just now we have a much more insighftul and meaningful way to look at the universe:&lt;/p&gt;
&lt;p&gt;Paths &lt;strong&gt;always attempt to minimize their action&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Okay. We don’t have that much time to spend on this, or its philosophical implications, so we’re going to move on now to Quantum Mechanics.&lt;/p&gt;
&lt;h2 id=&quot;quantum-mechanics&quot;&gt;Quantum Mechanics&lt;/h2&gt;
&lt;h3 id=&quot;schrödinger-formulation&quot;&gt;Schrödinger Formulation&lt;/h3&gt;
&lt;p&gt;If there was one thing that “everyone” knew about quantum mechanics, it would either be &lt;a href=&quot;http://en.wikipedia.org/wiki/Schr%C3%B6dinger&amp;#39;s_cat&quot;&gt;Scrödinger’s Cat&lt;/a&gt; or the fact that objects are no longer “for sure” anywhere. They are only &lt;em&gt;probably&lt;/em&gt; somewhere.&lt;/p&gt;
&lt;p&gt;How can we then analyze the behavior of &lt;em&gt;anything&lt;/em&gt;? If everything is just a probability, and nothing is certain, we can’t really use the same “state-updating functions” that we used to rely on, because the positions and velocities of the objects in question don’t even have well-defined values.&lt;/p&gt;
&lt;p&gt;Physicists’ first solutions involved creating a new “state” that did not involve particles at all. This “state” described the state of the universe, but not in terms of particles and positions and velocities. It is a new &lt;em&gt;abstract&lt;/em&gt; state. Then, they invented the equivalent of an &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt; for this abstract state — an equation that, for every abstract state at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0&quot; alt=&quot;t_0&quot; title=&quot;t_0&quot; /&gt;, gives you the abstract state at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0%20%2B%20%5CDelta%20t&quot; alt=&quot;t_0 + \Delta t&quot; title=&quot;t_0 + \Delta t&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;This approach is useful…just like &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt; was useful. But it inherits all of the problems of &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?F%20%3D%20m%20a&quot; alt=&quot;F = m a&quot; title=&quot;F = m a&quot; /&gt;. How can we apply what we learned about actions and Lagrangian mechanics to Quantum Mechanics? How do we make Lagrangian mechanics “quantum”?&lt;/p&gt;
&lt;h3 id=&quot;path-integral-formulation&quot;&gt;Path Integral Formulation&lt;/h3&gt;
&lt;p&gt;The answer is a bit simple, actually.&lt;/p&gt;
&lt;p&gt;Instead of saying “the object will chose the path with the least action”, we say &lt;strong&gt;the object chooses a random path, choosing lower-action paths more often&lt;/strong&gt;. That is, if an electron is shot from point A to point B, the electron picks a random path from point A to point B. It is a &lt;em&gt;weighted random choice&lt;/em&gt; based on the action of each path — if Path &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Calpha&quot; alt=&quot;\alpha&quot; title=&quot;\alpha&quot; /&gt; has lower action than Path &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cbeta&quot; alt=&quot;\beta&quot; title=&quot;\beta&quot; /&gt;, the electron will pick path &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Calpha&quot; alt=&quot;\alpha&quot; title=&quot;\alpha&quot; /&gt; more often than path &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cbeta&quot; alt=&quot;\beta&quot; title=&quot;\beta&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;There are some small technical differences (the process of calculating the action is slightly different, and you end up summing over complex numbers for certain reasons), but the fundamental principle remains the same.&lt;/p&gt;
&lt;p&gt;So say we have an electron floating around a hydrogen atom (a hydrogen atom creates a very pretty and easy to work with potential field). We know it is at point A at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0&quot; alt=&quot;t_0&quot; title=&quot;t_0&quot; /&gt;, and point B at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_1&quot; alt=&quot;t_1&quot; title=&quot;t_1&quot; /&gt;. What path did the electron take to get there?&lt;/p&gt;
&lt;p&gt;Simple: We don’t know. But we can say that it &lt;em&gt;probably&lt;/em&gt; took the path with the least action. It &lt;em&gt;could have also&lt;/em&gt; taken the path with the &lt;em&gt;second to least&lt;/em&gt; action…but that’s just slightly less likely. It &lt;em&gt;probably did not&lt;/em&gt; take the path with the greatest action…but who knows — it might have! It’s like it rolls a dice to determine which path it goes on, but the dice is weighted so that lower-action paths are rolled more often than higher-action paths.&lt;/p&gt;
&lt;p&gt;The electron &lt;em&gt;wants&lt;/em&gt; to take the lowest-action path…but sometimes decides not to.&lt;/p&gt;
&lt;p&gt;So now we see what Lagrangian Mechanics in classical mechanics really &lt;em&gt;is&lt;/em&gt;: It’s quantum mechanics, except that the lowest-action path is &lt;em&gt;so much likelier&lt;/em&gt; than any other path that we almost never see the second-to-least action path taken.&lt;/p&gt;
&lt;p&gt;As it turns out, like Lagrangian mechanics opened eyes to new worlds in classical mechanics, the Path Integral formulation&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; of quantum mechanics opened up totally new worlds that the previous “state updating formula” approach could have never dreamed of.&lt;/p&gt;
&lt;h2 id=&quot;implications&quot;&gt;Implications&lt;/h2&gt;
&lt;p&gt;Okay, so what does this all have to do with us?&lt;/p&gt;
&lt;p&gt;How many processes do we know that can be modeled by something trying to minimize itself, but not always succeeding? What data patterns can be unveiled by modeling things this way?&lt;/p&gt;
&lt;p&gt;I’ll leave this question slightly open-ended, but I’m also going to hint at the next installment’s contents.&lt;/p&gt;
&lt;h3 id=&quot;particle-in-a-potential&quot;&gt;Particle in a potential&lt;/h3&gt;
&lt;p&gt;Let’s go back again to our electron next to an atom. Let’s say that this electron will move around and return back to its current position at time &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?t_0%20%2B%20%5CDelta%20t&quot; alt=&quot;t_0 + \Delta t&quot; title=&quot;t_0 + \Delta t&quot; /&gt;, for very large &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5CDelta%20t&quot; alt=&quot;\Delta t&quot; title=&quot;\Delta t&quot; /&gt;. From what we learned, this electron can really take any path it wants, going anywhere in the universe and back again. Any closed loop that that zig zags or curls anywhere is a valid path.&lt;/p&gt;
&lt;p&gt;We can “pick” a random path, weighted by the action, and see where the electron goes in that path. See where we find the electron along points in the path. After many picks, we start seeing where the electron is “most likely to be”. We find the probability distribution of an electron in that potential.&lt;/p&gt;
&lt;p&gt;We now have a way, given any quantum potential, to find the probability distribution of a particle in that potential.&lt;/p&gt;
&lt;p&gt;From here we can also find the particle’s average energy, and many other properties of a particle given an arbitrary quantum potential.&lt;/p&gt;
&lt;p&gt;Now let’s implement it.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Why is it called the “Path Integral” formulation? When we add up something at every single point on a path, we are mathematically perfoming a “Path Integral”. So Path Integral Formulation means “physics based on the adding up stuff for every point on a path”.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Physics</category><category>Computation</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/a-brief-primer-on-classical-and-quantum-mechanics.html</guid><pubDate>Sat, 30 Nov 2013 00:32:12 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Physics, Computation</dc:subject><dc:date>2013-11-30</dc:date></item><item><title>Testing Math</title><link>http://home.jle0.com:4111/entry/ident/testing-math.html</link><description>&lt;p&gt;I’m a person. &lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?x%5E2&quot; alt=&quot;x^2&quot; title=&quot;x^2&quot; /&gt;.&lt;/p&gt;
&lt;p&gt;testing out some math&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csum_%7Bn%3D0%7D%5E%5Cinfty%20x%5E2&quot; alt=&quot;\sum_{n=0}^\infty x^2&quot; title=&quot;\sum_{n=0}^\infty x^2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Cint%20x%20dx&quot; alt=&quot;\int x dx&quot; title=&quot;\int x dx&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?e%5Ex%20%3D%20%5Csum_%7Bn%3D0%7D%5E%5Cinfty%20%5Cfrac%7Bx%5En%7D%7Bn%21%7D%20%3D%20%5Clim_%7Bn%5Crightarrow%5Cinfty%7D%20%281%2Bx%2Fn%29%5En&quot; alt=&quot;e^x = \sum_{n=0}^\infty \frac{x^n}{n!} = \lim_{n\rightarrow\infty} (1+x/n)^n&quot; title=&quot;e^x = \sum_{n=0}^\infty \frac{x^n}{n!} = \lim_{n\rightarrow\infty} (1+x/n)^n&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csum_%7Bn%3D0%7D%5E%5Cinfty%20%5Cfrac%7Bx%5En%7D%7Bn%21%7D%20%3D%20%5Clim_%7Bn%5Crightarrow%5Cinfty%7D%20%281%2Bx%2Fn%29%5En&quot; alt=&quot;\sum_{n=0}^\infty \frac{x^n}{n!} = \lim_{n\rightarrow\infty} (1+x/n)^n&quot; title=&quot;\sum_{n=0}^\infty \frac{x^n}{n!} = \lim_{n\rightarrow\infty} (1+x/n)^n&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;vertical-align:middle&quot; src=&quot;https://latex.codecogs.com/gif.latex?%5Csum_%7Bn%3D0%7D%5E%5Cinfty%20%5Cfrac%7Bx%5En%7D%7Bn%21%7D&quot; alt=&quot;\sum_{n=0}^\infty \frac{x^n}{n!}&quot; title=&quot;\sum_{n=0}^\infty \frac{x^n}{n!}&quot; /&gt;&lt;/p&gt;</description><author>Justin Le</author><category>Meta</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/ident/testing-math.html</guid><pubDate>Mon, 18 Nov 2013 22:30:44 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Meta</dc:subject><dc:date>2013-11-18</dc:date></item><item><title>The Hamster Hotel: An Introduction to Control Theory (Part 2)</title><link>http://home.jle0.com:4111/entry/the-hamster-hotel-an-introduction-to-control-theory-2.html</link><description>&lt;p&gt;As we left it off in &lt;a href=&quot;/entry/the-hamster-hotel-an-introduction-to-control-theory&quot;&gt;part 1&lt;/a&gt;, our elevator is still in trouble. You have an elevator for your humble hotel that consists of a plate being pushed up a shaft with a fountain of water where we can control the fountain strength, but you don’t really have any way to automate getting it to go to just the right height.&lt;/p&gt;
&lt;p&gt;You’ve tried writing down the proper fountain strengths for every floor, but changes in weight of the hamsters and lots of other factors make this unreliable. You’ve tried mathematically analyzing and accounting for all of these other factors, but not only is it impractical, but it can’t possibly account for dynamic changes in the system.&lt;/p&gt;
&lt;p&gt;Let’s take a look at a possible solution that might have some promise.&lt;/p&gt;
&lt;h2 id=&quot;i-detect-a-clue&quot;&gt;I Detect a Clue&lt;/h2&gt;
&lt;p&gt;You decide to put aside your elevator problems for now and focus on other aspects of your business. You do very well, actually, and your hotel grows to large acclaim in the hamster world. Still, you can’t help but be embarrassed every day when you explain that your elevator is still not adequately controllable.&lt;/p&gt;
&lt;p&gt;You gain enough revenue that you decide to try things again with a human factor. You hire an elevator boy.&lt;/p&gt;
&lt;p&gt;Your scheme is simple: have a little bell attached at the point where every elevator reaches the perfect height. Your elevator boy will turn the knob up, up, up until he hears the bell, and then stop it right after.&lt;/p&gt;
&lt;p&gt;The same thing works for going down – tell him to turn the knob down, down until he hears a bell.&lt;/p&gt;
&lt;p&gt;And suddenly, things seem to click.&lt;/p&gt;
&lt;h3 id=&quot;the-key&quot;&gt;The Key&lt;/h3&gt;
&lt;p&gt;This system accounts for all of the problems we ran into before. We have a human here who can account for everything. He makes all of the adjustments on the fly. He doesn’t need to know any exact percentages … he doesn’t need to worry about water pressure or friction or hamster weights, or any of that stuff. All he needs to know is “should I be increasing the flow, decreasing it, or leaving it alone?” So maybe the heavier hamsters get to their destinations slower — so what? You’ve discovered something amazing.&lt;/p&gt;
&lt;p&gt;The key difference here is the &lt;em&gt;detection&lt;/em&gt;. You are no longer thinking of a static system that will never change — you are constantly adjusting on the fly. You are doing things, detecting the reactions, and responding to those detections. In control theory, this difference is what we call &lt;strong&gt;feedback&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Feedback&lt;/em&gt; is the process of letting what you &lt;em&gt;observe&lt;/em&gt; from your changes affect what you &lt;em&gt;change next, on the fly&lt;/em&gt;&lt;/strong&gt;, which then affects what you &lt;em&gt;observe&lt;/em&gt;, etc. etc.&lt;/p&gt;
&lt;p&gt;And &lt;em&gt;this&lt;/em&gt; is the key.&lt;/p&gt;
&lt;p&gt;In control theory, this would be known as moving from an &lt;strong&gt;open loop&lt;/strong&gt; (where we don’t let what we observe affect what we change on-the-fly) to a &lt;strong&gt;closed loop&lt;/strong&gt; (where we do).&lt;/p&gt;
&lt;p&gt;Also note one other fundamental shift we just made: Based on what we observe, we &lt;em&gt;change&lt;/em&gt;. We no longer are finding out what we should &lt;em&gt;set&lt;/em&gt; — we are instead figuring out how we should &lt;em&gt;change&lt;/em&gt;. We don’t care about 10%, 20%, 30%, etc. anymore — we only care about twisting the knob &lt;em&gt;left&lt;/em&gt; or &lt;em&gt;right&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&quot;simple-improvements&quot;&gt;Simple Improvements&lt;/h3&gt;
&lt;p&gt;Still, this system isn’t perfect. Sometimes, if you forget to feed your elevator boy, he will accidentally miss the bell and overshoot slightly. No big deal. You attach some &lt;a href=&quot;http://www.snapcircuits.net/&quot;&gt;very simple electronics&lt;/a&gt; to your elevator shaft so that a &lt;em&gt;red&lt;/em&gt; light comes on if the elevator is too low, a &lt;em&gt;blue&lt;/em&gt; light comes on if it’s too high, and a &lt;em&gt;green&lt;/em&gt; light if it’s just right.&lt;/p&gt;
&lt;p&gt;Finally, with all of the electronics installed, your elevator boy knows three rules: increase the flow if the light is red, decrease the flow if it’s blue, and leave it constant if it’s green.&lt;/p&gt;
&lt;p&gt;Of course, you were hoping (from the beginning) to be able to do have this be done without human intervention.&lt;/p&gt;
&lt;p&gt;One day, you figure out that you can do the entire thing electronically. To save money, you fire your elevator boy and set up a motor to twist the knob. In addition to the lights, your circuit will also trigger the motor to loosen the valve (spin right) if the car is too low, tighten it (spin left) if it’s too high, and stop the motor when it is just right.&lt;/p&gt;
&lt;p&gt;Congratulations, you now have your very first automated closed feedback loop, known as the &lt;a href=&quot;http://en.wikipedia.org/wiki/Bang%E2%80%93bang_control&quot;&gt;bang–bang controller&lt;/a&gt;&lt;a href=&quot;#fn1&quot; class=&quot;footnoteRef&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With this in hand, you are sure to have no obstacles to firmly establishing your hamster hotel empire.&lt;/p&gt;
&lt;h3 id=&quot;problems-again&quot;&gt;Problems Again&lt;/h3&gt;
&lt;p&gt;Of course, our bang–bang controller is (as you might expect from the crudeness of the name) not exactly the be-all and end-all solution that control theory exists to provide.&lt;/p&gt;
&lt;p&gt;Let’s look at its shortcomings even in our simple scenario.&lt;/p&gt;
&lt;p&gt;In reality, the light will almost never be green for long. If a platform is properly aligned as a hamster steps on it, it will be nudged off balance. The light will immediately turn red, the motor will immediately adjust the jet and the car at full speed. This is felt as a “jitter” (Which, as I have on good word, is a particularly unpleasant sensation for a hamster.)&lt;/p&gt;
&lt;p&gt;Could you possibly make the “adjustment speed” slower? That is, could you slow down the speed that your motor runs at, so that the adjustment is slow enough as to not be felt as a rapid jitter?&lt;/p&gt;
&lt;p&gt;Well, you can! But if your motor is slow, it will actually take much too long to ever move anywhere. Perhaps the proper non-jittering motor speed is the same speed that would cause the car to take an hour to move up one story. Not acceptable!&lt;/p&gt;
&lt;p&gt;You either jitter, or you take too long to move anywhere. Whatever motor speed you choose will always have one problem or the other.&lt;/p&gt;
&lt;p&gt;Furthermore, here we assume that our motor can instantly react to the changes in the red/blue/green lights. However, real-world motors can’t simply change their direction immediately. Have you ever tried getting a car going 60 mph forwards to move 60 mph backwards instantly?&lt;/p&gt;
&lt;p&gt;Imagine applying this, then, to the elevator. It’ll move up, up, up, then notice that it’s at the right level. But before it can stop, it’s already too high. It starts turning the motor the other way, to go down, down at the same speed … it reaches the right level, but by the time it can stop, it’s too low.&lt;/p&gt;
&lt;p&gt;This idea of &lt;em&gt;overshoot&lt;/em&gt; will cause your elevator car to forever go up and down, bouncing up and down without ever settling on the green zone even once. This is because your motor only has one speed, and however much you overshoot going up, it’ll be exactly as much as you overshoot going down, and as much as you overshoot going up the next time.&lt;/p&gt;
&lt;p&gt;For now … you might just have to rehire your elevator boy.&lt;/p&gt;
&lt;h2 id=&quot;the-hamster-hole-grows-deeper&quot;&gt;The Hamster Hole Grows Deeper&lt;/h2&gt;
&lt;p&gt;Are these the last of our problems standing in the way of a fully automated control system? Well, if you’ve noticed one trend in this post, it might be that as soon as we conquer one problem … many others inevitably pop up. Any simple solution to these that you can think of now will have its own share of issues and problems.&lt;/p&gt;
&lt;p&gt;However, believe it or not, one day we will finally reach an end to this rat race and arrive at what is today known as the canonical “best” compromise for our system — the system that deals with all of the problems mentioned here, and nearly all of the problems that come up with the naive solutions of the ones we face now. The best we got. Not perfect — and not the best for many specific systems — but the best overall, general scheme for problems of this particular type.&lt;/p&gt;
&lt;p&gt;I’m saying this to prevent you from being weary. We may have come a long way, and there may be much more to tackle, but fear not — there is a satisfying end to this hamster hole.&lt;/p&gt;
&lt;p&gt;But first! How will we solve these fundamental problems — jittering and oscillation — of the bang–bang controller?&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&quot;fn1&quot;&gt;&lt;p&gt;Technically, it is a modified version of the bang–bang controller with an option for “don’t do anything” — a “bang–bang–shh”. A true bang–bang controller would not have the “green light” option.&lt;a href=&quot;#fnref1&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Engineering</category><category>Ramblings</category><guid isPermaLink="true">http://home.jle0.com:4111/entry/the-hamster-hotel-an-introduction-to-control-theory-2.html</guid><pubDate>Tue,  1 Oct 2013 19:47:41 UTC</pubDate><dc:creator>Justin Le</dc:creator><dc:subject>Engineering, Ramblings</dc:subject><dc:date>2013-10-01</dc:date></item><language>en</language><copyright>Copyright 2016 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Sat, 11 Feb 2017 06:06:47 UTC</lastBuildDate><generator>feed-0.3.11.1 (Sigbjorn Finne)</generator><image><url>http://home.jle0.com:4111/img/site_logo.jpg</url><title>in Code</title><link>http://home.jle0.com:4111/</link></image><dc:creator>Justin Le</dc:creator><dc:language>en</dc:language><dc:rights>Copyright 2016 Justin Le</dc:rights><dc:date>2017-02-11</dc:date><dc:description>Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge.</dc:description></channel></rss>