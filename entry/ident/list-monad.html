<!DOCTYPE HTML>
<html><head><title>Fun With MonadPlus: The Success/Failure Monads · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Monads. Haskell’s famous for them, but they are one of the most ill-understood concepts to the public. They are mostly shrouded in mystery because of their association with how Haskell models I/O. This reputation is undeserved. Monads don’t have anything to do with I/O. This series is a part of a global effort to deshroud the mystery behind monads and show that they are fun! And exciting! And really just a way of chaining together functions that allow for new ways of approaching puzzles."><meta property="og:type" content="article"><meta property="og:title" content="Fun With MonadPlus: The Success/Failure Monads"><meta property="og:image" content="http://home.jle0.com:4111/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="http://home.jle0.com:4111/entry/ident/list-monad.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/justinleblogdevelopment"><link rel="canonical" href="http://home.jle0.com:4111/entry/ident/list-monad.html"><link href="http://home.jle0.com:4111/favicon.ico" rel="shortcut icon"><link href="http://home.jle0.com:4111/css/toast.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/font.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/main.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/page/entry.css" rel="stylesheet" type="text/css"><link href="http://home.jle0.com:4111/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='justinleblogdevelopment';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-7', 'jle0.com');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-520df7c304b817b9"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/page/entry_toc.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/disqus_count.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/social.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="http://home.jle0.com:4111/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=645245675494525";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="http://home.jle0.com:4111/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="http://home.jle0.com:4111/">home</a></li><li><a href="http://home.jle0.com:4111/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Fun With MonadPlus: The Success/Failure Monads</h1><p class="entry-info">by <a class="author" href="http://home.jle0.com:4111/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/blog/tree/develop/copy/entries/list-monad.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/blog/tree/gh-pages/entry/ident/list-monad.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="http://home.jle0.com:4111/entry/ident/list-monad.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="http://home.jle0.com:4111/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled…really just the king of great languages.">Haskell</a>, <a href="http://home.jle0.com:4111/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you
too!). Lots of surveys and introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Monads. Haskell’s famous for them, but they are one of the most ill-understood concepts to the public. They are mostly shrouded in mystery because of their association with how Haskell models I/O. This reputation is undeserved. Monads don’t have anything to do with I/O.</p>
<p>This series is a part of a global effort to deshroud the mystery behind monads and show that they are fun! And exciting! And really just a way of chaining together functions that allow for new ways of approaching puzzles.</p>
<p>At the end of it all, we are going to be solving the classic logic puzzle, as old as time itself, using the List monad:</p>
<blockquote>
<p>A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his only boat can carry one thing at a time. He can’t leave the wolf alone with the goat, or the wolf will eat the goat. He can’t leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?</p>
</blockquote>
<p>Let us enter a brave new world!</p>
<h2 id="monads-reviewed">Monads, Reviewed</h2>
<p>As a Haskell blogger, I’m not allowed to write any straight-up monad tutorials, but I don’t need too — there are a wealth of great ones. <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Adit provides a great concise one</a>, and, if you want, <a href="http://www.haskell.org/haskellwiki/All_About_Monads">a more in depth one</a> is on the haskell.org wiki about using them in real life.</p>
<p>However, here is a short description of “monadic style”, as it applies to what we are going to do today.</p>
<p>Remember — different monads do not actually have any non-superficial relationship to one another. When we say monads, we just mean things that chain together functions “inside” wrappers, containers, or contexts. In our case, containers.</p>
<h2 id="maybe-maybe-not">Maybe, maybe not</h2>
<p>Let’s look at the most obvious container – a <code>Maybe a</code>. A <code>Maybe a</code> is a container that can either be <code>Just a</code> (representing a succesful result <code>a</code>) or a <code>Nothing</code> (representing a failed result).</p>
<aside>
<pre><code>###### Aside</code></pre>
<p>Hi! These asides are going to be for you readers that are unfamiliar with Haskell syntax. Feel free to ignore them if you already feel comfortable.</p>
Anyways, if you’ve ever done any object-oriented programming, you might be able to think of <code>Maybe a</code> as an abstract/virtual superclass with templates/generics — <code>Maybe&lt;a&gt;</code>, kinda. And that superclass has two subclasses: <code>Just&lt;a&gt;</code>, which has one public instance variable of type <code>a</code>, and <code>Nothing</code>, which contains no instance variables.
</aside>
<p>Often times you’ll have functions that fail, and you want to chain them. The easiest way is that any function that is chained onto a failed value will be skipped; a failure is the final result.</p>
<p>Consider the <code>halve</code> function, which returns <code>Just (x `div` 2)</code> on a succesful halving, or <code>Nothing</code> on an unsuccesful halving:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halve ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>                       <span class="co">-- 1</span>
halve x <span class="fu">|</span> even x    <span class="fu">=</span> <span class="dt">Just</span> (x <span class="ot">`div`</span> <span class="dv">2</span>)          <span class="co">-- 2</span>
        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span>                   <span class="co">-- 3</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<p>Hi again! There are some quick syntax features here.</p>
<ol type="1">
<li>This first line declares that the type of the function <code>halve</code> is <code>Int -&gt; Maybe Int</code>, which means that it takes in an <code>Int</code> and returns a <code>Maybe Int</code> — an integer wrapped in a “Maybe” container.</li>
<li>This says that if x is even, then return a succesful <code>Just (x `div` 2)</code>. <code>x `div` 2</code> is basically x divided by two, in case you couldn’t guess already.</li>
<li>Otherwise, return <code>Nothing</code> — a failure.</li>
</ol>
</aside>
<p>We can now chain <code>halve</code>s on results of other <code>halves</code>, and have any failures automatically propagate to the end and short circuit your entire computation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> halve <span class="dv">8</span>
<span class="dt">Just</span> <span class="dv">4</span>
λ<span class="fu">:</span> halve <span class="dv">7</span>
<span class="dt">Nothing</span>
λ<span class="fu">:</span> halve <span class="dv">8</span> <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Just</span> <span class="dv">2</span>
λ<span class="fu">:</span> halve <span class="dv">7</span> <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Nothing</span>                         <span class="co">-- 1</span>
λ<span class="fu">:</span> halve <span class="dv">6</span> <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Nothing</span>
λ<span class="fu">:</span> halve <span class="dv">6</span> <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Nothing</span>                         <span class="co">-- 2</span>
λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>)
<span class="dt">Nothing</span>                         <span class="co">-- 3</span>
λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Just</span> <span class="dv">2</span>
λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>) <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Nothing</span>                         <span class="co">-- 4</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
In this article, code that begins with <code>λ:</code> represents commands to be entered at the interactive prompt, ghci. Code that doesn’t is actual source code.
</aside>
<p>Some interesting points:</p>
<ol type="1">
<li>Note that this command doesn’t even bother with the second <code>halve</code>. It knows that the end result will be <code>Nothing</code> no matter what (because <code>halve 7</code> is <code>Nothing</code>), so it just skips right past the second <code>halve</code>.</li>
<li>Same thing here; it just skips right past the third <code>halve</code>, becuase <code>halve 6 &gt;&gt;= halve</code> is <code>Nothing</code>.</li>
<li>Somewhat interesting. <code>(\_ -&gt; Nothing)</code> is a function that returns <code>Nothing</code> no matter what. So chaining that at the end of <code>halve 32</code> (a <code>Just 12</code>) sort of means instant failure no matter what.</li>
<li>Disaterous! Even though halving 32 four times usually is fine, giving <code>Just 2</code>, having just one failure along the way means that the entire thing is a failure. Think of it as <code>Nothing &gt;&gt;= halve &gt;&gt;= halve &gt;&gt;= halve</code>.</li>
</ol>
<h2 id="do-notation">Do Notation</h2>
<p>Haskell provides a convenient way of writing chained <code>&gt;&gt;=</code>’s called do notation; here are a few samples matched with their equivalent <code>&gt;&gt;=</code> form:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> half <span class="dv">8</span>
<span class="dt">Just</span> <span class="dv">4</span>
λ<span class="fu">:</span> <span class="kw">do</span>
 <span class="fu">|</span>     half <span class="dv">8</span>
<span class="dt">Just</span> <span class="dv">4</span>

λ<span class="fu">:</span> halve <span class="dv">8</span> <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Just</span> <span class="dv">2</span>
λ<span class="fu">:</span> <span class="kw">do</span>
 <span class="fu">|</span>     x <span class="ot">&lt;-</span> halve <span class="dv">8</span>
 <span class="fu">|</span>     halve x
<span class="dt">Just</span> <span class="dv">2</span>

λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Just</span> <span class="dv">2</span>
λ<span class="fu">:</span> <span class="kw">do</span>
 <span class="fu">|</span>     x <span class="ot">&lt;-</span> halve <span class="dv">32</span>
 <span class="fu">|</span>     y <span class="ot">&lt;-</span> halve x
 <span class="fu">|</span>     z <span class="ot">&lt;-</span> halve y
 <span class="fu">|</span>     halve z
<span class="dt">Just</span> <span class="dv">2</span>

λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>) <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
<span class="dt">Nothing</span>
λ<span class="fu">:</span> <span class="kw">do</span>
 <span class="fu">|</span>     x <span class="ot">&lt;-</span> halve <span class="dv">32</span>
 <span class="fu">|</span>     <span class="dt">Nothing</span>
 <span class="fu">|</span>     y <span class="ot">&lt;-</span> halve x
 <span class="fu">|</span>     z <span class="ot">&lt;-</span> halve y
 <span class="fu">|</span>     halve z
<span class="dt">Nothing</span></code></pre></div>
<p>It’s kind of imperative-y — “do <code>halve 32</code> and assign the result (16) to <code>x</code>…do <code>halve x</code> and assign the result (8) to <code>y</code>…” — but remember, it’s still just a bunch of chained <code>&gt;&gt;=</code>’s in the end.</p>
<h2 id="failure-is-an-option">Failure is an option</h2>
<p>The important thing to note here is that “do” notation basically builds up one “giant” object. Remember the last two examples — the second to last one, all of those lines were in an effort to build one giant <code>Just 2</code> value. In the last example, all of those lines were in an effort to build one giant <code>Nothing</code> value. That’s why one <code>Nothing</code> “ruined” the whole thing. The entire computation is one big <code>Maybe a</code>. If at any point in your attempt to build that <code>Maybe a</code>, you fail, then you have <code>Nothing</code>.</p>
<p>This behavior of “fail anywhere, fail the entire thing” is a special subclass of Monads. Not all monads are like this. This special subclass of monads, we call “MonadPlus”. I know, the name isn’t really that fancy and it’s also slightly embarassing. But a MonadPlus is basically a monad that embodies this ideal of <em>“I am building up either a success or a failure…and if at any point I fail, the whole thing is a failure.”</em></p>
<p>What do I mean?</p>
<p>Well, “monads” really is just a way to allow things to return new objects based on the contents of previous objects. Given any object, there is technically more than one way to do this, obviously…you can have the “chaining” process be anything you want, arbitrarily. Sometimes, it’s useful to think of this chaining as a failure/success process. When we model chaining as a failure/success process, we say that we model it as a MonadPlus.</p>
<p>When you’re working with a MonadPlus, your failure case is called “empty”. In fact, you can type in <code>empty</code> instead of <code>Nothing</code>, and Haskell will know you mean <code>Nothing</code> — it’s like an alias.</p>
<p>Now let’s revisit the last do block and make it more generic, and just rephrase it in a form that we are going to be encountering more when we solve our problem with the List monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halveThriceOops ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
halveThriceOops n <span class="fu">=</span> <span class="kw">do</span>          <span class="co">-- call with n = 32</span>
    x  <span class="ot">&lt;-</span> <span class="dt">Just</span> n                <span class="co">-- Just 32              -- 1</span>
    y  <span class="ot">&lt;-</span> halve x               <span class="co">-- Just 16</span>
    empty                       <span class="co">-- Nothing              -- 2</span>
    z  <span class="ot">&lt;-</span> halve x&#39;              <span class="co">-- (skip)               -- 3</span>
    zz <span class="ot">&lt;-</span> halve x&#39;              <span class="co">-- (skip)</span>
    return zz                   <span class="co">-- (skip)               -- 4</span></code></pre></div>
<p>Note that I’ve also included a line-by-line ‘trace’ of the do block with what the monad “is” at that point. It is what is calculated on that line, and it would be the value returned if you just exited at that step.</p>
<ol type="1">
<li>We’re going to “initialize” by setting the whole result to be <code>Just n</code>, at first. This is slightly redundant becuase this is sort of dummy step — as soon as we put <code>n</code> in the <code>Just</code>, we “take it out” again and put it in <code>x</code>. (The arrows mean “take the content inside of the <code>Maybe</code> and put it in this value”) So while this is sort of redudant, the reason for this will be clear later. Also, it’s nice to just sort of see a nice “Step 0”</li>
<li>The failure. Remember, <code>empty</code> means “fail here automatically”, which, in a Maybe object, means <code>Nothing</code>.</li>
<li>Now from here on, nothing else even matters…the entire block is a failure!</li>
<li><code>return :: a -&gt; Maybe a</code> — it basically “always succeeds” with the value given to it. And if it wasn’t for the fact that the block already failed before it could get to this line, it would succeed with <code>zz</code>. This, too, is slightly redundant, but it’ll also make sense later. Remember, this is just a “succeed automatically with this value” — if we had written <code>return 5</code>, the entire block would have succeeded with a 5 if it didn’t already fail. If we had written <code>return x</code>, it would have succeeded with the original unchanged value!</li>
</ol>
<h3 id="guards">Guards</h3>
<p>Wouldn’t it be handy to have a function that says “fail right…here. if this condition is not met”? Sort of like a more judicious <code>empty</code>, which says “fail here no matter what”.</p>
<p>Luckily, Haskell gives us one in the standard library:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">guard ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m ()        <span class="co">-- 1</span>
guard <span class="dt">True</span>  <span class="fu">=</span> return ()
guard <span class="dt">False</span> <span class="fu">=</span> empty</code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<ol type="1">
<li><p>This is a type signature, like before. We say that <code>guard</code> is a function that takes a <code>Bool</code> and returns a <code>m ()</code> — a monad containing <code>()</code>. But we say that <code>m</code>, the monad, must be a MonadPlus.</p>
<p>For example, if we applied this to <code>Maybe</code>, the concrete signature would be <code>guard :: Bool -&gt; Maybe ()</code></p></li>
</ol>
</aside>
<p>So <code>guard</code> will make sure a condition is met, or else it fails the entire thing. If the condition is met, then it succeeds automatically and places a <code>()</code> in the value.</p>
<p>We can use this to re-implement <code>halve</code>, using do notation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halve ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
halve n <span class="fu">=</span> <span class="kw">do</span>                <span class="co">-- n = 8        n = 7</span>
    x <span class="ot">&lt;-</span> return n           <span class="co">-- Just 8       Just 7</span>
    guard <span class="fu">$</span> even x          <span class="co">-- Just ()      Nothing</span>
    return <span class="fu">$</span> x <span class="ot">`div`</span> <span class="dv">2</span>      <span class="co">-- Just 4       (skip)</span></code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
<code>guard $ even x</code> is no mystery…it is just shorthand for <code>guard (even x)</code>. We just don’t like writing all those parentheses out.
</aside>
<p>So…halve puts <code>n</code> into a <code>Just</code> to get it in the context of <code>Maybe</code>. Then, if <code>x</code> (which is just <code>n</code>) is not even, it fails right there. If not, it auto-succeeds with <code>x `div` 2</code>.</p>
<p>You can trust me when I say this works the exact same way!</p>
<p>As a friendly reminder, this entire block is “compiled”/desugared to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">halve<span class="ot"> n ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
halve n <span class="fu">=</span> return n <span class="fu">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> guard (even x)) <span class="fu">&gt;&gt;=</span> return (x <span class="ot">`div`</span> <span class="dv">2</span>)</code></pre></div>
<aside>
<pre><code>###### Note</code></pre>
<p>Some of this might seem a little convoluted…why didn’t we just do:</p>
<pre><code>halve :: Int -&gt; Maybe Int
halve n = do
    guard $ even n
    return $ n `div` 2</code></pre>
The answer is that we could…but just hang on tight for a bit and see why I didn’t write it this way!
</aside>
<h2 id="lists">Lists</h2>
<p>Well, this article is about the List monad and I have done very little to talk about it at all.</p>
<p>When I say “list monad”, I mean “one way that you can implement chaining operations on a list”. To be more precise, I should say “haskell’s default choice of chaining method on lists”. There is no “the list monad”…there is “a way we can make <em>list</em> a monad”.</p>
<p>And one way we can do it? We saw it before — yup! We can model lists as a MonadPlus — a method of chaining that revolves around successes and failures.</p>
<p>Don’t believe me? Let’s take the exact same <code>halve</code> function…but instead of returning a <code>Maybe Int</code>, we returned a list of <code>Int</code>s:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halve ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
halve n <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> return n
    guard <span class="fu">$</span> even x
    return <span class="fu">$</span> x <span class="ot">`div`</span> <span class="dv">2</span></code></pre></div>
<p>This is…the exact same function. We didn’t do anything but change the type signature. But because you believe me when I say that List is a MonadPlus…this should work, right? <code>guarad</code> should work for any MonadPlus.</p>
<p>How is list a meaningful MonadPlus? Simple: a “failure” is an empty list. A “success” is a non-empty list.</p>
<p>Watch:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> halve <span class="dv">8</span>
[<span class="dv">4</span>]
λ<span class="fu">:</span> halve <span class="dv">7</span>
[]
λ<span class="fu">:</span> halve <span class="dv">8</span> <span class="fu">&gt;&gt;=</span> halve
[<span class="dv">4</span>]
λ<span class="fu">:</span> halve <span class="dv">7</span> <span class="fu">&gt;&gt;=</span> halve
[]
λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
[<span class="dv">2</span>]
λ<span class="fu">:</span> halve <span class="dv">32</span> <span class="fu">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> empty) <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve <span class="fu">&gt;&gt;=</span> halve
[]</code></pre></div>
<p>Oh my goodness. <code>Nothing</code> is just <code>[]</code>…<code>Just a</code> is now just <code>[a]</code>. It’s al so clear now. Why does <code>Maybe</code> even exist? What an outrage! This whole time! It’s all a lie!</p>
<p>In fact, if we generalize our type signature for <code>halve</code>, we can do some crazy things…</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">genericHalve ::</span> <span class="dt">MonadPlus</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span>
genericHalve n <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> return n
    guard <span class="fu">$</span> even x
    return x</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> genericHalve <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="dt">Just</span> <span class="dv">4</span>
λ<span class="fu">:</span> genericHalve <span class="dv">8</span><span class="ot"> ::</span> [<span class="dt">Int</span>]
[<span class="dv">4</span>]
λ<span class="fu">:</span> genericHalve <span class="dv">7</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
<span class="dt">Nothing</span>
λ<span class="fu">:</span> genericHalve <span class="dv">7</span><span class="ot"> ::</span> [<span class="dt">Int</span>]
[]</code></pre></div>
<aside>
<pre><code>###### Aside</code></pre>
When we say something like <code>genericHalve 8 :: Maybe Int</code>, it means “I want <code>genericHalve 8</code>…and I want the type to be <code>Maybe Int</code>.” This is necessary here becuase in our <code>genericHalve</code> can be <em>any</em> MonadPlus, so we have to tell ghci which MonadPlus we want.
</aside>
<p>So there you have it. Maybe and lists are one and the same. Lists <em>do</em> too represent the concept of failure and success. So…what’s the difference?</p>
<h3 id="a-list-apart">A List Apart</h3>
<p>Lists can model failure the same way that Maybe can. But it should be apparent that list can model success…very interestingly.</p>
<p>Consider <code>[3, 5]</code>. Clearly this is to represent some sort of “success”. But what?</p>
<p>How about we look at it this way: <code>[3, 5]</code> represents two separate <em>paths</em> to success. When we look at a <code>Just 5</code>, we see a computation that succeeded with a 5. When we see a <code>[3, 5]</code>, we may interpret it as a computation that had two possible succesful paths: one succeeding with a 3 and another with a 5.</p>
<p>You can also say that it represents a computaiton that <em>could have chosen</em> to succeed in a 3, or a 5. In this way, the list monad is often referred to as the “choice” monad.</p>
<p>This view of a list as a collection of possible successes or choices of successes is not the only way to think of a list as a monad…but it is the way that the Haskell community has adopted as arguably the most useful. (The other main way is to approach it completely differently, making list not even a MonadPlus and therefore not representing failure or success at all)</p>
<p>Think of it this way: A value goes through a long and arduous journey with many choices and possible paths and forks. At the end of it, you have the result of every path that could have lead to a success. Contrast this to the <code>Maybe</code> monad, where a value goes through this arduous journey, but never has any choice. There is only one path — succesful, or otherwise. A <code>Maybe</code> is deterministic…a list provides a choice in paths.</p>
<p>Let’s take a simple example: <code>halveOrDouble</code>. It provides two succesful paths if you are even: halving and doubling. It only provides one choice or possible path to success if you are odd: doubling. In this way it is slightly racist.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halveOrDouble ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
halveOrDouble n <span class="fu">|</span> even n    <span class="fu">=</span> [n <span class="ot">`div`</span> <span class="dv">2</span>, n <span class="fu">*</span> <span class="dv">2</span>]
                <span class="fu">|</span> otherwise <span class="fu">=</span> [n <span class="fu">*</span> <span class="dv">2</span>]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> halveOrDouble <span class="dv">6</span>
[<span class="dv">3</span>, <span class="dv">6</span>]
λ<span class="fu">:</span> halveOrDouble <span class="dv">7</span>
[  <span class="dv">14</span>]</code></pre></div>
<p>As you can see in the first case, with the 6, there are two paths to success: the halve, and the double. In the second case, with the 7, there is only one — the double.</p>
<p>How about we subject a number to this halving-or-doubling journey twice? What do we expect?</p>
<ol type="1">
<li>The path of halve-halve only works if the number is divisible by two twice. So this is only a succesful path if the number is divisible by four.</li>
<li>The path of halve-double only works if the number is even. So this is only a succesful path in that case.</li>
<li>The path of double-halve will work in all cases! It is a success always.</li>
<li>The path of double-double will also work in all cases…it’ll never fail for our sojourning number!</li>
</ol>
<p>So…halving-or-doubling twice has two possible succesful paths for an odd number, three succesful paths for a number divisible by two but not four, and four succesful paths for a number divisible by four.</p>
<p>Let’s try it out:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> return <span class="dv">5</span> <span class="fu">&gt;&gt;=</span> halveOrDouble <span class="fu">&gt;&gt;=</span> halveOrDouble
[       <span class="dv">5</span>, <span class="dv">20</span>]
λ<span class="fu">:</span> return <span class="dv">6</span> <span class="fu">&gt;&gt;=</span> halveOrDouble <span class="fu">&gt;&gt;=</span> halveOrDouble
[    <span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">24</span>]
λ<span class="fu">:</span> return <span class="dv">8</span> <span class="fu">&gt;&gt;=</span> halveOrDouble <span class="fu">&gt;&gt;=</span> halveOrDouble
[ <span class="dv">2</span>, <span class="dv">8</span>, <span class="dv">8</span>, <span class="dv">32</span>]</code></pre></div>
<p>The first list represents the results of all of the possible succesful paths 5 could have taken to “traverse” the dreaded <code>halveOrDouble</code> landscape twice — double-halve, or double-double. The second, 6 could have emerged succesful with halve-double, double-halve, or double-double. 8 had the succesful paths it could have taken.</p>
<p>Let’s look at this in the do notation form to offer some possible insight:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halveOrDoubleTwice ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
halveOrDoubleTwice n <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> return n
    y <span class="ot">&lt;-</span> halveOrDouble x
    z <span class="ot">&lt;-</span> halveOrDouble y
    return z</code></pre></div>
<p>Do notation describes <strong>a single path of a value</strong>. This is slightly confusing at first. But look at it — it has the exact same form as a Maybe monad do block.</p>
<p>This thing describes, in general terms, the path of a single value. <code>x</code>, <code>y</code>, and <code>z</code> are not lists — they represent a single value, in the middle of the treacherous journey.</p>
<p>Here is an illustration, tracing out “individual paths”:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halveOrDoubleTwice ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
halveOrDoubleTwice n <span class="fu">=</span> <span class="kw">do</span>       <span class="co">-- halveOrDoubleTwice 6</span>
    x <span class="ot">&lt;-</span> return n               <span class="co">-- x =              Just 6</span>
    y <span class="ot">&lt;-</span> halveOrDouble x        <span class="co">-- y =      Just 3          Just 12</span>
    z <span class="ot">&lt;-</span> halveOrDouble y        <span class="co">-- z = Nothing  Just 6  Just 6  Just 24</span>
    return z                    <span class="co">--     Nothing  Just 6  Just 6  Just 24</span></code></pre></div>
<p>where you take the left path if you want to halve, and the right path if you want to double.</p>
<p>Remember, just like in the Maybe monad, the <code>x</code>, <code>y</code>, and <code>z</code> represent the <em>value</em> inside the object — <code>x</code> represents the 6, <code>y</code> represents either the 3 or the 12, depending on what path you take. This binding of <code>x</code>, <code>y</code>, or <code>z</code> remains the same throughout the remainder of the path.</p>
<p>Here is the tricky part: the last line, <code>return z</code>, returns <strong>what <code>z</code> is on that path</strong>. In the halve-double path, <code>z</code> is 6. In the <code>double-double</code> path, <code>z</code> is 24.</p>
<p>What if we had typed <code>return y</code> instead of <code>return z</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halveOrDoubleDance ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
halveOrDoubleDance n <span class="fu">=</span> <span class="kw">do</span>       <span class="co">-- halveOrDoubleDance 6</span>
    x <span class="ot">&lt;-</span> return n               <span class="co">-- x &lt;-             Just 6</span>
    y <span class="ot">&lt;-</span> halveOrDouble x        <span class="co">-- y &lt;-     Just 3          Just 12</span>
    z <span class="ot">&lt;-</span> halveOrDouble y        <span class="co">-- z &lt;- Nothing Just 6  Just 6  Just 24</span>
    return z                    <span class="co">--      Nothing Just 3  Just 12 Just 12</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> halveOrDoubleDance <span class="dv">6</span>
[    <span class="dv">3</span>,<span class="dv">12</span>,<span class="dv">12</span>]
λ<span class="fu">:</span> halveOrDoubleDance <span class="dv">7</span>
[      <span class="dv">14</span>,<span class="dv">14</span>]
λ<span class="fu">:</span> halveOrDoubleDance <span class="dv">8</span>
[ <span class="dv">4</span>, <span class="dv">4</span>,<span class="dv">16</span>,<span class="dv">16</span>]</code></pre></div>
<figure>
<img src="/img/entries/list-monad/halvedouble.png" title="halveOrDoubleDance 6" alt="halveOrDoubleDance 6, all journeys illustrated" /><figcaption><em>halveOrDoubleDance 6</em>, all journeys illustrated</figcaption>
</figure>
<p>Huh. What happened here?</p>
<p>Again, there are four possible paths/journies…only three of them end in success. In the halve-halve path…it fails. Now let’s see what happens in the “halve-double” path. In this case, it might be useful to look at the corresponding Maybe do-block, and using the choices we make explicitly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">halveOrDoubleDance&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
halveOrDoubleDance&#39; n <span class="fu">=</span> <span class="kw">do</span>      <span class="co">-- halveOrDoubleDance&#39; 6</span>
    x <span class="ot">&lt;-</span> return n               <span class="co">-- Just 6</span>
    y <span class="ot">&lt;-</span> halve x                <span class="co">-- Just 3</span>
    z <span class="ot">&lt;-</span> double y               <span class="co">-- Just 6  (double n = Just n)</span>
    return y                    <span class="co">-- Just 3</span></code></pre></div>
<p>It is clear in this case that <code>return y</code> will give you the value of <code>y</code> <strong>on that path</strong>.</p>
<p>In our halve-double path, the value of <code>y</code> (which is bound on the second line) is 3. That’s why when we say <code>return y</code>, it is <code>[3]</code>.</p>
<p>Remember — you have to treat everything as its own individual path. In the halve-double path, <code>y</code> is 3. So <code>return y</code> returns 3.</p>
<h3 id="solving-real-ish-problems">Solving real-ish problems</h3>
<p>Okay, we are <em>almost</em> ready to finally implement our solution to the Wolf/Goat/Cabbage puzzle. Just one more demonstration.</p>
<p>Let’s try this somewhat practical question:</p>
<p>“What operations on a number will make it a multiple of three?”</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isMultThree ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>                              <span class="co">-- 1</span>
isMultThree a <span class="fu">=</span> a <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span>

<span class="ot">testNumber ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]
testNumber n <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> return n                                       <span class="co">-- 2</span>
    (f, fName)  <span class="ot">&lt;-</span>  [ ((<span class="fu">*</span><span class="dv">2</span>)         , <span class="st">&quot;times two&quot;</span>)      <span class="co">-- 3</span>
                    , ((<span class="fu">*</span><span class="dv">3</span>)         , <span class="st">&quot;times three&quot;</span>)
                    , ((<span class="fu">+</span><span class="dv">2</span>)         , <span class="st">&quot;plus two&quot;</span>)
                    , ((<span class="fu">+</span><span class="dv">3</span>)         , <span class="st">&quot;plus three&quot;</span>)
                    , ((<span class="fu">^</span><span class="dv">2</span>)         , <span class="st">&quot;square&quot;</span>)
                    , ((<span class="fu">+</span><span class="dv">1</span>)<span class="fu">.</span>(<span class="fu">^</span><span class="dv">2</span>)    , <span class="st">&quot;square plus 1&quot;</span>)
                    , ((<span class="fu">+</span><span class="dv">1</span>)<span class="fu">.</span>(<span class="fu">^</span><span class="dv">3</span>)    , <span class="st">&quot;cube plus 1&quot;</span>)
                    , (id           , <span class="st">&quot;stay the same&quot;</span>)
                    ]
    <span class="kw">let</span> z <span class="fu">=</span> f x                                         <span class="co">-- 4</span>

    guard <span class="fu">$</span> isMultThree z                               <span class="co">-- 5</span>
    return fName                                        <span class="co">-- 6</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">:</span> testNumber <span class="dv">4</span>
[<span class="st">&quot;times three&quot;</span>, <span class="st">&quot;plus two&quot;</span>]
λ<span class="fu">:</span> testNumber <span class="dv">5</span>
[<span class="st">&quot;times three&quot;</span>, <span class="st">&quot;cube plus 1&quot;</span>]
λ<span class="fu">:</span> testNumber <span class="dv">6</span>
[<span class="st">&quot;times two&quot;</span>, <span class="st">&quot;times three&quot;</span>, <span class="st">&quot;plus three&quot;</span>, <span class="st">&quot;square&quot;</span>, <span class="st">&quot;stay the same&quot;</span>]
λ<span class="fu">:</span> testNumber <span class="dv">7</span>
[<span class="st">&quot;times three&quot;</span>, <span class="st">&quot;plus two&quot;</span>]
λ<span class="fu">:</span> testNumber <span class="dv">8</span>
[<span class="st">&quot;times three&quot;</span>, <span class="st">&quot;cube plus 1&quot;</span>]</code></pre></div>
<p>Let’s go over this step-by-step:</p>
<ol type="1">
<li>First of all, define the utility function <code>isMultThree a</code>, which is true when <code>a</code> is a multiple of three and false when it isn’t.</li>
<li>In the block, <code>x</code> is set to be a choice in the journey. This choice is always going to be <code>n</code>, but if we wanted to test multiple numbers, we could do something like <code>x &lt;- [n, n+1, n+2]</code>.</li>
<li>Now, the journey digerges. <code>f</code> and <code>fName</code> is now a value that depends on the path we took. If we took the first path, <code>f = (*2)</code> (the doubling function) and <code>fName = &quot;times two&quot;</code>. On the second path, <code>f = (*3)</code> (the tripling function) and <code>fName = &quot;times three&quot;</code>, etc.</li>
<li>We alias <code>z</code> to be the function we chose applied to <code>x</code>. If we had chosen the path <code>f = (*2)</code>, <code>z</code> would be <code>(*2) x</code>, which is <code>x*2</code>.</li>
<li>We check if <code>z</code> is a multiple of three. If it isn’t, the journey sadly ends here. For example, if we called the function with <code>n = 4</code>, and we had chosen <code>f = (^2)</code> (the square function), this journey (involving the choice of <code>(^2)</code>) would meet its failure here…but the journey with the choice <code>f = (+2)</code> would not!</li>
<li>At the end of the weary journey, we return the name of the function we chose. This step is never reached for failed journeys.</li>
</ol>
<p>Here is a diagram!</p>
<figure>
<img src="/img/entries/list-monad/testnumber.png" title="testNumber 5" alt="testNumber 5, all journeys illustrated" /><figcaption><em>testNumber 5</em>, all journeys illustrated</figcaption>
</figure>
<!-- ### Maybe? -->
<!-- What do I mean? -->
<!-- Let's look at the most obvious container -- a `Maybe a`.  A `Maybe a` is a -->
<!-- container that can either be `Just a` (representing a succesful result `a`) or -->
<!-- a `Nothing` (representing a failed result). -->
<!-- <aside> -->
<!--     ###### Aside -->
<!-- Hi!  These asides are going to be for you readers that are unfamiliar with -->
<!-- Haskell syntax.  Feel free to ignore them if you already feel comfortable. -->
<!-- Anyways, if you've ever done any object-oriented programming, you might be -->
<!-- able to think of `Maybe a` as an abstract/virtual superclass with -->
<!-- templates/generics --- `Maybe<a>`, kinda.  And that superclass has two -->
<!-- subclasses: `Just<a>`, which has one public instance variable of type `a`, and -->
<!-- `Nothing`, which contains no instance variables. -->
<!-- </aside> -->
<!-- The Monad instance of Maybe is useful because it allows us to chain -->
<!-- failable-computations. -->
<!-- For example, the `halve` function, which returns ``Just (x `div` 2)`` on a -->
<!-- succesful halving, or `Nothing` on an unsuccesful halving: -->
<!-- ~~~haskell -->
<!-- halve :: Int -> Maybe Int                       -- 1 -->
<!-- halve x | even x    = Just (x `div` 2)          -- 2 -->
<!--         | otherwise = Nothing                   -- 3 -->
<!-- ~~~ -->
<!-- <aside> -->
<!--     ###### Aside -->
<!-- Hi again!  There are some quick syntax features here. -->
<!-- 1.  This first line declares that the type of the function `halve` is `Int -> -->
<!--     Maybe Int`, which means that it takes in an `Int` and returns a `Maybe -->
<!--     Int` --- an integer wrapped in a "Maybe" container. -->
<!-- 2.  This says that if x is even, then return a succesful ``Just (x `div` 2)``. -->
<!--     ``x `div` 2`` is basically x divided by two, in case you couldn't guess -->
<!--     already. -->
<!-- 3.  Otherwise, return `Nothing` --- a failure. -->
<!-- </aside> -->
<!-- ~~~haskell -->
<!-- λ: halve 6 -->
<!-- Just 3 -->
<!-- λ: halve 7 -->
<!-- Nothing -->
<!-- ~~~ -->
<!-- <aside> -->
<!--     ###### Aside -->
<!-- In this article, code that begins with `λ: ` represents commands to be entered -->
<!-- at the interactive prompt, ghci.  Code that doesn't is actual source code. -->
<!-- </aside> -->
<!-- How would we write `halveTwice`? -->
<!-- ~~~haskell -->
<!-- halveTwice :: Int -> Maybe Int -->
<!-- halveTwice x = -->
<!--     case halve x of                             -- 1 -->
<!--         Just x2 -> halve x2 -->
<!--         Nothing -> Nothing -->
<!-- ~~~ -->
<!-- <aside> -->
<!--     ###### Aside -->
<!-- 1.  Like a case/switch statement in any language, the path it takes depends on -->
<!--     what you give it.  In this case, it calculates `halve x`, and decides with -->
<!--     path depending on what `halve x` is. -->
<!-- </aside> -->
<!-- ~~~haskell -->
<!-- λ: halveTwice 6 -->
<!-- Nothing -->
<!-- λ: halveTwice 8 -->
<!-- Just 2 -->
<!-- ~~~ -->
<!-- Okay, this isn't too clean code.  What about `halveThrice`? -->
<!-- ~~~haskell -->
<!-- halveThrice :: Int -> Maybe Int -->
<!-- halveThrice x = -->
<!--     case halve x of -->
<!--         Just x2 -> -->
<!--             case halve x2 of -->
<!--                 Just x3     -> halve x3 -->
<!--                 Nothing     -> Nothing -->
<!--         Nothing     -> -->
<!--             Nothing -->
<!-- ~~~ -->
<!-- ~~~haskel -->
<!-- λ: halveThrice 4 -->
<!-- Nothing -->
<!-- λ: halveThrice 8 -->
<!-- Just 1 -->
<!-- ~~~ -->
<!-- Now that's just downright ugly. -->
<!-- What are we trying to do here, exactly? -->
<!-- Basically, we want to generate a new `Maybe` based on what a current `Maybe` -->
<!-- contains.  We want to chain these. -->
<!-- Monads to the rescue! -->
<!-- ~~~haskell -->
<!-- halveTwice :: Int -> Maybe Int -->
<!-- halveTwice = (halve x) >>= halve -->
<!-- halveThrice :: Int -> Maybe Int -->
<!-- halveThrice = (halve x) >>= halve >>= halve -->
<!-- ~~~ -->
<!-- And that's it! -->
<!-- `>>=` takes care of the plumbing (the ugly case statements) for us and -->
<!-- abstracts it away.  Want to know how?  Too bad!  This isn't a monad tutorial! -->
<!-- Read a real one :) -->
<!-- Anyways, the cool thing about monads in Haskell is that Haskell provides -->
<!-- convenient syntactic sugar for using `>>=`: -->
<!-- ~~~haskell -->
<!-- halveTwice :: Int -> Maybe Int -->
<!-- halveTwice x = do -->
<!--     x2  <- halve x -->
<!--     halve x2 -->
<!-- ~~~ -->
<!-- which is the same as: -->
<!-- ~~~haskell -->
<!-- halveTwice :: Int -> Maybe Int -->
<!-- halveTwice x = halve x >>= (\x2 -> halve x2)    -- 1 -->
<!-- ~~~ -->
<!-- which is -->
<!-- ~~~haskell -->
<!-- halveTwice :: Int -> Maybe Int -->
<!-- halveTwice x = halve x >>= halve -->
<!-- ~~~ -->
<!-- <aside> -->
<!--     ###### Aside -->
<!-- 1. Haskell has the construct `(\x -> f x)` which is basically a function that -->
<!--    takes `x` and returns `f x`.  So `(\x2 -> halve x2)` is a function that -->
<!--    takes an `x2` and returns `halve x2`.  This is exactly the same as the -->
<!--    function `halve` --- it takes an `x` and returns `halve x`. -->
<!-- </aside> -->
<!-- We can also do `halveFourTimes`: -->
<!-- ~~~haskell -->
<!-- halveFourTimes :: Int -> Maybe Int -->
<!-- halveFourTimes x = do -->
<!--     x2 <- halve x -->
<!--     x3 <- halve x2 -->
<!--     x4 <- halve x3 -->
<!--     halve x4 -->
<!-- ~~~ -->
<!-- Imagine having to do that manually! -->
<!-- ### The do block -->
<!-- Note one interesting thing about a `>>=` based definition of `halveFourTimes`: -->
<!-- ~~~haskell -->
<!-- halveFourTimes :: Int -> Maybe Int -->
<!-- halveFourTimes = halve x >>= halve >>= halve >>= halve -->
<!-- ~~~ -->
<!-- Note that at any time, if *any* of those `halve`s fail, the entire thing -->
<!-- fails. -->
<!-- This is how `Maybe` works --- if a computation fails, then all computations -->
<!-- deriving from that computation will also fail, necessarily. -->
<!-- Think about something like this: -->
<!-- ~~~haskell -->
<!-- halveFourTimesOops :: Int -> Maybe Int -->
<!-- halveFourTimesOops x = do -->
<!--     x2 <- halve x -->
<!--     x3 <- halve x2 -->
<!--     _  <- Nothing                       -- 1 -->
<!--     x4 <- halve x3 -->
<!--     halve x4 -->
<!-- ~~~ -->
<!-- <aside> -->
<!--     ###### Aside -->
<!-- 1.  An underscore `_` in Haskell is a wildcard; basically, it says "store this -->
<!--     value somewhere, but I don't need it again ever so I won't even bother -->
<!--     giving it a name." -->
<!-- </aside> -->
<!-- Now watch: -->
<!-- ~~~haskell -->
<!-- λ: halveFourTimes 32 -->
<!-- Just 2 -->
<!-- λ: halveFourTimesOops 32 -->
<!-- Nothing -->
<!-- ~~~ -->
<!-- That's what `Maybe` really is --- it chains together failable computations. -->
<!-- But if at any point in time, a computaion fails, then the entire full chained -->
<!-- computation is now a failure, no matter what. -->
<!-- To convince you, let's break down a simple `>>=` style chaining of -->
<!-- `halveTwiceOops`: -->
<!-- ~~~haskell -->
<!-- λ: halve 8 >>= (\_ -> Nothing) >>= halve -->
<!-- Nothing -->
<!-- ~~~ -->
<!-- What is `halve 8 >>= (\_ -> Nothing)`, anyway?  It is "ignore the result of -->
<!-- `halve 8` and return `Nothing` no matter what": -->
<!-- ~~~haskell -->
<!-- λ: halve 8 >>= (\_ -> Nothing) -->
<!-- Nothing -->
<!-- ~~~ -->
<!-- So obviously, we expect `Nothing >>= halve` to return `Nothing`...you can't -->
<!-- halve a failure! -->
<!-- ~~~haskell -->
<!-- λ: Nothing >>= halve -->
<!-- Nothing -->
<!-- ~~~ -->
<!-- So that's why, if at any point along the chain you have a failure, the entire -->
<!-- thing fails. -->
<!-- Okay, now let's get to the actual problem (finally!). -->
<!-- Okay, let's back up.  When we say "functor", we mean things that have the -->
<!-- ability to apply functions "inside" them. -->
<!-- ~~~haskell -->
<!-- -- Normal function application, with $ -->
<!-- λ: (*2) $ 3 -->
<!-- 6 -->
<!-- -- Function application inside a container, with <$> -->
<!-- λ: (*2) <$> [3] -->
<!-- [6] -->
<!-- λ: (*2) <$> Just 3 -->
<!-- -- "Just" is just a container that contains one value, the 3 -->
<!-- Just 6 -->
<!-- λ: (*2) <$> [3,4,5] -->
<!-- [6,8,10] -->
<!-- ~~~ -->
<!-- Note the last one...the List functor...we can say that the list -->
<!-- "simultaneously contains" 3, 4, and 5...just like a Maybe "contains" a 3.  So -->
<!-- when we apply the function `(*2)` (the doubling function) to what is "inside" -->
<!-- a List...we apply it to all things simultaneously inside the list (3, 4, and -->
<!-- 5). -->
<!-- Now, when we say "monad", we mean things that have the ability to create new -->
<!-- objects from the contents of the previous object. -->
<!-- For example, we want to create a `Just something` from the contents of -->
<!-- `Just 5`. So we write a function `f :: Int -> Just Int`, which takes an int -->
<!-- (in this case, the 5) and --></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Practical Monads&quot;</b>.  Find the rest of the entries in this series at its <a href="http://home.jle0.com:4111/entries/series/+practical-monads.html" class="tag-a-series" title="Ongoing series exploring interesting objects and their curious monad
instances."> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="http://home.jle0.com:4111/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="http://home.jle0.com:4111/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="http://home.jle0.com:4111/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="http://home.jle0.com:4111/entries/series/+practical-monads.html" class="tag-a-series">+Practical Monads</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="http://home.jle0.com:4111/entry/introducing-in-code.html">Introducing “in Code”!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://home.jle0.com:4111/entry/ident/list-monad.html';
    this.page.identifier = 'list-monad';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//justinleblogdevelopment.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-facebook" title="Friend me on Facebook!" href="https://facebook.com/mstksg">Facebook</a></li><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/justinleblogdevelopment">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=justinleblogdevelopment">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>